fn main() -> i32 {
  // Stage0: placeholder Mee "compiler".
  // Validates full pipeline with hardcoded input.
  let stage0_ok: i32 = compile_stub();
  if (stage0_ok != 0) { return 1; }

  // Stage1: test memory-based AST/IR storage.
  let ast_ok: i32 = test_mem_ast();
  if (ast_ok != 1) { return 2; }

  let ir_ok: i32 = test_mem_ir();
  if (ir_ok != 1) { return 3; }

  // All stages passed
  return 0;
}

fn compile_stub() -> i32 {
  // Hardcoded source for: fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }
  // Lexer uses char_at(pos) to simulate input without strings/arrays.
  let pos: i32 = 0;
  let ok: i32 = parse_program(pos);
  if (ok == 1) { return 0; }
  return 1;
}

// Minimal AST encoded as scalar locals (no arrays yet).
// Node kinds.
fn nk_int() -> i32 { return 1; }
fn nk_return() -> i32 { return 2; }
fn nk_ident() -> i32 { return 3; }
fn nk_let() -> i32 { return 4; }
fn nk_add() -> i32 { return 5; }

fn parse_program(pos: i32) -> i32 {
  let p: i32 = pos;
  // Expect: fn main() -> i32 { let x: i32 = 1; return x; }
  let cur: i32 = p;
  let tok: i32 = lex(cur);
  let kind: i32 = lex_kind(tok);
  let next: i32 = lex_next(tok);
  if (kind != tok_fn()) { return 0; }

  let tok2: i32 = lex(next);
  let kind2: i32 = lex_kind(tok2);
  let next2: i32 = lex_next(tok2);
  if (kind2 != tok_ident()) { return 0; }
  let main_start: i32 = skip_ws(next);
  let main_id: i32 = ident_id(main_start, next2);
  if (main_id == 0) { return 0; }

  let tok3: i32 = lex(next2);
  if (lex_kind(tok3) != tok_lparen()) { return 0; }
  let next3: i32 = lex_next(tok3);

  let tok4: i32 = lex(next3);
  if (lex_kind(tok4) != tok_rparen()) { return 0; }
  let next4: i32 = lex_next(tok4);

  let tok5: i32 = lex(next4);
  if (lex_kind(tok5) != tok_arrow()) { return 0; }
  let next5: i32 = lex_next(tok5);

  let tok6: i32 = lex(next5);
  if (lex_kind(tok6) != tok_i32()) { return 0; }
  let next6: i32 = lex_next(tok6);

  let tok7: i32 = lex(next6);
  if (lex_kind(tok7) != tok_lbrace()) { return 0; }
  let next7: i32 = lex_next(tok7);

  let tok8: i32 = lex(next7);
  if (lex_kind(tok8) != tok_let()) { return 0; }
  let next8: i32 = lex_next(tok8);

  let tok9: i32 = lex(next8);
  if (lex_kind(tok9) != tok_ident()) { return 0; }
  let next9: i32 = lex_next(tok9);
  let ident_start: i32 = skip_ws(next8);
  let let_ident: i32 = ident_id(ident_start, next9);
  if (let_ident == 0) { return 0; }

  let tok10: i32 = lex(next9);
  if (lex_kind(tok10) != tok_colon()) { return 0; }
  let next10: i32 = lex_next(tok10);

  let tok11: i32 = lex(next10);
  if (lex_kind(tok11) != tok_i32()) { return 0; }
  let next11: i32 = lex_next(tok11);

  let tok12: i32 = lex(next11);
  if (lex_kind(tok12) != tok_eq()) { return 0; }
  let next12: i32 = lex_next(tok12);

  let tok13: i32 = lex(next12);
  if (lex_kind(tok13) != tok_int()) { return 0; }
  let next13: i32 = lex_next(tok13);
  let int_start: i32 = skip_ws(next12);
  let expr_value: i32 = int_value(int_start, next13);

  let tok14: i32 = lex(next13);
  if (lex_kind(tok14) != tok_semi()) { return 0; }
  let next14: i32 = lex_next(tok14);

  let tok15: i32 = lex(next14);
  if (lex_kind(tok15) != tok_let()) { return 0; }
  let next15: i32 = lex_next(tok15);

  let tok16: i32 = lex(next15);
  if (lex_kind(tok16) != tok_ident()) { return 0; }
  let next16: i32 = lex_next(tok16);
  let ident_start2: i32 = skip_ws(next15);
  let let_ident2: i32 = ident_id(ident_start2, next16);
  if (let_ident2 == 0) { return 0; }

  let tok17: i32 = lex(next16);
  if (lex_kind(tok17) != tok_colon()) { return 0; }
  let next17: i32 = lex_next(tok17);

  let tok18: i32 = lex(next17);
  if (lex_kind(tok18) != tok_i32()) { return 0; }
  let next18: i32 = lex_next(tok18);

  let tok19: i32 = lex(next18);
  if (lex_kind(tok19) != tok_eq()) { return 0; }
  let next19: i32 = lex_next(tok19);

  let tok20: i32 = lex(next19);
  if (lex_kind(tok20) != tok_int()) { return 0; }
  let next20: i32 = lex_next(tok20);
  let int_start2: i32 = skip_ws(next19);
  let expr_value2: i32 = int_value(int_start2, next20);

  let tok21: i32 = lex(next20);
  if (lex_kind(tok21) != tok_semi()) { return 0; }
  let next21: i32 = lex_next(tok21);

  let tok22: i32 = lex(next21);
  if (lex_kind(tok22) != tok_return()) { return 0; }
  let next22: i32 = lex_next(tok22);

  let tok23: i32 = lex(next22);
  if (lex_kind(tok23) != tok_ident()) { return 0; }
  let next23: i32 = lex_next(tok23);
  let ret_start: i32 = skip_ws(next22);
  let ret_ident: i32 = ident_id(ret_start, next23);

  let tok24: i32 = lex(next23);
  if (lex_kind(tok24) != tok_plus()) { return 0; }
  let next24: i32 = lex_next(tok24);

  let tok25: i32 = lex(next24);
  if (lex_kind(tok25) != tok_ident()) { return 0; }
  let next25: i32 = lex_next(tok25);
  let ret_start2: i32 = skip_ws(next24);
  let ret_ident2: i32 = ident_id(ret_start2, next25);

  let tok26: i32 = lex(next25);
  if (lex_kind(tok26) != tok_semi()) { return 0; }
  let next26: i32 = lex_next(tok26);

  let tok27: i32 = lex(next26);
  if (lex_kind(tok27) != tok_rbrace()) { return 0; }

  // Build AST using memory-based storage (Stage 1).
  // Node 0: let x = (expr at node 1)
  ast_set(0, nk_let(), let_ident, 1, 0);
  // Node 1: int 1
  ast_set(1, nk_int(), expr_value, 0, 0);
  // Node 2: let y = (expr at node 3)
  ast_set(2, nk_let(), let_ident2, 3, 0);
  // Node 3: int 2
  ast_set(3, nk_int(), expr_value2, 0, 0);
  // Node 4: ident x
  ast_set(4, nk_ident(), ret_ident, 0, 0);
  // Node 5: ident y
  ast_set(5, nk_ident(), ret_ident2, 0, 0);
  // Node 6: add (node 4, node 5)
  ast_set(6, nk_add(), 4, 5, 0);
  // Node 7: return (node 6)
  ast_set(7, nk_return(), 6, 0, 0);

  // Validate the AST stream from memory.
  if (ast_kind(0) != nk_let()) { return 0; }
  if (ast_a(0) == 0) { return 0; }
  if (ast_b(0) != 1) { return 0; }
  if (ast_kind(1) != nk_int()) { return 0; }
  if (ast_a(1) != 1) { return 0; }
  if (ast_kind(2) != nk_let()) { return 0; }
  if (ast_a(2) == 0) { return 0; }
  if (ast_b(2) != 3) { return 0; }
  if (ast_kind(3) != nk_int()) { return 0; }
  if (ast_a(3) != 2) { return 0; }
  if (ast_kind(4) != nk_ident()) { return 0; }
  if (ast_a(4) != ast_a(0)) { return 0; }
  if (ast_kind(5) != nk_ident()) { return 0; }
  if (ast_a(5) != ast_a(2)) { return 0; }
  if (ast_kind(6) != nk_add()) { return 0; }
  if (ast_a(6) != 4) { return 0; }
  if (ast_b(6) != 5) { return 0; }
  if (ast_kind(7) != nk_return()) { return 0; }
  if (ast_a(7) != 6) { return 0; }

  // Codegen: emit IR from memory-based AST.
  let ok_ir: i32 = emit_program_from_mem();
  if (ok_ir != 1) { return 0; }

  return 1;
}

// Lexer: returns packed (kind * 10000 + next_pos).
fn lex(pos: i32) -> i32 {
  let p: i32 = skip_ws(pos);
  let c: i32 = char_at(p);
  if (c == 0) { return pack_tok(tok_eof(), p); }

  if (is_ident_start(c) == 1) {
    let ident_end: i32 = scan_ident(p);
    let ident_k: i32 = ident_kind(p, ident_end);
    return pack_tok(ident_k, ident_end);
  }
  if (is_digit(c) == 1) {
    let int_end: i32 = scan_int(p);
    return pack_tok(tok_int(), int_end);
  }

  if (c == 40) { return pack_tok(tok_lparen(), p + 1); } // (
  if (c == 41) { return pack_tok(tok_rparen(), p + 1); } // )
  if (c == 123) { return pack_tok(tok_lbrace(), p + 1); } // {
  if (c == 125) { return pack_tok(tok_rbrace(), p + 1); } // }
  if (c == 58) { return pack_tok(tok_colon(), p + 1); } // :
  if (c == 59) { return pack_tok(tok_semi(), p + 1); } // ;
  if (c == 61) { return pack_tok(tok_eq(), p + 1); } // =
  if (c == 43) { return pack_tok(tok_plus(), p + 1); } // +
  if (c == 45) { // -
    if (char_at(p + 1) == 62) { return pack_tok(tok_arrow(), p + 2); }
  }
  return pack_tok(tok_eof(), p + 1);
}

fn pack_tok(kind: i32, next_pos: i32) -> i32 {
  return kind * 10000 + next_pos;
}

fn lex_kind(tok: i32) -> i32 {
  return tok / 10000;
}

fn lex_next(tok: i32) -> i32 {
  let kind: i32 = tok / 10000;
  return tok - kind * 10000;
}

fn skip_ws(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_space(c) == 1) {
    return skip_ws(p + 1);
  }
  return p;
}

fn scan_ident(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_ident_cont(c) == 1) {
    return scan_ident(p + 1);
  }
  return p;
}

fn scan_int(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_digit(c) == 1) {
    return scan_int(p + 1);
  }
  return p;
}

fn ident_kind(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 2) {
    if (char_at(start) == 102) {
      if (char_at(start + 1) == 110) { return tok_fn(); }
    }
  }
  if (len == 3) {
    if (char_at(start) == 108) {
      if (char_at(start + 1) == 101) {
        if (char_at(start + 2) == 116) { return tok_let(); }
      }
    }
  }
  if (len == 6) {
    if (char_at(start) == 114) {
      if (char_at(start + 1) == 101) {
        if (char_at(start + 2) == 116) {
          if (char_at(start + 3) == 117) {
            if (char_at(start + 4) == 114) {
              if (char_at(start + 5) == 110) { return tok_return(); }
            }
          }
        }
      }
    }
  }
  if (len == 3) {
    if (char_at(start) == 105) {
      if (char_at(start + 1) == 51) {
        if (char_at(start + 2) == 50) { return tok_i32(); }
      }
    }
  }
  return tok_ident();
}

fn ident_id(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 4) {
    if (char_at(start) == 109) {
      if (char_at(start + 1) == 97) {
        if (char_at(start + 2) == 105) {
          if (char_at(start + 3) == 110) { return 1; }
        }
      }
    }
  }
  if (len == 1) {
    if (char_at(start) == 120) { return 2; }
  }
  if (len == 1) {
    if (char_at(start) == 121) { return 3; }
  }
  return 0;
}

fn int_value(start: i32, end: i32) -> i32 {
  if (start >= end) { return 0; }
  let v: i32 = int_value(start + 1, end);
  let d: i32 = char_at(start) - 48;
  let pow: i32 = pow10(end - start - 1);
  return d * pow + v;
}

fn pow10(n: i32) -> i32 {
  if (n <= 0) { return 1; }
  return 10 * pow10(n - 1);
}

fn is_space(c: i32) -> i32 {
  if (c == 32) { return 1; }
  if (c == 10) { return 1; }
  if (c == 13) { return 1; }
  if (c == 9) { return 1; }
  return 0;
}

fn is_alpha(c: i32) -> i32 {
  if (c >= 65) {
    if (c <= 90) { return 1; }
  }
  if (c >= 97) {
    if (c <= 122) { return 1; }
  }
  return 0;
}

fn is_digit(c: i32) -> i32 {
  if (c >= 48) {
    if (c <= 57) { return 1; }
  }
  return 0;
}

fn is_ident_start(c: i32) -> i32 {
  if (is_alpha(c) == 1) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}

fn is_ident_cont(c: i32) -> i32 {
  if (is_alpha(c) == 1) { return 1; }
  if (is_digit(c) == 1) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}

// Hardcoded source string: "fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }"
fn char_at(pos: i32) -> i32 {
  if (pos == 0) { return 102; } // f
  if (pos == 1) { return 110; } // n
  if (pos == 2) { return 32; } // space
  if (pos == 3) { return 109; } // m
  if (pos == 4) { return 97; } // a
  if (pos == 5) { return 105; } // i
  if (pos == 6) { return 110; } // n
  if (pos == 7) { return 40; } // (
  if (pos == 8) { return 41; } // )
  if (pos == 9) { return 32; } // space
  if (pos == 10) { return 45; } // -
  if (pos == 11) { return 62; } // >
  if (pos == 12) { return 32; } // space
  if (pos == 13) { return 105; } // i
  if (pos == 14) { return 51; } // 3
  if (pos == 15) { return 50; } // 2
  if (pos == 16) { return 32; } // space
  if (pos == 17) { return 123; } // {
  if (pos == 18) { return 32; } // space
  if (pos == 19) { return 108; } // l
  if (pos == 20) { return 101; } // e
  if (pos == 21) { return 116; } // t
  if (pos == 22) { return 32; } // space
  if (pos == 23) { return 120; } // x
  if (pos == 24) { return 58; } // :
  if (pos == 25) { return 32; } // space
  if (pos == 26) { return 105; } // i
  if (pos == 27) { return 51; } // 3
  if (pos == 28) { return 50; } // 2
  if (pos == 29) { return 32; } // space
  if (pos == 30) { return 61; } // =
  if (pos == 31) { return 32; } // space
  if (pos == 32) { return 49; } // 1
  if (pos == 33) { return 59; } // ;
  if (pos == 34) { return 32; } // space
  if (pos == 35) { return 108; } // l
  if (pos == 36) { return 101; } // e
  if (pos == 37) { return 116; } // t
  if (pos == 38) { return 32; } // space
  if (pos == 39) { return 121; } // y
  if (pos == 40) { return 58; } // :
  if (pos == 41) { return 32; } // space
  if (pos == 42) { return 105; } // i
  if (pos == 43) { return 51; } // 3
  if (pos == 44) { return 50; } // 2
  if (pos == 45) { return 32; } // space
  if (pos == 46) { return 61; } // =
  if (pos == 47) { return 32; } // space
  if (pos == 48) { return 50; } // 2
  if (pos == 49) { return 59; } // ;
  if (pos == 50) { return 32; } // space
  if (pos == 51) { return 114; } // r
  if (pos == 52) { return 101; } // e
  if (pos == 53) { return 116; } // t
  if (pos == 54) { return 117; } // u
  if (pos == 55) { return 114; } // r
  if (pos == 56) { return 110; } // n
  if (pos == 57) { return 32; } // space
  if (pos == 58) { return 120; } // x
  if (pos == 59) { return 32; } // space
  if (pos == 60) { return 43; } // +
  if (pos == 61) { return 32; } // space
  if (pos == 62) { return 121; } // y
  if (pos == 63) { return 59; } // ;
  if (pos == 64) { return 32; } // space
  if (pos == 65) { return 125; } // }
  return 0;
}

fn tok_eof() -> i32 { return 0; }
fn tok_fn() -> i32 { return 1; }
fn tok_ident() -> i32 { return 2; }
fn tok_lparen() -> i32 { return 3; }
fn tok_rparen() -> i32 { return 4; }
fn tok_arrow() -> i32 { return 5; }
fn tok_i32() -> i32 { return 6; }
fn tok_lbrace() -> i32 { return 7; }
fn tok_rbrace() -> i32 { return 8; }
fn tok_return() -> i32 { return 9; }
fn tok_int() -> i32 { return 10; }
fn tok_semi() -> i32 { return 11; }
fn tok_let() -> i32 { return 12; }
fn tok_colon() -> i32 { return 13; }
fn tok_eq() -> i32 { return 14; }
fn tok_plus() -> i32 { return 15; }

// IR opcodes.
fn op_const() -> i32 { return 1; }
fn op_store() -> i32 { return 2; }
fn op_load() -> i32 { return 3; }
fn op_ret() -> i32 { return 4; }
fn op_add() -> i32 { return 5; }

// Emit IR from memory-based AST (Stage 1).
fn emit_program_from_mem() -> i32 {
  // Validate AST node kinds.
  if (ast_kind(0) != nk_let()) { return 0; }
  if (ast_kind(1) != nk_int()) { return 0; }
  if (ast_kind(2) != nk_let()) { return 0; }
  if (ast_kind(3) != nk_int()) { return 0; }
  if (ast_kind(4) != nk_ident()) { return 0; }
  if (ast_kind(5) != nk_ident()) { return 0; }
  if (ast_kind(6) != nk_add()) { return 0; }
  if (ast_kind(7) != nk_return()) { return 0; }

  // Lower AST to IR, storing in memory.
  // IR for: let x = 1; let y = 2; return x + y;
  // op0: const 1
  ir_set(0, op_const(), ast_a(1));
  // op1: store x
  ir_set(1, op_store(), ast_a(0));
  // op2: const 2
  ir_set(2, op_const(), ast_a(3));
  // op3: store y
  ir_set(3, op_store(), ast_a(2));
  // op4: load x
  ir_set(4, op_load(), ast_a(4));
  // op5: load y
  ir_set(5, op_load(), ast_a(5));
  // op6: add
  ir_set(6, op_add(), 0);
  // op7: ret
  ir_set(7, op_ret(), ast_a(7));

  // Validate IR stream from memory.
  if (ir_opcode(0) != op_const()) { return 0; }
  if (ir_arg(0) != 1) { return 0; }
  if (ir_opcode(1) != op_store()) { return 0; }
  if (ir_arg(1) == 0) { return 0; }
  if (ir_opcode(2) != op_const()) { return 0; }
  if (ir_arg(2) != 2) { return 0; }
  if (ir_opcode(3) != op_store()) { return 0; }
  if (ir_arg(3) == 0) { return 0; }
  if (ir_opcode(4) != op_load()) { return 0; }
  if (ir_arg(4) != ir_arg(1)) { return 0; }
  if (ir_opcode(5) != op_load()) { return 0; }
  if (ir_arg(5) != ir_arg(3)) { return 0; }
  if (ir_opcode(6) != op_add()) { return 0; }
  if (ir_opcode(7) != op_ret()) { return 0; }

  // Lower IR to WAT opcodes.
  if (emit_wat_from_ir_mem() != 1) { return 0; }

  return 1;
}

// WAT opcode tags.
fn w_const() -> i32 { return 1; }
fn w_local_set() -> i32 { return 2; }
fn w_local_get() -> i32 { return 3; }
fn w_return() -> i32 { return 4; }
fn w_add() -> i32 { return 5; }

// Emit WAT opcodes from memory-based IR (Stage 1).
// WAT stream stored at wat_base() (offset 0x2000).
fn wat_base() -> i32 { return 8192; }
fn wat_op_size() -> i32 { return 8; }

fn wat_addr(idx: i32, field: i32) -> i32 {
  return wat_base() + idx * wat_op_size() + field;
}

fn wat_set(idx: i32, opcode: i32, arg: i32) -> i32 {
  __mem_store(wat_addr(idx, 0), opcode);
  __mem_store(wat_addr(idx, 4), arg);
  return 0;
}

fn wat_opcode(idx: i32) -> i32 { return __mem_load(wat_addr(idx, 0)); }
fn wat_arg(idx: i32) -> i32 { return __mem_load(wat_addr(idx, 4)); }

fn emit_wat_from_ir_mem() -> i32 {
  // Map IR to WAT ops, storing in memory.
  if (ir_opcode(0) != op_const()) { return 0; }
  wat_set(0, w_const(), ir_arg(0));

  if (ir_opcode(1) != op_store()) { return 0; }
  wat_set(1, w_local_set(), map_local(ir_arg(1)));

  if (ir_opcode(2) != op_const()) { return 0; }
  wat_set(2, w_const(), ir_arg(2));

  if (ir_opcode(3) != op_store()) { return 0; }
  wat_set(3, w_local_set(), map_local(ir_arg(3)));

  if (ir_opcode(4) != op_load()) { return 0; }
  wat_set(4, w_local_get(), map_local(ir_arg(4)));

  if (ir_opcode(5) != op_load()) { return 0; }
  wat_set(5, w_local_get(), map_local(ir_arg(5)));

  if (ir_opcode(6) != op_add()) { return 0; }
  wat_set(6, w_add(), 0);

  if (ir_opcode(7) != op_ret()) { return 0; }
  wat_set(7, w_return(), 0);

  // Validate WAT stream from memory.
  // Expected: const 1; local.set 0; const 2; local.set 1; local.get 0; local.get 1; add; return
  if (wat_opcode(0) != w_const()) { return 0; }
  if (wat_arg(0) != 1) { return 0; }
  if (wat_opcode(1) != w_local_set()) { return 0; }
  if (wat_arg(1) != 0) { return 0; }
  if (wat_opcode(2) != w_const()) { return 0; }
  if (wat_arg(2) != 2) { return 0; }
  if (wat_opcode(3) != w_local_set()) { return 0; }
  if (wat_arg(3) != 1) { return 0; }
  if (wat_opcode(4) != w_local_get()) { return 0; }
  if (wat_arg(4) != 0) { return 0; }
  if (wat_opcode(5) != w_local_get()) { return 0; }
  if (wat_arg(5) != 1) { return 0; }
  if (wat_opcode(6) != w_add()) { return 0; }
  if (wat_opcode(7) != w_return()) { return 0; }

  return 1;
}

fn map_local(ident_id: i32) -> i32 {
  // Two locals in this stub: x -> 0, y -> 1
  if (ident_id == 2) { return 0; }
  if (ident_id == 3) { return 1; }
  return 0;
}

// ============================================================================
// Stage 1 Infrastructure: Memory-based AST storage
// ============================================================================
// Memory layout (from SELFHOSTING.md):
//   0x0000 - 0x0FFF: AST nodes (256 nodes × 16 bytes)
//   0x1000 - 0x1FFF: IR instructions (256 ops × 8 bytes)
//   0x2000 - 0x2FFF: Source input buffer (4KB)
//   0x3000 - 0x3FFF: Output buffer (4KB)
//
// AST Node format (16 bytes):
//   offset 0: kind (i32)
//   offset 4: arg_a (i32)
//   offset 8: arg_b (i32)
//   offset 12: arg_c (i32)

fn ast_base() -> i32 { return 0; }
fn ast_node_size() -> i32 { return 16; }
fn ast_max_nodes() -> i32 { return 256; }

// Compute address of AST node field
fn ast_addr(node_idx: i32, field_offset: i32) -> i32 {
  return ast_base() + node_idx * ast_node_size() + field_offset;
}

// Store AST node
fn ast_set(idx: i32, kind: i32, a: i32, b: i32, c: i32) -> i32 {
  __mem_store(ast_addr(idx, 0), kind);
  __mem_store(ast_addr(idx, 4), a);
  __mem_store(ast_addr(idx, 8), b);
  __mem_store(ast_addr(idx, 12), c);
  return 0;
}

// Load AST node fields
fn ast_kind(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 0)); }
fn ast_a(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 4)); }
fn ast_b(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 8)); }
fn ast_c(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 12)); }

// ============================================================================
// Stage 1 Infrastructure: Memory-based IR storage
// ============================================================================
// IR Instruction format (8 bytes):
//   offset 0: opcode (i32)
//   offset 4: argument (i32)

fn ir_base() -> i32 { return 4096; }
fn ir_op_size() -> i32 { return 8; }
fn ir_max_ops() -> i32 { return 256; }

fn ir_addr(op_idx: i32, field_offset: i32) -> i32 {
  return ir_base() + op_idx * ir_op_size() + field_offset;
}

fn ir_set(idx: i32, opcode: i32, arg: i32) -> i32 {
  __mem_store(ir_addr(idx, 0), opcode);
  __mem_store(ir_addr(idx, 4), arg);
  return 0;
}

fn ir_opcode(idx: i32) -> i32 { return __mem_load(ir_addr(idx, 0)); }
fn ir_arg(idx: i32) -> i32 { return __mem_load(ir_addr(idx, 4)); }

// ============================================================================
// Stage 1 Test: Verify memory-based AST/IR works
// ============================================================================
fn test_mem_ast() -> i32 {
  // Build the same AST as Stage 0, but using memory arrays
  // Node 0: let x = (expr at node 1)
  ast_set(0, nk_let(), 2, 1, 0);
  // Node 1: int 1
  ast_set(1, nk_int(), 1, 0, 0);
  // Node 2: let y = (expr at node 3)
  ast_set(2, nk_let(), 3, 3, 0);
  // Node 3: int 2
  ast_set(3, nk_int(), 2, 0, 0);
  // Node 4: ident x
  ast_set(4, nk_ident(), 2, 0, 0);
  // Node 5: ident y
  ast_set(5, nk_ident(), 3, 0, 0);
  // Node 6: add (node 4, node 5)
  ast_set(6, nk_add(), 4, 5, 0);
  // Node 7: return (node 6)
  ast_set(7, nk_return(), 6, 0, 0);

  // Verify
  if (ast_kind(0) != nk_let()) { return 0; }
  if (ast_a(0) != 2) { return 0; }
  if (ast_kind(1) != nk_int()) { return 0; }
  if (ast_a(1) != 1) { return 0; }
  if (ast_kind(6) != nk_add()) { return 0; }
  if (ast_a(6) != 4) { return 0; }
  if (ast_b(6) != 5) { return 0; }
  if (ast_kind(7) != nk_return()) { return 0; }

  return 1;
}

fn test_mem_ir() -> i32 {
  // Build IR: const 1; store x; const 2; store y; load x; load y; add; ret
  ir_set(0, op_const(), 1);
  ir_set(1, op_store(), 2);
  ir_set(2, op_const(), 2);
  ir_set(3, op_store(), 3);
  ir_set(4, op_load(), 2);
  ir_set(5, op_load(), 3);
  ir_set(6, op_add(), 0);
  ir_set(7, op_ret(), 0);

  // Verify
  if (ir_opcode(0) != op_const()) { return 0; }
  if (ir_arg(0) != 1) { return 0; }
  if (ir_opcode(6) != op_add()) { return 0; }
  if (ir_opcode(7) != op_ret()) { return 0; }

  return 1;
}
