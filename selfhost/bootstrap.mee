fn main() -> i32 {
  // Stage0: placeholder Mee "compiler".
  // We can't do real parsing yet (no structs/arrays/string ops),
  // so keep this as a compiling stub and grow it as features land.
  return compile_stub();
}

fn compile_stub() -> i32 {
  // Hardcoded source for: fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }
  // Lexer uses char_at(pos) to simulate input without strings/arrays.
  let pos: i32 = 0;
  let ok: i32 = parse_program(pos);
  if (ok == 1) { return 0; }
  return 1;
}

// Minimal AST encoded as scalar locals (no arrays yet).
// Node kinds.
fn nk_int() -> i32 { return 1; }
fn nk_return() -> i32 { return 2; }
fn nk_ident() -> i32 { return 3; }
fn nk_let() -> i32 { return 4; }
fn nk_add() -> i32 { return 5; }

fn parse_program(pos: i32) -> i32 {
  let p: i32 = pos;
  // Expect: fn main() -> i32 { let x: i32 = 1; return x; }
  let cur: i32 = p;
  let tok: i32 = lex(cur);
  let kind: i32 = lex_kind(tok);
  let next: i32 = lex_next(tok);
  if (kind != tok_fn()) { return 0; }

  let tok2: i32 = lex(next);
  let kind2: i32 = lex_kind(tok2);
  let next2: i32 = lex_next(tok2);
  if (kind2 != tok_ident()) { return 0; }
  let main_id: i32 = ident_id(next, next2);
  if (main_id == 0) { return 0; }

  let tok3: i32 = lex(next2);
  if (lex_kind(tok3) != tok_lparen()) { return 0; }
  let next3: i32 = lex_next(tok3);

  let tok4: i32 = lex(next3);
  if (lex_kind(tok4) != tok_rparen()) { return 0; }
  let next4: i32 = lex_next(tok4);

  let tok5: i32 = lex(next4);
  if (lex_kind(tok5) != tok_arrow()) { return 0; }
  let next5: i32 = lex_next(tok5);

  let tok6: i32 = lex(next5);
  if (lex_kind(tok6) != tok_i32()) { return 0; }
  let next6: i32 = lex_next(tok6);

  let tok7: i32 = lex(next6);
  if (lex_kind(tok7) != tok_lbrace()) { return 0; }
  let next7: i32 = lex_next(tok7);

  let tok8: i32 = lex(next7);
  if (lex_kind(tok8) != tok_let()) { return 0; }
  let next8: i32 = lex_next(tok8);

  let tok9: i32 = lex(next8);
  if (lex_kind(tok9) != tok_ident()) { return 0; }
  let next9: i32 = lex_next(tok9);
  let let_ident: i32 = ident_id(next8, next9);
  if (let_ident == 0) { return 0; }

  let tok10: i32 = lex(next9);
  if (lex_kind(tok10) != tok_colon()) { return 0; }
  let next10: i32 = lex_next(tok10);

  let tok11: i32 = lex(next10);
  if (lex_kind(tok11) != tok_i32()) { return 0; }
  let next11: i32 = lex_next(tok11);

  let tok12: i32 = lex(next11);
  if (lex_kind(tok12) != tok_eq()) { return 0; }
  let next12: i32 = lex_next(tok12);

  let tok13: i32 = lex(next12);
  if (lex_kind(tok13) != tok_int()) { return 0; }
  let next13: i32 = lex_next(tok13);
  let expr_value: i32 = int_value(next12, next13);

  let tok14: i32 = lex(next13);
  if (lex_kind(tok14) != tok_semi()) { return 0; }
  let next14: i32 = lex_next(tok14);

  let tok15: i32 = lex(next14);
  if (lex_kind(tok15) != tok_let()) { return 0; }
  let next15: i32 = lex_next(tok15);

  let tok16: i32 = lex(next15);
  if (lex_kind(tok16) != tok_ident()) { return 0; }
  let next16: i32 = lex_next(tok16);
  let let_ident2: i32 = ident_id(next15, next16);
  if (let_ident2 == 0) { return 0; }

  let tok17: i32 = lex(next16);
  if (lex_kind(tok17) != tok_colon()) { return 0; }
  let next17: i32 = lex_next(tok17);

  let tok18: i32 = lex(next17);
  if (lex_kind(tok18) != tok_i32()) { return 0; }
  let next18: i32 = lex_next(tok18);

  let tok19: i32 = lex(next18);
  if (lex_kind(tok19) != tok_eq()) { return 0; }
  let next19: i32 = lex_next(tok19);

  let tok20: i32 = lex(next19);
  if (lex_kind(tok20) != tok_int()) { return 0; }
  let next20: i32 = lex_next(tok20);
  let expr_value2: i32 = int_value(next19, next20);

  let tok21: i32 = lex(next20);
  if (lex_kind(tok21) != tok_semi()) { return 0; }
  let next21: i32 = lex_next(tok21);

  let tok22: i32 = lex(next21);
  if (lex_kind(tok22) != tok_return()) { return 0; }
  let next22: i32 = lex_next(tok22);

  let tok23: i32 = lex(next22);
  if (lex_kind(tok23) != tok_ident()) { return 0; }
  let next23: i32 = lex_next(tok23);
  let ret_ident: i32 = ident_id(next22, next23);

  let tok24: i32 = lex(next23);
  if (lex_kind(tok24) != tok_plus()) { return 0; }
  let next24: i32 = lex_next(tok24);

  let tok25: i32 = lex(next24);
  if (lex_kind(tok25) != tok_ident()) { return 0; }
  let next25: i32 = lex_next(tok25);
  let ret_ident2: i32 = ident_id(next24, next25);

  let tok26: i32 = lex(next25);
  if (lex_kind(tok26) != tok_semi()) { return 0; }
  let next26: i32 = lex_next(tok26);

  let tok27: i32 = lex(next26);
  if (lex_kind(tok27) != tok_rbrace()) { return 0; }

  // Build a tiny AST stream.
  // Node 0: let x = (int 1)
  let n0_kind: i32 = nk_let();
  let n0_a: i32 = let_ident; // ident id
  let n0_b: i32 = 1; // expr node index
  let n0_c: i32 = 0;

  // Node 1: int 1
  let n1_kind: i32 = nk_int();
  let n1_a: i32 = expr_value;
  let n1_b: i32 = 0;
  let n1_c: i32 = 0;

  // Node 2: let y = (int 2)
  let n2_kind: i32 = nk_let();
  let n2_a: i32 = let_ident2;
  let n2_b: i32 = 3; // expr node index
  let n2_c: i32 = 0;

  // Node 3: int 2
  let n3_kind: i32 = nk_int();
  let n3_a: i32 = expr_value2;
  let n3_b: i32 = 0;
  let n3_c: i32 = 0;

  // Node 4: ident x
  let n4_kind: i32 = nk_ident();
  let n4_a: i32 = ret_ident;
  let n4_b: i32 = 0;
  let n4_c: i32 = 0;

  // Node 5: ident y
  let n5_kind: i32 = nk_ident();
  let n5_a: i32 = ret_ident2;
  let n5_b: i32 = 0;
  let n5_c: i32 = 0;

  // Node 6: add (ident x, ident y)
  let n6_kind: i32 = nk_add();
  let n6_a: i32 = 4;
  let n6_b: i32 = 5;
  let n6_c: i32 = 0;

  // Node 7: return (add)
  let n7_kind: i32 = nk_return();
  let n7_a: i32 = 6;
  let n7_b: i32 = 0;
  let n7_c: i32 = 0;

  // Validate the AST stream.
  if (n0_kind != nk_let()) { return 0; }
  if (n0_a == 0) { return 0; }
  if (n0_b != 1) { return 0; }
  if (n1_kind != nk_int()) { return 0; }
  if (n1_a != 1) { return 0; }
  if (n2_kind != nk_let()) { return 0; }
  if (n2_a == 0) { return 0; }
  if (n2_b != 3) { return 0; }
  if (n3_kind != nk_int()) { return 0; }
  if (n3_a != 2) { return 0; }
  if (n4_kind != nk_ident()) { return 0; }
  if (n4_a != n0_a) { return 0; }
  if (n5_kind != nk_ident()) { return 0; }
  if (n5_a != n2_a) { return 0; }
  if (n6_kind != nk_add()) { return 0; }
  if (n6_a != 4) { return 0; }
  if (n6_b != 5) { return 0; }
  if (n7_kind != nk_return()) { return 0; }
  if (n7_a != 6) { return 0; }

  // Codegen stub: build a tiny linear IR stream and validate it.
  // Expected IR for: let x = 1; let y = 2; return x + y;
  let ok_ir: i32 = emit_program(
    n0_kind, n0_a, n0_b,
    n1_kind, n1_a,
    n2_kind, n2_a, n2_b,
    n3_kind, n3_a,
    n4_kind, n4_a,
    n5_kind, n5_a,
    n6_kind, n6_a, n6_b,
    n7_kind, n7_a
  );
  if (ok_ir != 1) { return 0; }

  return 1;
}

// Lexer: returns packed (kind * 10000 + next_pos).
fn lex(pos: i32) -> i32 {
  let p: i32 = skip_ws(pos);
  let c: i32 = char_at(p);
  if (c == 0) { return pack_tok(tok_eof(), p); }

  if (is_ident_start(c) == 1) {
    let end: i32 = scan_ident(p);
    let kind: i32 = ident_kind(p, end);
    return pack_tok(kind, end);
  }
  if (is_digit(c) == 1) {
    let end: i32 = scan_int(p);
    return pack_tok(tok_int(), end);
  }

  if (c == 40) { return pack_tok(tok_lparen(), p + 1); } // (
  if (c == 41) { return pack_tok(tok_rparen(), p + 1); } // )
  if (c == 123) { return pack_tok(tok_lbrace(), p + 1); } // {
  if (c == 125) { return pack_tok(tok_rbrace(), p + 1); } // }
  if (c == 58) { return pack_tok(tok_colon(), p + 1); } // :
  if (c == 59) { return pack_tok(tok_semi(), p + 1); } // ;
  if (c == 61) { return pack_tok(tok_eq(), p + 1); } // =
  if (c == 43) { return pack_tok(tok_plus(), p + 1); } // +
  if (c == 45) { // -
    if (char_at(p + 1) == 62) { return pack_tok(tok_arrow(), p + 2); }
  }
  return pack_tok(tok_eof(), p + 1);
}

fn pack_tok(kind: i32, next_pos: i32) -> i32 {
  return kind * 10000 + next_pos;
}

fn lex_kind(tok: i32) -> i32 {
  return tok / 10000;
}

fn lex_next(tok: i32) -> i32 {
  let kind: i32 = tok / 10000;
  return tok - kind * 10000;
}

fn skip_ws(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_space(c) == 1) {
    return skip_ws(p + 1);
  }
  return p;
}

fn scan_ident(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_ident_cont(c) == 1) {
    return scan_ident(p + 1);
  }
  return p;
}

fn scan_int(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_digit(c) == 1) {
    return scan_int(p + 1);
  }
  return p;
}

fn ident_kind(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 2) {
    if (char_at(start) == 102) {
      if (char_at(start + 1) == 110) { return tok_fn(); }
    }
  }
  if (len == 3) {
    if (char_at(start) == 108) {
      if (char_at(start + 1) == 101) {
        if (char_at(start + 2) == 116) { return tok_let(); }
      }
    }
  }
  if (len == 6) {
    if (char_at(start) == 114) {
      if (char_at(start + 1) == 101) {
        if (char_at(start + 2) == 116) {
          if (char_at(start + 3) == 117) {
            if (char_at(start + 4) == 114) {
              if (char_at(start + 5) == 110) { return tok_return(); }
            }
          }
        }
      }
    }
  }
  if (len == 3) {
    if (char_at(start) == 105) {
      if (char_at(start + 1) == 51) {
        if (char_at(start + 2) == 50) { return tok_i32(); }
      }
    }
  }
  return tok_ident();
}

fn ident_id(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 4) {
    if (char_at(start) == 109) {
      if (char_at(start + 1) == 97) {
        if (char_at(start + 2) == 105) {
          if (char_at(start + 3) == 110) { return 1; }
        }
      }
    }
  }
  if (len == 1) {
    if (char_at(start) == 120) { return 2; }
  }
  if (len == 1) {
    if (char_at(start) == 121) { return 3; }
  }
  return 0;
}

fn int_value(start: i32, end: i32) -> i32 {
  if (start >= end) { return 0; }
  let v: i32 = int_value(start + 1, end);
  let d: i32 = char_at(start) - 48;
  let pow: i32 = pow10(end - start - 1);
  return d * pow + v;
}

fn pow10(n: i32) -> i32 {
  if (n <= 0) { return 1; }
  return 10 * pow10(n - 1);
}

fn is_space(c: i32) -> i32 {
  if (c == 32) { return 1; }
  if (c == 10) { return 1; }
  if (c == 13) { return 1; }
  if (c == 9) { return 1; }
  return 0;
}

fn is_alpha(c: i32) -> i32 {
  if (c >= 65) {
    if (c <= 90) { return 1; }
  }
  if (c >= 97) {
    if (c <= 122) { return 1; }
  }
  return 0;
}

fn is_digit(c: i32) -> i32 {
  if (c >= 48) {
    if (c <= 57) { return 1; }
  }
  return 0;
}

fn is_ident_start(c: i32) -> i32 {
  if (is_alpha(c) == 1) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}

fn is_ident_cont(c: i32) -> i32 {
  if (is_alpha(c) == 1) { return 1; }
  if (is_digit(c) == 1) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}

// Hardcoded source string: "fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }"
fn char_at(pos: i32) -> i32 {
  if (pos == 0) { return 102; } // f
  if (pos == 1) { return 110; } // n
  if (pos == 2) { return 32; } // space
  if (pos == 3) { return 109; } // m
  if (pos == 4) { return 97; } // a
  if (pos == 5) { return 105; } // i
  if (pos == 6) { return 110; } // n
  if (pos == 7) { return 40; } // (
  if (pos == 8) { return 41; } // )
  if (pos == 9) { return 32; } // space
  if (pos == 10) { return 45; } // -
  if (pos == 11) { return 62; } // >
  if (pos == 12) { return 32; } // space
  if (pos == 13) { return 105; } // i
  if (pos == 14) { return 51; } // 3
  if (pos == 15) { return 50; } // 2
  if (pos == 16) { return 32; } // space
  if (pos == 17) { return 123; } // {
  if (pos == 18) { return 32; } // space
  if (pos == 19) { return 108; } // l
  if (pos == 20) { return 101; } // e
  if (pos == 21) { return 116; } // t
  if (pos == 22) { return 32; } // space
  if (pos == 23) { return 120; } // x
  if (pos == 24) { return 58; } // :
  if (pos == 25) { return 32; } // space
  if (pos == 26) { return 105; } // i
  if (pos == 27) { return 51; } // 3
  if (pos == 28) { return 50; } // 2
  if (pos == 29) { return 32; } // space
  if (pos == 30) { return 61; } // =
  if (pos == 31) { return 32; } // space
  if (pos == 32) { return 49; } // 1
  if (pos == 33) { return 59; } // ;
  if (pos == 34) { return 32; } // space
  if (pos == 35) { return 108; } // l
  if (pos == 36) { return 101; } // e
  if (pos == 37) { return 116; } // t
  if (pos == 38) { return 32; } // space
  if (pos == 39) { return 121; } // y
  if (pos == 40) { return 58; } // :
  if (pos == 41) { return 32; } // space
  if (pos == 42) { return 105; } // i
  if (pos == 43) { return 51; } // 3
  if (pos == 44) { return 50; } // 2
  if (pos == 45) { return 32; } // space
  if (pos == 46) { return 61; } // =
  if (pos == 47) { return 32; } // space
  if (pos == 48) { return 50; } // 2
  if (pos == 49) { return 59; } // ;
  if (pos == 50) { return 32; } // space
  if (pos == 51) { return 114; } // r
  if (pos == 52) { return 101; } // e
  if (pos == 53) { return 116; } // t
  if (pos == 54) { return 117; } // u
  if (pos == 55) { return 114; } // r
  if (pos == 56) { return 110; } // n
  if (pos == 57) { return 32; } // space
  if (pos == 58) { return 120; } // x
  if (pos == 59) { return 32; } // space
  if (pos == 60) { return 43; } // +
  if (pos == 61) { return 32; } // space
  if (pos == 62) { return 121; } // y
  if (pos == 63) { return 59; } // ;
  if (pos == 64) { return 32; } // space
  if (pos == 65) { return 125; } // }
  return 0;
}

fn tok_eof() -> i32 { return 0; }
fn tok_fn() -> i32 { return 1; }
fn tok_ident() -> i32 { return 2; }
fn tok_lparen() -> i32 { return 3; }
fn tok_rparen() -> i32 { return 4; }
fn tok_arrow() -> i32 { return 5; }
fn tok_i32() -> i32 { return 6; }
fn tok_lbrace() -> i32 { return 7; }
fn tok_rbrace() -> i32 { return 8; }
fn tok_return() -> i32 { return 9; }
fn tok_int() -> i32 { return 10; }
fn tok_semi() -> i32 { return 11; }
fn tok_let() -> i32 { return 12; }
fn tok_colon() -> i32 { return 13; }
fn tok_eq() -> i32 { return 14; }
fn tok_plus() -> i32 { return 15; }

// IR opcodes.
fn op_const() -> i32 { return 1; }
fn op_store() -> i32 { return 2; }
fn op_load() -> i32 { return 3; }
fn op_ret() -> i32 { return 4; }
fn op_add() -> i32 { return 5; }

fn emit_program(
  n0_kind: i32,
  n0_a: i32,
  n0_b: i32,
  n1_kind: i32,
  n1_a: i32,
  n2_kind: i32,
  n2_a: i32,
  n2_b: i32,
  n3_kind: i32,
  n3_a: i32,
  n4_kind: i32,
  n4_a: i32,
  n5_kind: i32,
  n5_a: i32,
  n6_kind: i32,
  n6_a: i32,
  n6_b: i32,
  n7_kind: i32,
  n7_a: i32
) -> i32 {
  // Fixed 8-instruction stream (op,arg) pairs.
  let op0: i32 = 0;
  let arg0: i32 = 0;
  let op1: i32 = 0;
  let arg1: i32 = 0;
  let op2: i32 = 0;
  let arg2: i32 = 0;
  let op3: i32 = 0;
  let arg3: i32 = 0;
  let op4: i32 = 0;
  let arg4: i32 = 0;
  let op5: i32 = 0;
  let arg5: i32 = 0;
  let op6: i32 = 0;
  let arg6: i32 = 0;
  let op7: i32 = 0;
  let arg7: i32 = 0;

  // Lower AST: let x = int 1; let y = int 2; return x + y;
  if (n0_kind != nk_let()) { return 0; }
  if (n1_kind != nk_int()) { return 0; }
  if (n2_kind != nk_let()) { return 0; }
  if (n3_kind != nk_int()) { return 0; }
  if (n4_kind != nk_ident()) { return 0; }
  if (n5_kind != nk_ident()) { return 0; }
  if (n6_kind != nk_add()) { return 0; }
  if (n7_kind != nk_return()) { return 0; }

  // op0: const 1
  op0 = op_const();
  arg0 = n1_a;
  // op1: store x
  op1 = op_store();
  arg1 = n0_a;
  // op2: const 2
  op2 = op_const();
  arg2 = n3_a;
  // op3: store y
  op3 = op_store();
  arg3 = n2_a;
  // op4: load x
  op4 = op_load();
  arg4 = n4_a;
  // op5: load y
  op5 = op_load();
  arg5 = n5_a;
  // op6: add
  op6 = op_add();
  arg6 = 0;
  // op7: ret
  op7 = op_ret();
  arg7 = n7_a;

  // Validate stream matches expectation.
  if (op0 != op_const()) { return 0; }
  if (arg0 != 1) { return 0; }
  if (op1 != op_store()) { return 0; }
  if (arg1 == 0) { return 0; }
  if (op2 != op_const()) { return 0; }
  if (arg2 != 2) { return 0; }
  if (op3 != op_store()) { return 0; }
  if (arg3 == 0) { return 0; }
  if (op4 != op_load()) { return 0; }
  if (arg4 != arg1) { return 0; }
  if (op5 != op_load()) { return 0; }
  if (arg5 != arg3) { return 0; }
  if (op6 != op_add()) { return 0; }
  if (op7 != op_ret()) { return 0; }

  // Lower IR to a tiny WAT opcode stream and validate it.
  if (emit_wat_from_ir(
    op0, arg0,
    op1, arg1,
    op2, arg2,
    op3, arg3,
    op4, arg4,
    op5, arg5,
    op6, arg6,
    op7, arg7
  ) != 1) { return 0; }

  return 1;
}

// WAT opcode tags.
fn w_const() -> i32 { return 1; }
fn w_local_set() -> i32 { return 2; }
fn w_local_get() -> i32 { return 3; }
fn w_return() -> i32 { return 4; }
fn w_add() -> i32 { return 5; }

fn emit_wat_from_ir(
  op0: i32,
  arg0: i32,
  op1: i32,
  arg1: i32,
  op2: i32,
  arg2: i32,
  op3: i32,
  arg3: i32,
  op4: i32,
  arg4: i32,
  op5: i32,
  arg5: i32,
  op6: i32,
  arg6: i32,
  op7: i32,
  arg7: i32
) -> i32 {
  let w0: i32 = 0;
  let wa0: i32 = 0;
  let w1: i32 = 0;
  let wa1: i32 = 0;
  let w2: i32 = 0;
  let wa2: i32 = 0;
  let w3: i32 = 0;
  let wa3: i32 = 0;
  let w4: i32 = 0;
  let wa4: i32 = 0;
  let w5: i32 = 0;
  let wa5: i32 = 0;
  let w6: i32 = 0;
  let wa6: i32 = 0;
  let w7: i32 = 0;
  let wa7: i32 = 0;

  // Map IR to WAT ops.
  if (op0 != op_const()) { return 0; }
  w0 = w_const();
  wa0 = arg0;

  if (op1 != op_store()) { return 0; }
  w1 = w_local_set();
  wa1 = map_local(arg1);

  if (op2 != op_const()) { return 0; }
  w2 = w_const();
  wa2 = arg2;

  if (op3 != op_store()) { return 0; }
  w3 = w_local_set();
  wa3 = map_local(arg3);

  if (op4 != op_load()) { return 0; }
  w4 = w_local_get();
  wa4 = map_local(arg4);

  if (op5 != op_load()) { return 0; }
  w5 = w_local_get();
  wa5 = map_local(arg5);

  if (op6 != op_add()) { return 0; }
  w6 = w_add();
  wa6 = 0;

  if (op7 != op_ret()) { return 0; }
  w7 = w_return();
  wa7 = 0;

  // Expected WAT stream:
  // const 1; local.set 0; const 2; local.set 1; local.get 0; local.get 1; add; return
  if (w0 != w_const()) { return 0; }
  if (wa0 != 1) { return 0; }
  if (w1 != w_local_set()) { return 0; }
  if (wa1 != 0) { return 0; }
  if (w2 != w_const()) { return 0; }
  if (wa2 != 2) { return 0; }
  if (w3 != w_local_set()) { return 0; }
  if (wa3 != 1) { return 0; }
  if (w4 != w_local_get()) { return 0; }
  if (wa4 != 0) { return 0; }
  if (w5 != w_local_get()) { return 0; }
  if (wa5 != 1) { return 0; }
  if (w6 != w_add()) { return 0; }
  if (w7 != w_return()) { return 0; }

  return 1;
}

fn map_local(ident_id: i32) -> i32 {
  // Two locals in this stub: x -> 0, y -> 1
  if (ident_id == 2) { return 0; }
  if (ident_id == 3) { return 1; }
  return 0;
}
