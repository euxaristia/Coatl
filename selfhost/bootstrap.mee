fn main() -> i32 {
  // Toggle to emit WAT text to stdout (1 = enabled, 0 = disabled)
  let emit_stdout: i32 = emit_wat_stdout_enabled();
  // Stage0a: validate token/opcode constants (self-host sanity check)
  let tok_ok: i32 = test_token_constants();
  if (tok_ok != 1) { return tok_ok; }
  // Stage0: placeholder Mee "compiler".
  // Validates full pipeline with hardcoded input.
  let stage0_ok: i32 = compile_stub();
  if (stage0_ok != 0) { return stage0_ok; }

  // Stage1: test memory-based AST/IR storage.
  let ast_ok: i32 = test_mem_ast();
  if (ast_ok != 1) { return 2; }

  let ir_ok: i32 = test_mem_ir();
  if (ir_ok != 1) { return 3; }

  // Stage1.5: test general parser.
  let parser_ok: i32 = test_general_parser();
  if (parser_ok != 1) { return 4; }

  // Stage1.6: test general codegen.
  let codegen_ok: i32 = test_general_codegen();
  if (codegen_ok != 1) { return 5; }

  // Stage1.7: test general compile pipeline.
  let compile_ok: i32 = test_general_compile();
  if (compile_ok != 1) {
    if (debug_enabled() == 1) { return compile_ok; }
    return 6;
  }

  // Stage1.7b: test control flow codegen.
  let if_ok: i32 = test_if_codegen();
  if (if_ok != 1) { return 7; }

  let while_ok: i32 = test_while_codegen();
  if (while_ok != 1) { return 8; }

  // Stage 3: test dynamic input compilation.
  let dyn_ok: i32 = test_dynamic_compile();
  if (dyn_ok != 1) {
    if (debug_enabled() == 1) { return dyn_ok; }
    return 9;
  }

  // Stage 3b: test dynamic input with control flow.
  let dyn_if_ok: i32 = test_dynamic_if();
  if (dyn_if_ok != 1) { return 10; }

  // Stage 4: test function calls.
  let call_ok: i32 = test_function_call();
  if (call_ok != 1) { return 11; }

  let parse_call_ok: i32 = test_parse_call_dyn();
  if (parse_call_ok != 1) { return 12; }

  // Stage 4b: test multi-function programs.
  let multi_fn_ok: i32 = test_multi_fn();
  if (multi_fn_ok != 1) { return 13; }

  // Stage 4c: test function parameters.
  let params_ok: i32 = test_fn_params();
  if (params_ok != 1) { return 14; }

  // Stage 4d: test assignment statements.
  let assign_ok: i32 = test_assignment();
  if (assign_ok != 1) { return 15; }

  // Stage 4e: test comments.
  let comment_ok: i32 = test_comments();
  if (comment_ok != 1) { return 16; }

  // Stage 5: test WAT text generation.
  let wat_text_ok: i32 = test_wat_text_gen();
  if (wat_text_ok != 1) { return 17; }

  // Stage 5b: test multi-function WAT generation.
  let wat_multi_ok: i32 = test_wat_multi_fn();
  if (wat_multi_ok != 1) { return 18; }

  // Stage 5c: test WAT output via stdout
  let wat_stdout_ok: i32 = test_wat_stdout();
  if (wat_stdout_ok != 1) { return 19; }

  // Stage 5d: test stdin -> stdout path (skips if disabled)
  let wat_stdin_ok: i32 = test_wat_stdin();
  if (wat_stdin_ok != 1) {
    if (debug_enabled() == 1) {
      debug_dump_error();
      return wat_stdin_ok;
    }
    return 20;
  }

  // Stage 5e: test WAT output to file (skips if disabled)
  let wat_file_ok: i32 = test_wat_file();
  if (wat_file_ok != 1) { return 23; }

  // Emit WAT to stdout (simple return program) if enabled
  if (emit_stdout == 1) {
    init_src_buffer();
    load_simple_return();
    if (compile_program_to_stdout() != 1) { return 21; }
    clear_src_buffer();
  }

  // Compile from stdin to stdout if enabled
  if (compile_stdin_enabled() == 1) {
    if (compile_stdin_to_stdout() != 1) {
      if (debug_enabled() == 1) { debug_dump_error(); }
      return 22;
    }
    clear_src_buffer();
  }

  // All stages passed
  return 0;
}

fn test_token_constants() -> i32 {
  if (tok_fn() != 1) { return 901; }
  if (tok_rbrace() != 8) { return 902; }
  if (tok_let() != 12) { return 903; }
  if (nk_let() != 4) { return 904; }
  if (nk_block() != 14) { return 905; }
  if (op_const() != 1) { return 906; }
  if (op_call() != 20) { return 907; }
  if (w_const() != 1) { return 908; }
  if (w_call() != 22) { return 909; }
  return 1;
}

// Set to 1 to emit WAT text to stdout from main()
fn emit_wat_stdout_enabled() -> i32 {
  return __mem_load(state_emit_stdout_flag());
}

// Set to 1 to enable WAT file output tests
fn emit_wat_file_enabled() -> i32 {
  return __mem_load(state_emit_file_flag());
}

// Set to 1 to compile from stdin and write WAT to stdout
fn compile_stdin_enabled() -> i32 {
  return __mem_load(state_stdin_flag());
}

// Set to 1 to return detailed error codes during early boot
fn debug_enabled() -> i32 {
  return __mem_load(state_debug_flag());
}

// Track stage for stage0 debugging (stored in state_err_code)
fn set_debug_stage(code: i32) -> i32 {
  __mem_store(state_err_code(), code);
  __mem_store(state_err_pos(), 0);
  __mem_store(state_err_tok(), 0);
  __mem_store(state_err_line(), 0);
  __mem_store(state_err_col(), 0);
  return 0;
}

// Emit parse error info: "<code> <pos> <tok> <line> <col>\n"
fn debug_dump_error() -> i32 {
  out_init();
  out_num(__mem_load(state_err_code()));
  out_sp();
  out_num(__mem_load(state_err_pos()));
  out_sp();
  out_num(__mem_load(state_err_tok()));
  out_sp();
  out_num(__mem_load(state_err_line()));
  out_sp();
  out_num(__mem_load(state_err_col()));
  out_nl();
  out_flush();
  return 0;
}

// Emit fn_count, main_idx, main_stmt_count (debug level 2)
fn debug_dump_main_counts() -> i32 {
  out_init();
  out_num(get_fn_count());
  out_sp();
  let main_idx: i32 = find_main_fn();
  out_num(main_idx);
  out_sp();
  if (main_idx >= 0) {
    let body: i32 = get_fn_ast(main_idx);
    out_num(ast_b(body));
    out_sp();
    let s0: i32 = ast_a(body);
    let s1: i32 = ast_c(s0);
    let s2: i32 = ast_c(s1);
    let s3: i32 = ast_c(s2);
    out_num(s0);
    out_sp();
    out_num(s1);
    out_sp();
    out_num(s2);
    out_sp();
    out_num(s3);
  } else {
    out_num(0);
  }
  out_nl();
  out_flush();
  return 0;
}

fn debug_dump_codegen(code: i32, fn_idx: i32) -> i32 {
  out_init();
  out_num(code);
  out_sp();
  out_num(fn_idx);
  out_nl();
  out_flush();
  return 0;
}

fn debug_dump_ir_bad(op: i32, idx: i32) -> i32 {
  out_init();
  out_num(op);
  out_sp();
  out_num(idx);
  out_sp();
  out_num(get_current_fn());
  out_nl();
  out_flush();
  return 0;
}

// Store parse error info (code, position, token kind)
fn set_parse_error(code: i32) -> i32 {
  __mem_store(state_err_code(), code);
  __mem_store(state_err_pos(), get_pos());
  let tok: i32 = peek_tok_dyn();
  __mem_store(state_err_tok(), lex_kind(tok));
  set_error_line_col(get_pos());
  return code;
}

fn compile_stub() -> i32 {
  // Hardcoded source for: fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }
  // Lexer uses char_at(pos) to simulate input without strings/arrays.
  let pos: i32 = 0;
  let ok: i32 = parse_program(pos);
  if (ok == 1) { return 0; }
  return ok;
}

// Minimal AST encoded as scalar locals (no arrays yet).
// Node kinds.
fn nk_int() -> i32 { return 1; }
fn nk_return() -> i32 { return 2; }
fn nk_ident() -> i32 { return 3; }
fn nk_let() -> i32 { return 4; }
fn nk_add() -> i32 { return 5; }
fn nk_sub() -> i32 { return 6; }
fn nk_mul() -> i32 { return 7; }
fn nk_div() -> i32 { return 8; }
fn nk_lt() -> i32 { return 9; }
fn nk_gt() -> i32 { return 10; }
fn nk_eq() -> i32 { return 11; }
fn nk_if() -> i32 { return 12; }
fn nk_while() -> i32 { return 13; }
fn nk_block() -> i32 { return 14; }
fn nk_ne() -> i32 { return 15; }
fn nk_le() -> i32 { return 16; }
fn nk_ge() -> i32 { return 17; }
fn nk_call() -> i32 { return 18; }
fn nk_fn() -> i32 { return 19; }
fn nk_program() -> i32 { return 20; }
fn nk_assign() -> i32 { return 21; }
fn nk_mem_load() -> i32 { return 22; }
fn nk_mem_store() -> i32 { return 23; }
fn nk_mem_load8() -> i32 { return 24; }
fn nk_mem_store8() -> i32 { return 25; }
fn nk_stmt() -> i32 { return 26; }
fn nk_bool() -> i32 { return 27; }
fn nk_and() -> i32 { return 28; }
fn nk_or() -> i32 { return 29; }
fn nk_string() -> i32 { return 30; }
fn nk_not() -> i32 { return 31; }

// Intrinsic call IDs (avoid collision with ident_id_dyn)
fn intrin_mem_load_id() -> i32 { return 1000001; }
fn intrin_mem_store_id() -> i32 { return 1000002; }
fn intrin_mem_load8_id() -> i32 { return 1000003; }
fn intrin_mem_store8_id() -> i32 { return 1000004; }
fn intrin_fd_write_id() -> i32 { return 1000005; }
fn intrin_fd_read_id() -> i32 { return 1000006; }
fn intrin_path_open_id() -> i32 { return 1000007; }
fn intrin_fd_close_id() -> i32 { return 1000008; }

fn parse_program(pos: i32) -> i32 {
  set_debug_stage(1);
  let p: i32 = pos;
  // Expect: fn main() -> i32 { let x: i32 = 1; return x; }
  let cur: i32 = p;
  let tok: i32 = lex(cur);
  let kind: i32 = lex_kind(tok);
  let next: i32 = lex_next(tok);
  if (kind != tok_fn()) { return 0 - 10; }
  set_debug_stage(10);

  let tok2: i32 = lex(next);
  let kind2: i32 = lex_kind(tok2);
  let next2: i32 = lex_next(tok2);
  if (kind2 != tok_ident()) { return 0 - 20; }
  set_debug_stage(20);
  let main_start: i32 = skip_ws(next);
  let main_id: i32 = ident_id(main_start, next2);
  if (main_id == 0) { return 0 - 30; }
  set_debug_stage(30);

  let tok3: i32 = lex(next2);
  if (lex_kind(tok3) != tok_lparen()) { return 0 - 40; }
  set_debug_stage(40);
  let next3: i32 = lex_next(tok3);

  let tok4: i32 = lex(next3);
  if (lex_kind(tok4) != tok_rparen()) { return 0 - 50; }
  set_debug_stage(50);
  let next4: i32 = lex_next(tok4);

  let tok5: i32 = lex(next4);
  if (lex_kind(tok5) != tok_arrow()) { return 0 - 60; }
  set_debug_stage(60);
  let next5: i32 = lex_next(tok5);

  let tok6: i32 = lex(next5);
  if (lex_kind(tok6) != tok_i32()) { return 0 - 70; }
  set_debug_stage(70);
  let next6: i32 = lex_next(tok6);

  let tok7: i32 = lex(next6);
  if (lex_kind(tok7) != tok_lbrace()) { return 0 - 80; }
  set_debug_stage(80);
  let next7: i32 = lex_next(tok7);

  let tok8: i32 = lex(next7);
  if (lex_kind(tok8) != tok_let()) { return 0 - 90; }
  set_debug_stage(90);
  let next8: i32 = lex_next(tok8);

  let tok9: i32 = lex(next8);
  if (lex_kind(tok9) != tok_ident()) { return 0 - 100; }
  set_debug_stage(100);
  let next9: i32 = lex_next(tok9);
  let ident_start: i32 = skip_ws(next8);
  let let_ident: i32 = ident_id(ident_start, next9);
  if (let_ident == 0) { return 0 - 110; }
  set_debug_stage(110);

  let tok10: i32 = lex(next9);
  if (lex_kind(tok10) != tok_colon()) { return 0 - 120; }
  set_debug_stage(120);
  let next10: i32 = lex_next(tok10);

  let tok11: i32 = lex(next10);
  if (lex_kind(tok11) != tok_i32()) { return 0 - 130; }
  set_debug_stage(130);
  let next11: i32 = lex_next(tok11);

  let tok12: i32 = lex(next11);
  if (lex_kind(tok12) != tok_eq()) { return 0 - 140; }
  set_debug_stage(140);
  let next12: i32 = lex_next(tok12);

  let tok13: i32 = lex(next12);
  if (lex_kind(tok13) != tok_int()) { return 0 - 150; }
  set_debug_stage(150);
  let next13: i32 = lex_next(tok13);
  let int_start: i32 = skip_ws(next12);
  let expr_value: i32 = int_value(int_start, next13);
  set_debug_stage(160);

  let tok14: i32 = lex(next13);
  if (lex_kind(tok14) != tok_semi()) { return 0 - 170; }
  set_debug_stage(170);
  let next14: i32 = lex_next(tok14);

  let tok15: i32 = lex(next14);
  if (lex_kind(tok15) != tok_let()) { return 0 - 180; }
  set_debug_stage(180);
  let next15: i32 = lex_next(tok15);

  let tok16: i32 = lex(next15);
  if (lex_kind(tok16) != tok_ident()) { return 0 - 190; }
  set_debug_stage(190);
  let next16: i32 = lex_next(tok16);
  let ident_start2: i32 = skip_ws(next15);
  let let_ident2: i32 = ident_id(ident_start2, next16);
  if (let_ident2 == 0) { return 0 - 200; }
  set_debug_stage(200);

  let tok17: i32 = lex(next16);
  if (lex_kind(tok17) != tok_colon()) { return 0 - 210; }
  set_debug_stage(210);
  let next17: i32 = lex_next(tok17);

  let tok18: i32 = lex(next17);
  if (lex_kind(tok18) != tok_i32()) { return 0 - 220; }
  set_debug_stage(220);
  let next18: i32 = lex_next(tok18);

  let tok19: i32 = lex(next18);
  if (lex_kind(tok19) != tok_eq()) { return 0 - 230; }
  set_debug_stage(230);
  let next19: i32 = lex_next(tok19);

  let tok20: i32 = lex(next19);
  if (lex_kind(tok20) != tok_int()) { return 0 - 240; }
  set_debug_stage(240);
  let next20: i32 = lex_next(tok20);
  let int_start2: i32 = skip_ws(next19);
  let expr_value2: i32 = int_value(int_start2, next20);
  set_debug_stage(250);

  let tok21: i32 = lex(next20);
  if (lex_kind(tok21) != tok_semi()) { return 0 - 260; }
  set_debug_stage(260);
  let next21: i32 = lex_next(tok21);

  let tok22: i32 = lex(next21);
  if (lex_kind(tok22) != tok_return()) { return 0 - 270; }
  set_debug_stage(270);
  let next22: i32 = lex_next(tok22);

  let tok23: i32 = lex(next22);
  if (lex_kind(tok23) != tok_ident()) { return 0 - 280; }
  set_debug_stage(280);
  let next23: i32 = lex_next(tok23);
  let ret_start: i32 = skip_ws(next22);
  let ret_ident: i32 = ident_id(ret_start, next23);
  set_debug_stage(290);

  let tok24: i32 = lex(next23);
  if (lex_kind(tok24) != tok_plus()) { return 0 - 300; }
  set_debug_stage(300);
  let next24: i32 = lex_next(tok24);

  let tok25: i32 = lex(next24);
  if (lex_kind(tok25) != tok_ident()) { return 0 - 310; }
  set_debug_stage(310);
  let next25: i32 = lex_next(tok25);
  let ret_start2: i32 = skip_ws(next24);
  let ret_ident2: i32 = ident_id(ret_start2, next25);
  set_debug_stage(320);

  let tok26: i32 = lex(next25);
  if (lex_kind(tok26) != tok_semi()) { return 0 - 330; }
  set_debug_stage(330);
  let next26: i32 = lex_next(tok26);

  let tok27: i32 = lex(next26);
  if (lex_kind(tok27) != tok_rbrace()) { return 0 - 340; }
  set_debug_stage(340);

  // Build AST using memory-based storage (Stage 1).
  // Node 0: let x = (expr at node 1)
  ast_set(0, nk_let(), let_ident, 1, 0);
  // Node 1: int 1
  ast_set(1, nk_int(), expr_value, 0, 0);
  // Node 2: let y = (expr at node 3)
  ast_set(2, nk_let(), let_ident2, 3, 0);
  // Node 3: int 2
  ast_set(3, nk_int(), expr_value2, 0, 0);
  // Node 4: ident x
  ast_set(4, nk_ident(), ret_ident, 0, 0);
  // Node 5: ident y
  ast_set(5, nk_ident(), ret_ident2, 0, 0);
  // Node 6: add (node 4, node 5)
  ast_set(6, nk_add(), 4, 5, 0);
  // Node 7: return (node 6)
  ast_set(7, nk_return(), 6, 0, 0);

  // Validate the AST stream from memory.
  if (ast_kind(0) != nk_let()) { return 0 - 401 - ast_kind(0); }
  if (ast_a(0) == 0) { return 0 - 402; }
  if (ast_b(0) != 1) { return 0 - 403; }
  if (ast_kind(1) != nk_int()) { return 0 - 404; }
  if (ast_a(1) != 1) { return 0 - 405; }
  if (ast_kind(2) != nk_let()) { return 0 - 406; }
  if (ast_a(2) == 0) { return 0 - 407; }
  if (ast_b(2) != 3) { return 0 - 408; }
  if (ast_kind(3) != nk_int()) { return 0 - 409; }
  if (ast_a(3) != 2) { return 0 - 410; }
  if (ast_kind(4) != nk_ident()) { return 0 - 411; }
  if (ast_a(4) != ast_a(0)) { return 0 - 412; }
  if (ast_kind(5) != nk_ident()) { return 0 - 413; }
  if (ast_a(5) != ast_a(2)) { return 0 - 414; }
  if (ast_kind(6) != nk_add()) { return 0 - 415; }
  if (ast_a(6) != 4) { return 0 - 416; }
  if (ast_b(6) != 5) { return 0 - 417; }
  if (ast_kind(7) != nk_return()) { return 0 - 418; }
  if (ast_a(7) != 6) { return 0 - 419; }

  // Codegen: emit IR from memory-based AST.
  let ok_ir: i32 = emit_program_from_mem();
  if (ok_ir != 1) { return 0 - 450; }

  set_debug_stage(900);
  return 1;
}

// Lexer: returns packed (kind * 10000 + next_pos).
fn lex(pos: i32) -> i32 {
  let p: i32 = skip_ws(pos);
  let c: i32 = char_at(p);
  if (c == 0) { return pack_tok(tok_eof(), p); }

  if (is_ident_start(c) == 1) {
    let ident_end: i32 = scan_ident(p);
    let ident_k: i32 = ident_kind(p, ident_end);
    return pack_tok(ident_k, ident_end);
  }
  if (is_digit(c) == 1) {
    let int_end: i32 = scan_int(p);
    return pack_tok(tok_int(), int_end);
  }
  if (c == 34) { // "
    let str_end: i32 = scan_string(p + 1);
    return pack_tok(tok_string(), str_end);
  }

  if (c == 40) { return pack_tok(tok_lparen(), p + 1); } // (
  if (c == 41) { return pack_tok(tok_rparen(), p + 1); } // )
  if (c == 123) { return pack_tok(tok_lbrace(), p + 1); } // {
  if (c == 125) { return pack_tok(tok_rbrace(), p + 1); } // }
  if (c == 58) { return pack_tok(tok_colon(), p + 1); } // :
  if (c == 59) { return pack_tok(tok_semi(), p + 1); } // ;
  if (c == 43) { return pack_tok(tok_plus(), p + 1); } // +
  if (c == 42) { return pack_tok(tok_star(), p + 1); } // *
  if (c == 47) { return pack_tok(tok_slash(), p + 1); } // /
  if (c == 60) { // <
    if (char_at(p + 1) == 61) { return pack_tok(tok_le(), p + 2); } // <=
    return pack_tok(tok_lt(), p + 1);
  }
  if (c == 62) { // >
    if (char_at(p + 1) == 61) { return pack_tok(tok_ge(), p + 2); } // >=
    return pack_tok(tok_gt(), p + 1);
  }
  if (c == 33) { // !
    if (char_at(p + 1) == 61) { return pack_tok(tok_ne(), p + 2); } // !=
    return pack_tok(tok_bang(), p + 1);
  }
  if (c == 61) { // =
    if (char_at(p + 1) == 61) { return pack_tok(tok_eqeq(), p + 2); } // ==
    return pack_tok(tok_eq(), p + 1); // =
  }
  if (c == 45) { // -
    if (char_at(p + 1) == 62) { return pack_tok(tok_arrow(), p + 2); } // ->
    return pack_tok(tok_minus(), p + 1); // -
  }
  if (c == 38) { // &
    if (char_at(p + 1) == 38) { return pack_tok(tok_and(), p + 2); } // &&
    return pack_tok(tok_eof(), p + 1);
  }
  if (c == 124) { // |
    if (char_at(p + 1) == 124) { return pack_tok(tok_or(), p + 2); } // ||
    return pack_tok(tok_eof(), p + 1);
  }
  return pack_tok(tok_eof(), p + 1);
}

fn tok_base() -> i32 { return 1000000; }

fn pack_tok(kind: i32, next_pos: i32) -> i32 {
  return kind * tok_base() + next_pos;
}

fn lex_kind(tok: i32) -> i32 {
  return tok / tok_base();
}

fn lex_next(tok: i32) -> i32 {
  let kind: i32 = tok / tok_base();
  return tok - kind * tok_base();
}

fn skip_ws(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_space(c) == 1) {
    return skip_ws(p + 1);
  }
  return p;
}

fn scan_ident(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_ident_cont(c) == 1) {
    return scan_ident(p + 1);
  }
  return p;
}

fn scan_int(pos: i32) -> i32 {
  let p: i32 = pos;
  let c: i32 = char_at(p);
  if (is_digit(c) == 1) {
    return scan_int(p + 1);
  }
  return p;
}

fn scan_string(pos: i32) -> i32 {
  let c: i32 = char_at(pos);
  if (c == 0) { return pos; }
  if (c == 34) { return pos + 1; }
  if (c == 92) { return scan_string(pos + 2); }
  return scan_string(pos + 1);
}

fn ident_kind(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 2) {
    // "fn"
    if (char_at(start) == 102) {
      if (char_at(start + 1) == 110) { return tok_fn(); }
    }
    // "if"
    if (char_at(start) == 105) {
      if (char_at(start + 1) == 102) { return tok_if(); }
    }
  }
  if (len == 3) {
    // "let"
    if (char_at(start) == 108) {
      if (char_at(start + 1) == 101) {
        if (char_at(start + 2) == 116) { return tok_let(); }
      }
    }
    // "i32"
    if (char_at(start) == 105) {
      if (char_at(start + 1) == 51) {
        if (char_at(start + 2) == 50) { return tok_i32(); }
      }
    }
  }
  if (len == 4) {
    // "else"
    if (char_at(start) == 101) {
      if (char_at(start + 1) == 108) {
        if (char_at(start + 2) == 115) {
          if (char_at(start + 3) == 101) { return tok_else(); }
        }
      }
    }
    // "true"
    if (char_at(start) == 116) {
      if (char_at(start + 1) == 114) {
        if (char_at(start + 2) == 117) {
          if (char_at(start + 3) == 101) { return tok_true(); }
        }
      }
    }
  }
  if (len == 5) {
    // "while"
    if (char_at(start) == 119) {
      if (char_at(start + 1) == 104) {
        if (char_at(start + 2) == 105) {
          if (char_at(start + 3) == 108) {
            if (char_at(start + 4) == 101) { return tok_while(); }
          }
        }
      }
    }
    // "false"
    if (char_at(start) == 102) {
      if (char_at(start + 1) == 97) {
        if (char_at(start + 2) == 108) {
          if (char_at(start + 3) == 115) {
            if (char_at(start + 4) == 101) { return tok_false(); }
          }
        }
      }
    }
  }
  if (len == 6) {
    // "return"
    if (char_at(start) == 114) {
      if (char_at(start + 1) == 101) {
        if (char_at(start + 2) == 116) {
          if (char_at(start + 3) == 117) {
            if (char_at(start + 4) == 114) {
              if (char_at(start + 5) == 110) { return tok_return(); }
            }
          }
        }
      }
    }
  }
  return tok_ident();
}

fn ident_id(start: i32, end: i32) -> i32 {
  let i: i32 = start;
  let h: i32 = 0;
  while (i < end) {
    h = h * 131 + char_at(i);
    i = i + 1;
  }
  return h;
}

fn int_value(start: i32, end: i32) -> i32 {
  if (start >= end) { return 0; }
  let v: i32 = int_value(start + 1, end);
  let d: i32 = char_at(start) - 48;
  let pow: i32 = pow10(end - start - 1);
  return d * pow + v;
}

fn pow10(n: i32) -> i32 {
  if (n <= 0) { return 1; }
  return 10 * pow10(n - 1);
}

fn is_space(c: i32) -> i32 {
  if (c == 32) { return 1; }
  if (c == 10) { return 1; }
  if (c == 13) { return 1; }
  if (c == 9) { return 1; }
  return 0;
}

fn is_alpha(c: i32) -> i32 {
  if (c >= 65) {
    if (c <= 90) { return 1; }
  }
  if (c >= 97) {
    if (c <= 122) { return 1; }
  }
  return 0;
}

fn is_digit(c: i32) -> i32 {
  if (c >= 48) {
    if (c <= 57) { return 1; }
  }
  return 0;
}

fn is_ident_start(c: i32) -> i32 {
  if (is_alpha(c) == 1) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}

fn is_ident_cont(c: i32) -> i32 {
  if (is_alpha(c) == 1) { return 1; }
  if (is_digit(c) == 1) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}

// Hardcoded source string: "fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }"
fn char_at(pos: i32) -> i32 {
  if (pos == 0) { return 102; } // f
  if (pos == 1) { return 110; } // n
  if (pos == 2) { return 32; } // space
  if (pos == 3) { return 109; } // m
  if (pos == 4) { return 97; } // a
  if (pos == 5) { return 105; } // i
  if (pos == 6) { return 110; } // n
  if (pos == 7) { return 40; } // (
  if (pos == 8) { return 41; } // )
  if (pos == 9) { return 32; } // space
  if (pos == 10) { return 45; } // -
  if (pos == 11) { return 62; } // >
  if (pos == 12) { return 32; } // space
  if (pos == 13) { return 105; } // i
  if (pos == 14) { return 51; } // 3
  if (pos == 15) { return 50; } // 2
  if (pos == 16) { return 32; } // space
  if (pos == 17) { return 123; } // {
  if (pos == 18) { return 32; } // space
  if (pos == 19) { return 108; } // l
  if (pos == 20) { return 101; } // e
  if (pos == 21) { return 116; } // t
  if (pos == 22) { return 32; } // space
  if (pos == 23) { return 120; } // x
  if (pos == 24) { return 58; } // :
  if (pos == 25) { return 32; } // space
  if (pos == 26) { return 105; } // i
  if (pos == 27) { return 51; } // 3
  if (pos == 28) { return 50; } // 2
  if (pos == 29) { return 32; } // space
  if (pos == 30) { return 61; } // =
  if (pos == 31) { return 32; } // space
  if (pos == 32) { return 49; } // 1
  if (pos == 33) { return 59; } // ;
  if (pos == 34) { return 32; } // space
  if (pos == 35) { return 108; } // l
  if (pos == 36) { return 101; } // e
  if (pos == 37) { return 116; } // t
  if (pos == 38) { return 32; } // space
  if (pos == 39) { return 121; } // y
  if (pos == 40) { return 58; } // :
  if (pos == 41) { return 32; } // space
  if (pos == 42) { return 105; } // i
  if (pos == 43) { return 51; } // 3
  if (pos == 44) { return 50; } // 2
  if (pos == 45) { return 32; } // space
  if (pos == 46) { return 61; } // =
  if (pos == 47) { return 32; } // space
  if (pos == 48) { return 50; } // 2
  if (pos == 49) { return 59; } // ;
  if (pos == 50) { return 32; } // space
  if (pos == 51) { return 114; } // r
  if (pos == 52) { return 101; } // e
  if (pos == 53) { return 116; } // t
  if (pos == 54) { return 117; } // u
  if (pos == 55) { return 114; } // r
  if (pos == 56) { return 110; } // n
  if (pos == 57) { return 32; } // space
  if (pos == 58) { return 120; } // x
  if (pos == 59) { return 32; } // space
  if (pos == 60) { return 43; } // +
  if (pos == 61) { return 32; } // space
  if (pos == 62) { return 121; } // y
  if (pos == 63) { return 59; } // ;
  if (pos == 64) { return 32; } // space
  if (pos == 65) { return 125; } // }
  return 0;
}

fn tok_eof() -> i32 { return 0; }
fn tok_fn() -> i32 { return 1; }
fn tok_ident() -> i32 { return 2; }
fn tok_lparen() -> i32 { return 3; }
fn tok_rparen() -> i32 { return 4; }
fn tok_arrow() -> i32 { return 5; }
fn tok_i32() -> i32 { return 6; }
fn tok_lbrace() -> i32 { return 7; }
fn tok_rbrace() -> i32 { return 8; }
fn tok_return() -> i32 { return 9; }
fn tok_int() -> i32 { return 10; }
fn tok_semi() -> i32 { return 11; }
fn tok_let() -> i32 { return 12; }
fn tok_colon() -> i32 { return 13; }
fn tok_eq() -> i32 { return 14; }
fn tok_plus() -> i32 { return 15; }
fn tok_minus() -> i32 { return 16; }
fn tok_star() -> i32 { return 17; }
fn tok_slash() -> i32 { return 18; }
fn tok_lt() -> i32 { return 19; }
fn tok_gt() -> i32 { return 20; }
fn tok_eqeq() -> i32 { return 21; }
fn tok_if() -> i32 { return 22; }
fn tok_else() -> i32 { return 23; }
fn tok_while() -> i32 { return 24; }
fn tok_ne() -> i32 { return 25; }
fn tok_le() -> i32 { return 26; }
fn tok_ge() -> i32 { return 27; }
fn tok_bang() -> i32 { return 28; }
fn tok_comma() -> i32 { return 29; }
fn tok_true() -> i32 { return 30; }
fn tok_false() -> i32 { return 31; }
fn tok_and() -> i32 { return 32; }
fn tok_or() -> i32 { return 33; }
fn tok_string() -> i32 { return 34; }

// IR opcodes.
fn op_const() -> i32 { return 1; }
fn op_store() -> i32 { return 2; }
fn op_load() -> i32 { return 3; }
fn op_ret() -> i32 { return 4; }
fn op_add() -> i32 { return 5; }
fn op_sub() -> i32 { return 6; }
fn op_mul() -> i32 { return 7; }
fn op_div() -> i32 { return 8; }
fn op_lt() -> i32 { return 9; }
fn op_gt() -> i32 { return 10; }
fn op_eq() -> i32 { return 11; }
fn op_br_if() -> i32 { return 12; }
fn op_br() -> i32 { return 13; }
fn op_block() -> i32 { return 14; }
fn op_end() -> i32 { return 15; }
fn op_ne() -> i32 { return 16; }
fn op_le() -> i32 { return 17; }
fn op_ge() -> i32 { return 18; }
fn op_loop() -> i32 { return 19; }
fn op_call() -> i32 { return 20; }
fn op_mem_load() -> i32 { return 21; }
fn op_mem_store() -> i32 { return 22; }
fn op_mem_load8() -> i32 { return 23; }
fn op_mem_store8() -> i32 { return 24; }
fn op_drop() -> i32 { return 25; }

// Emit IR from memory-based AST (Stage 1).
fn emit_program_from_mem() -> i32 {
  // Validate AST node kinds.
  if (ast_kind(0) != nk_let()) { return 0; }
  if (ast_kind(1) != nk_int()) { return 0; }
  if (ast_kind(2) != nk_let()) { return 0; }
  if (ast_kind(3) != nk_int()) { return 0; }
  if (ast_kind(4) != nk_ident()) { return 0; }
  if (ast_kind(5) != nk_ident()) { return 0; }
  if (ast_kind(6) != nk_add()) { return 0; }
  if (ast_kind(7) != nk_return()) { return 0; }

  // Lower AST to IR, storing in memory.
  // IR for: let x = 1; let y = 2; return x + y;
  // op0: const 1
  ir_set(0, op_const(), ast_a(1));
  // op1: store x
  ir_set(1, op_store(), ast_a(0));
  // op2: const 2
  ir_set(2, op_const(), ast_a(3));
  // op3: store y
  ir_set(3, op_store(), ast_a(2));
  // op4: load x
  ir_set(4, op_load(), ast_a(4));
  // op5: load y
  ir_set(5, op_load(), ast_a(5));
  // op6: add
  ir_set(6, op_add(), 0);
  // op7: ret
  ir_set(7, op_ret(), ast_a(7));

  // Validate IR stream from memory.
  if (ir_opcode(0) != op_const()) { return 0; }
  if (ir_arg(0) != 1) { return 0; }
  if (ir_opcode(1) != op_store()) { return 0; }
  if (ir_arg(1) == 0) { return 0; }
  if (ir_opcode(2) != op_const()) { return 0; }
  if (ir_arg(2) != 2) { return 0; }
  if (ir_opcode(3) != op_store()) { return 0; }
  if (ir_arg(3) == 0) { return 0; }
  if (ir_opcode(4) != op_load()) { return 0; }
  if (ir_arg(4) != ir_arg(1)) { return 0; }
  if (ir_opcode(5) != op_load()) { return 0; }
  if (ir_arg(5) != ir_arg(3)) { return 0; }
  if (ir_opcode(6) != op_add()) { return 0; }
  if (ir_opcode(7) != op_ret()) { return 0; }

  // Lower IR to WAT opcodes.
  if (emit_wat_from_ir_mem() != 1) { return 0; }

  return 1;
}

// WAT opcode tags.
fn w_const() -> i32 { return 1; }
fn w_local_set() -> i32 { return 2; }
fn w_local_get() -> i32 { return 3; }
fn w_return() -> i32 { return 4; }
fn w_add() -> i32 { return 5; }
fn w_sub() -> i32 { return 6; }
fn w_mul() -> i32 { return 7; }
fn w_div() -> i32 { return 8; }
fn w_lt() -> i32 { return 9; }
fn w_gt() -> i32 { return 10; }
fn w_eq() -> i32 { return 11; }
fn w_br_if() -> i32 { return 12; }
fn w_br() -> i32 { return 13; }
fn w_block() -> i32 { return 14; }
fn w_end() -> i32 { return 15; }
fn w_loop() -> i32 { return 16; }
fn w_if() -> i32 { return 17; }
fn w_else() -> i32 { return 18; }
fn w_ne() -> i32 { return 19; }
fn w_le() -> i32 { return 20; }
fn w_ge() -> i32 { return 21; }
fn w_call() -> i32 { return 22; }
fn w_i32_load() -> i32 { return 23; }
fn w_i32_store() -> i32 { return 24; }
fn w_i32_load8_u() -> i32 { return 25; }
fn w_i32_store8() -> i32 { return 26; }
fn w_drop() -> i32 { return 27; }

// Emit WAT opcodes from memory-based IR (Stage 1).
// WAT stream stored at wat_base() (offset 0x400000).
fn wat_base() -> i32 { return 10485760; }
fn wat_op_size() -> i32 { return 8; }

fn wat_addr(idx: i32, field: i32) -> i32 {
  return wat_base() + idx * wat_op_size() + field;
}

fn wat_set(idx: i32, opcode: i32, arg: i32) -> i32 {
  __mem_store(wat_addr(idx, 0), opcode);
  __mem_store(wat_addr(idx, 4), arg);
  return 0;
}

fn wat_opcode(idx: i32) -> i32 { return __mem_load(wat_addr(idx, 0)); }
fn wat_arg(idx: i32) -> i32 { return __mem_load(wat_addr(idx, 4)); }

fn emit_wat_from_ir_mem() -> i32 {
  // Map IR to WAT ops, storing in memory.
  if (ir_opcode(0) != op_const()) { return 0; }
  wat_set(0, w_const(), ir_arg(0));

  if (ir_opcode(1) != op_store()) { return 0; }
  wat_set(1, w_local_set(), map_local(ir_arg(1)));

  if (ir_opcode(2) != op_const()) { return 0; }
  wat_set(2, w_const(), ir_arg(2));

  if (ir_opcode(3) != op_store()) { return 0; }
  wat_set(3, w_local_set(), map_local(ir_arg(3)));

  if (ir_opcode(4) != op_load()) { return 0; }
  wat_set(4, w_local_get(), map_local(ir_arg(4)));

  if (ir_opcode(5) != op_load()) { return 0; }
  wat_set(5, w_local_get(), map_local(ir_arg(5)));

  if (ir_opcode(6) != op_add()) { return 0; }
  wat_set(6, w_add(), 0);

  if (ir_opcode(7) != op_ret()) { return 0; }
  wat_set(7, w_return(), 0);

  // Validate WAT stream from memory.
  // Expected: const 1; local.set 0; const 2; local.set 1; local.get 0; local.get 1; add; return
  if (wat_opcode(0) != w_const()) { return 0; }
  if (wat_arg(0) != 1) { return 0; }
  if (wat_opcode(1) != w_local_set()) { return 0; }
  if (wat_arg(1) != 0) { return 0; }
  if (wat_opcode(2) != w_const()) { return 0; }
  if (wat_arg(2) != 2) { return 0; }
  if (wat_opcode(3) != w_local_set()) { return 0; }
  if (wat_arg(3) != 1) { return 0; }
  if (wat_opcode(4) != w_local_get()) { return 0; }
  if (wat_arg(4) != 0) { return 0; }
  if (wat_opcode(5) != w_local_get()) { return 0; }
  if (wat_arg(5) != 1) { return 0; }
  if (wat_opcode(6) != w_add()) { return 0; }
  if (wat_opcode(7) != w_return()) { return 0; }

  return 1;
}

fn map_local(ident_id: i32) -> i32 {
  // Two locals in this stub: x -> 0, y -> 1
  if (ident_id == 120) { return 0; }
  if (ident_id == 121) { return 1; }
  return 0;
}

// ============================================================================
// Stage 1 Infrastructure: Memory-based AST storage
// ============================================================================
// Memory layout (expanded):
//   0x000000 - 0x1FFFFF: AST nodes (128K nodes × 16 bytes)
//   0x200000 - 0x9FFFFF: IR instructions (1M ops × 8 bytes)
//   0xA00000 - 0x11FFFFF: WAT opcodes (1M ops × 8 bytes)
//   0x1200000 - 0x123FFFF: Parser/state + symbol table
//   0x1240000 - 0x12BFFFF: Source input buffer (512KB)
//   0x12C0000 - 0x12FFFFF: Function tables
//   0x1300000 - 0x42FFFFF: Output buffer (48MB)
//   0x4300000 - 0x44FFFFF: Function local identifier table
//   0x4600000+      : I/O scratch (iovec + counters)
//
// AST Node format (16 bytes):
//   offset 0: kind (i32)
//   offset 4: arg_a (i32)
//   offset 8: arg_b (i32)
//   offset 12: arg_c (i32)

fn ast_base() -> i32 { return 0; }
fn ast_node_size() -> i32 { return 16; }
fn ast_max_nodes() -> i32 { return 131072; }

// Compute address of AST node field
fn ast_addr(node_idx: i32, field_offset: i32) -> i32 {
  return ast_base() + node_idx * ast_node_size() + field_offset;
}

// Store AST node
fn ast_set(idx: i32, kind: i32, a: i32, b: i32, c: i32) -> i32 {
  __mem_store(ast_addr(idx, 0), kind);
  __mem_store(ast_addr(idx, 4), a);
  __mem_store(ast_addr(idx, 8), b);
  __mem_store(ast_addr(idx, 12), c);
  return 0;
}

// Update only the c field (used for statement next pointers)
fn ast_set_c(idx: i32, c: i32) -> i32 {
  __mem_store(ast_addr(idx, 12), c);
  return 0;
}

// Load AST node fields
fn ast_kind(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 0)); }
fn ast_a(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 4)); }
fn ast_b(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 8)); }
fn ast_c(idx: i32) -> i32 { return __mem_load(ast_addr(idx, 12)); }

// ============================================================================
// Stage 1 Infrastructure: Memory-based IR storage
// ============================================================================
// IR Instruction format (8 bytes):
//   offset 0: opcode (i32)
//   offset 4: argument (i32)

fn ir_base() -> i32 { return 2097152; }
fn ir_op_size() -> i32 { return 8; }
fn ir_max_ops() -> i32 { return 1048576; }

fn ir_addr(op_idx: i32, field_offset: i32) -> i32 {
  return ir_base() + op_idx * ir_op_size() + field_offset;
}

fn ir_set(idx: i32, opcode: i32, arg: i32) -> i32 {
  __mem_store(ir_addr(idx, 0), opcode);
  __mem_store(ir_addr(idx, 4), arg);
  return 0;
}

fn ir_opcode(idx: i32) -> i32 { return __mem_load(ir_addr(idx, 0)); }
fn ir_arg(idx: i32) -> i32 { return __mem_load(ir_addr(idx, 4)); }

// ============================================================================
// Stage 1 Test: Verify memory-based AST/IR works
// ============================================================================
fn test_mem_ast() -> i32 {
  // Build the same AST as Stage 0, but using memory arrays
  // Node 0: let x = (expr at node 1)
  ast_set(0, nk_let(), 2, 1, 0);
  // Node 1: int 1
  ast_set(1, nk_int(), 1, 0, 0);
  // Node 2: let y = (expr at node 3)
  ast_set(2, nk_let(), 3, 3, 0);
  // Node 3: int 2
  ast_set(3, nk_int(), 2, 0, 0);
  // Node 4: ident x
  ast_set(4, nk_ident(), 2, 0, 0);
  // Node 5: ident y
  ast_set(5, nk_ident(), 3, 0, 0);
  // Node 6: add (node 4, node 5)
  ast_set(6, nk_add(), 4, 5, 0);
  // Node 7: return (node 6)
  ast_set(7, nk_return(), 6, 0, 0);

  // Verify
  if (ast_kind(0) != nk_let()) { return 0; }
  if (ast_a(0) != 2) { return 0; }
  if (ast_kind(1) != nk_int()) { return 0; }
  if (ast_a(1) != 1) { return 0; }
  if (ast_kind(6) != nk_add()) { return 0; }
  if (ast_a(6) != 4) { return 0; }
  if (ast_b(6) != 5) { return 0; }
  if (ast_kind(7) != nk_return()) { return 0; }

  return 1;
}

fn test_mem_ir() -> i32 {
  // Build IR: const 1; store x; const 2; store y; load x; load y; add; ret
  ir_set(0, op_const(), 1);
  ir_set(1, op_store(), 2);
  ir_set(2, op_const(), 2);
  ir_set(3, op_store(), 3);
  ir_set(4, op_load(), 2);
  ir_set(5, op_load(), 3);
  ir_set(6, op_add(), 0);
  ir_set(7, op_ret(), 0);

  // Verify
  if (ir_opcode(0) != op_const()) { return 0; }
  if (ir_arg(0) != 1) { return 0; }
  if (ir_opcode(6) != op_add()) { return 0; }
  if (ir_opcode(7) != op_ret()) { return 0; }

  return 1;
}

// ============================================================================
// Stage 1.5 Test: General parser
// ============================================================================
fn test_general_parser() -> i32 {
  // Test expression parsing with precedence
  // Parse: 1 + 2 * 3 (should be 1 + (2 * 3), not (1 + 2) * 3)
  parser_init(0);

  // Test parsing integer
  // We'll use the hardcoded input which starts at position 32: "1"
  set_pos(32);
  let int_node: i32 = parse_primary();
  if (int_node < 0) { return 0; }
  if (ast_kind(int_node) != nk_int()) { return 0; }
  if (ast_a(int_node) != 1) { return 0; }

  // Test precedence with 1 + 2 (positions in our hardcoded string)
  // We need to create a test string for this
  // For now, test that basic parsing machinery works
  parser_init(0);

  // Test symbol table
  set_local_count(0);
  let local0: i32 = add_local(100);
  if (local0 != 0) { return 0; }
  let local1: i32 = add_local(200);
  if (local1 != 1) { return 0; }

  let found0: i32 = lookup_local(100);
  if (found0 != 0) { return 0; }
  let found1: i32 = lookup_local(200);
  if (found1 != 1) { return 0; }
  let notfound: i32 = lookup_local(999);
  if (notfound != 0 - 1) { return 0; }

  // Test parsing let statement from the hardcoded input
  // Position 19 starts "let x: i32 = 1;"
  parser_init(0);
  set_pos(19);
  let let_node: i32 = parse_let_stmt();
  if (let_node < 0) { return 0; }
  if (ast_kind(let_node) != nk_let()) { return 0; }

  // The expression should be an int node with value 1
  let expr_idx: i32 = ast_b(let_node);
  if (ast_kind(expr_idx) != nk_int()) { return 0; }
  if (ast_a(expr_idx) != 1) { return 0; }

  // Test expression precedence: 1 + 2 * 3 should parse as 1 + (2 * 3)
  let prec_ok: i32 = test_precedence();
  if (prec_ok != 1) { return 0; }

  return 1;
}

// Test expression precedence parsing
fn test_precedence() -> i32 {
  // Use a new test source: "1 + 2 * 3"
  // We'll test the expression parser directly using memory
  // Store test string in the source buffer area
  let test_base: i32 = src_buffer_addr();
  // "1 + 2 * 3"
  __mem_store8(test_base + 0, 49);  // '1'
  __mem_store8(test_base + 1, 32);  // ' '
  __mem_store8(test_base + 2, 43);  // '+'
  __mem_store8(test_base + 3, 32);  // ' '
  __mem_store8(test_base + 4, 50);  // '2'
  __mem_store8(test_base + 5, 32);  // ' '
  __mem_store8(test_base + 6, 42);  // '*'
  __mem_store8(test_base + 7, 32);  // ' '
  __mem_store8(test_base + 8, 51);  // '3'
  __mem_store8(test_base + 9, 0);   // null terminator

  // Initialize parser using test input reader
  parser_init(0);
  set_test_input_base(test_base);

  // Parse expression
  let node: i32 = parse_expr_with_test_input();
  if (node < 0) { return 0; }

  // Should be: add(int(1), mul(int(2), int(3)))
  if (ast_kind(node) != nk_add()) { return 0; }
  let left: i32 = ast_a(node);
  let right: i32 = ast_b(node);

  // Left should be int(1)
  if (ast_kind(left) != nk_int()) { return 0; }
  if (ast_a(left) != 1) { return 0; }

  // Right should be mul(int(2), int(3))
  if (ast_kind(right) != nk_mul()) { return 0; }
  let mul_left: i32 = ast_a(right);
  let mul_right: i32 = ast_b(right);

  if (ast_kind(mul_left) != nk_int()) { return 0; }
  if (ast_a(mul_left) != 2) { return 0; }
  if (ast_kind(mul_right) != nk_int()) { return 0; }
  if (ast_a(mul_right) != 3) { return 0; }

  // Clear test mode
  set_test_input_base(0 - 1);

  return 1;
}

// Test input support - when set, char_at_test reads from this base instead
fn test_input_addr() -> i32 { return state_base() + 12; }
fn get_test_input_base() -> i32 { return __mem_load(test_input_addr()); }
fn set_test_input_base(base: i32) -> i32 { __mem_store(test_input_addr(), base); return 0; }

// Character reader that supports test mode
fn char_at_test(pos: i32) -> i32 {
  let test_base: i32 = get_test_input_base();
  if (test_base >= 0) {
    return __mem_load8(test_base + pos);
  }
  return char_at(pos);
}

// Lexer using test input
fn lex_test(pos: i32) -> i32 {
  let p: i32 = skip_ws_test(pos);
  let c: i32 = char_at_test(p);
  if (c == 0) { return pack_tok(tok_eof(), p); }

  if (is_ident_start(c) == 1) {
    let ident_end: i32 = scan_ident_test(p);
    let ident_k: i32 = ident_kind_test(p, ident_end);
    return pack_tok(ident_k, ident_end);
  }
  if (is_digit(c) == 1) {
    let int_end: i32 = scan_int_test(p);
    return pack_tok(tok_int(), int_end);
  }

  if (c == 40) { return pack_tok(tok_lparen(), p + 1); }
  if (c == 41) { return pack_tok(tok_rparen(), p + 1); }
  if (c == 123) { return pack_tok(tok_lbrace(), p + 1); }
  if (c == 125) { return pack_tok(tok_rbrace(), p + 1); }
  if (c == 58) { return pack_tok(tok_colon(), p + 1); }
  if (c == 59) { return pack_tok(tok_semi(), p + 1); }
  if (c == 43) { return pack_tok(tok_plus(), p + 1); }
  if (c == 42) { return pack_tok(tok_star(), p + 1); }
  if (c == 47) { return pack_tok(tok_slash(), p + 1); }
  if (c == 60) {
    if (char_at_test(p + 1) == 61) { return pack_tok(tok_le(), p + 2); }
    return pack_tok(tok_lt(), p + 1);
  }
  if (c == 62) {
    if (char_at_test(p + 1) == 61) { return pack_tok(tok_ge(), p + 2); }
    return pack_tok(tok_gt(), p + 1);
  }
  if (c == 33) {
    if (char_at_test(p + 1) == 61) { return pack_tok(tok_ne(), p + 2); }
    return pack_tok(tok_bang(), p + 1);
  }
  if (c == 61) {
    if (char_at_test(p + 1) == 61) { return pack_tok(tok_eqeq(), p + 2); }
    return pack_tok(tok_eq(), p + 1);
  }
  if (c == 45) {
    if (char_at_test(p + 1) == 62) { return pack_tok(tok_arrow(), p + 2); }
    return pack_tok(tok_minus(), p + 1);
  }
  return pack_tok(tok_eof(), p + 1);
}

fn skip_ws_test(pos: i32) -> i32 {
  let c: i32 = char_at_test(pos);
  if (is_space(c) == 1) {
    return skip_ws_test(pos + 1);
  }
  return pos;
}

fn scan_ident_test(pos: i32) -> i32 {
  let c: i32 = char_at_test(pos);
  if (is_ident_cont(c) == 1) {
    return scan_ident_test(pos + 1);
  }
  return pos;
}

fn scan_int_test(pos: i32) -> i32 {
  let c: i32 = char_at_test(pos);
  if (is_digit(c) == 1) {
    return scan_int_test(pos + 1);
  }
  return pos;
}

fn ident_kind_test(start: i32, end: i32) -> i32 {
  // For test input, just return tok_ident for now
  return tok_ident();
}

// Parse expression using test input
fn peek_tok_test() -> i32 {
  return lex_test(get_pos());
}

fn next_tok_test() -> i32 {
  let tok: i32 = peek_tok_test();
  set_pos(lex_next(tok));
  return tok;
}

fn parse_expr_with_test_input() -> i32 {
  return parse_cmp_test();
}

fn parse_cmp_test() -> i32 {
  let left: i32 = parse_add_test();
  if (left < 0) { return left; }
  return left;
}

fn parse_add_test() -> i32 {
  let left: i32 = parse_mul_test();
  if (left < 0) { return left; }
  return parse_add_rest_test(left);
}

fn parse_add_rest_test(left: i32) -> i32 {
  let tok: i32 = peek_tok_test();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_plus()) { return parse_add_op_test(left, nk_add()); }
  if (kind == tok_minus()) { return parse_add_op_test(left, nk_sub()); }
  return left;
}

fn parse_add_op_test(left: i32, nk: i32) -> i32 {
  next_tok_test();
  let right: i32 = parse_mul_test();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return parse_add_rest_test(node);
}

fn parse_mul_test() -> i32 {
  let left: i32 = parse_primary_test();
  if (left < 0) { return left; }
  return parse_mul_rest_test(left);
}

fn parse_mul_rest_test(left: i32) -> i32 {
  let tok: i32 = peek_tok_test();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_star()) { return parse_mul_op_test(left, nk_mul()); }
  if (kind == tok_slash()) { return parse_mul_op_test(left, nk_div()); }
  return left;
}

fn parse_mul_op_test(left: i32, nk: i32) -> i32 {
  next_tok_test();
  let right: i32 = parse_primary_test();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return parse_mul_rest_test(node);
}

fn parse_primary_test() -> i32 {
  let tok: i32 = peek_tok_test();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_int()) {
    return parse_int_test();
  }
  if (kind == tok_ident()) {
    return parse_ident_test();
  }
  if (kind == tok_lparen()) {
    next_tok_test();
    let inner: i32 = parse_expr_with_test_input();
    let rtok: i32 = peek_tok_test();
    if (lex_kind(rtok) != tok_rparen()) { return 0 - 1; }
    next_tok_test();
    return inner;
  }
  return 0 - 1000 - kind;
}

fn parse_int_test() -> i32 {
  let start: i32 = skip_ws_test(get_pos());
  next_tok_test();
  let val: i32 = int_value_test(start);
  let node: i32 = alloc_ast();
  ast_set(node, nk_int(), val, 0, 0);
  return node;
}

fn int_value_test(start: i32) -> i32 {
  let end: i32 = find_int_end_test(start);
  return int_value_range_test(start, end);
}

fn find_int_end_test(pos: i32) -> i32 {
  let c: i32 = char_at_test(pos);
  if (is_digit(c) == 1) {
    return find_int_end_test(pos + 1);
  }
  return pos;
}

fn int_value_range_test(start: i32, end: i32) -> i32 {
  if (start >= end) { return 0; }
  let v: i32 = int_value_range_test(start + 1, end);
  let d: i32 = char_at_test(start) - 48;
  let pow: i32 = pow10(end - start - 1);
  return d * pow + v;
}

fn parse_ident_test() -> i32 {
  let start: i32 = skip_ws_test(get_pos());
  next_tok_test();
  let end: i32 = get_pos();
  let id: i32 = 999;
  let node: i32 = alloc_ast();
  ast_set(node, nk_ident(), id, 0, 0);
  return node;
}

// ============================================================================
// Stage 1.6: General Codegen
// ============================================================================
// Recursively emit IR from AST nodes

// Initialize codegen state
fn codegen_init() -> i32 {
  set_ir_count(0);
  return 0;
}

// Emit IR for an expression, leaves result on stack
fn emit_ir_expr(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);

  if (kind == nk_int()) {
    return emit_ir_int(node);
  }
  if (kind == nk_bool()) {
    return emit_ir_bool(node);
  }
  if (kind == nk_string()) {
    return emit_ir_string(node);
  }
  if (kind == nk_ident()) {
    return emit_ir_ident(node);
  }
  if (kind == nk_call()) {
    return emit_ir_call(node);
  }
  if (kind == nk_add()) {
    return emit_ir_binop(node, op_add());
  }
  if (kind == nk_sub()) {
    return emit_ir_binop(node, op_sub());
  }
  if (kind == nk_mul()) {
    return emit_ir_binop(node, op_mul());
  }
  if (kind == nk_div()) {
    return emit_ir_binop(node, op_div());
  }
  if (kind == nk_lt()) {
    return emit_ir_binop(node, op_lt());
  }
  if (kind == nk_gt()) {
    return emit_ir_binop(node, op_gt());
  }
  if (kind == nk_eq()) {
    return emit_ir_binop(node, op_eq());
  }
  if (kind == nk_ne()) {
    return emit_ir_binop(node, op_ne());
  }
  if (kind == nk_le()) {
    return emit_ir_binop(node, op_le());
  }
  if (kind == nk_ge()) {
    return emit_ir_binop(node, op_ge());
  }
  if (kind == nk_and()) {
    return emit_ir_and(node);
  }
  if (kind == nk_or()) {
    return emit_ir_or(node);
  }
  if (kind == nk_not()) {
    return emit_ir_not(node);
  }

  return 0 - 3000 - kind;
}

fn emit_ir_and(node: i32) -> i32 {
  let left: i32 = ast_a(node);
  let right: i32 = ast_b(node);

  let r1: i32 = emit_ir_expr(left);
  if (r1 < 0) { return r1; }
  let z1: i32 = alloc_ir();
  ir_set(z1, op_const(), 0);
  let ne1: i32 = alloc_ir();
  ir_set(ne1, op_ne(), 0);

  let r2: i32 = emit_ir_expr(right);
  if (r2 < 0) { return r2; }
  let z2: i32 = alloc_ir();
  ir_set(z2, op_const(), 0);
  let ne2: i32 = alloc_ir();
  ir_set(ne2, op_ne(), 0);

  let mul: i32 = alloc_ir();
  ir_set(mul, op_mul(), 0);
  return r1 + r2 + 5;
}

fn emit_ir_or(node: i32) -> i32 {
  let left: i32 = ast_a(node);
  let right: i32 = ast_b(node);

  let r1: i32 = emit_ir_expr(left);
  if (r1 < 0) { return r1; }
  let z1: i32 = alloc_ir();
  ir_set(z1, op_const(), 0);
  let ne1: i32 = alloc_ir();
  ir_set(ne1, op_ne(), 0);

  let r2: i32 = emit_ir_expr(right);
  if (r2 < 0) { return r2; }
  let z2: i32 = alloc_ir();
  ir_set(z2, op_const(), 0);
  let ne2: i32 = alloc_ir();
  ir_set(ne2, op_ne(), 0);

  let add: i32 = alloc_ir();
  ir_set(add, op_add(), 0);
  let z3: i32 = alloc_ir();
  ir_set(z3, op_const(), 0);
  let ne3: i32 = alloc_ir();
  ir_set(ne3, op_ne(), 0);
  return r1 + r2 + 7;
}

fn emit_ir_not(node: i32) -> i32 {
  let inner: i32 = ast_a(node);
  let r: i32 = emit_ir_expr(inner);
  if (r < 0) { return r; }
  let z: i32 = alloc_ir();
  ir_set(z, op_const(), 0);
  let eq: i32 = alloc_ir();
  ir_set(eq, op_eq(), 0);
  return r + 2;
}

fn emit_ir_bool(node: i32) -> i32 {
  let idx: i32 = alloc_ir();
  ir_set(idx, op_const(), ast_a(node));
  return 1;
}

fn emit_ir_string(node: i32) -> i32 {
  let idx: i32 = alloc_ir();
  ir_set(idx, op_const(), ast_c(node));
  return 1;
}

fn emit_ir_call(node: i32) -> i32 {
  let fn_id: i32 = ast_a(node);
  let first_arg: i32 = ast_b(node);
  let arg_count: i32 = ast_c(node);

  if (fn_id == intrin_mem_load_id()) {
    if (arg_count != 1) { return 0 - 3302; }
    let arg0: i32 = ast_a(first_arg);
    let r1: i32 = emit_ir_expr(arg0);
    if (r1 < 0) { return r1; }
    let idx: i32 = alloc_ir();
    ir_set(idx, op_mem_load(), 0);
    return r1 + 1;
  }
  if (fn_id == intrin_mem_load8_id()) {
    if (arg_count != 1) { return 0 - 3302; }
    let arg1: i32 = ast_a(first_arg);
    let r2: i32 = emit_ir_expr(arg1);
    if (r2 < 0) { return r2; }
    let idx2: i32 = alloc_ir();
    ir_set(idx2, op_mem_load8(), 0);
    return r2 + 1;
  }
  if (fn_id == intrin_mem_store_id()) {
    if (arg_count != 2) { return 0 - 3303; }
    let arg2: i32 = ast_c(first_arg);
    if (arg2 < 0) { return 0 - 3304; }
    let a0: i32 = ast_a(first_arg);
    let a1: i32 = ast_a(arg2);
    let r3: i32 = emit_ir_expr(a0);
    if (r3 < 0) { return r3; }
    let r4: i32 = emit_ir_expr(a1);
    if (r4 < 0) { return r4; }
    let idx3: i32 = alloc_ir();
    ir_set(idx3, op_mem_store(), 0);
    return r3 + r4 + 1;
  }
  if (fn_id == intrin_mem_store8_id()) {
    if (arg_count != 2) { return 0 - 3303; }
    let arg3: i32 = ast_c(first_arg);
    if (arg3 < 0) { return 0 - 3304; }
    let b0: i32 = ast_a(first_arg);
    let b1: i32 = ast_a(arg3);
    let r5: i32 = emit_ir_expr(b0);
    if (r5 < 0) { return r5; }
    let r6: i32 = emit_ir_expr(b1);
    if (r6 < 0) { return r6; }
    let idx4: i32 = alloc_ir();
    ir_set(idx4, op_mem_store8(), 0);
    return r5 + r6 + 1;
  }
  if (fn_id == intrin_fd_write_id()) {
    if (arg_count != 4) { return 0 - 3305; }
    let args_ok2: i32 = emit_ir_args(first_arg, arg_count, 0);
    if (args_ok2 < 0) { return args_ok2; }
    let idx5: i32 = alloc_ir();
    ir_set(idx5, op_call(), fn_id);
    return args_ok2 + 1;
  }
  if (fn_id == intrin_fd_read_id()) {
    if (arg_count != 4) { return 0 - 3305; }
    let args_ok3: i32 = emit_ir_args(first_arg, arg_count, 0);
    if (args_ok3 < 0) { return args_ok3; }
    let idx6: i32 = alloc_ir();
    ir_set(idx6, op_call(), fn_id);
    return args_ok3 + 1;
  }
  if (fn_id == intrin_path_open_id()) {
    if (arg_count != 9) { return 0 - 3306; }
    let args_ok4: i32 = emit_ir_args(first_arg, arg_count, 0);
    if (args_ok4 < 0) { return args_ok4; }
    let idx7: i32 = alloc_ir();
    ir_set(idx7, op_call(), fn_id);
    return args_ok4 + 1;
  }
  if (fn_id == intrin_fd_close_id()) {
    if (arg_count != 1) { return 0 - 3307; }
    let args_ok5: i32 = emit_ir_args(first_arg, arg_count, 0);
    if (args_ok5 < 0) { return args_ok5; }
    let idx8: i32 = alloc_ir();
    ir_set(idx8, op_call(), fn_id);
    return args_ok5 + 1;
  }

  // Emit arguments (they go on the stack in order)
  let args_ok: i32 = emit_ir_args(first_arg, arg_count, 0);
  if (args_ok < 0) { return args_ok; }

  // Emit call instruction
  let fn_idx: i32 = lookup_fn(fn_id);
  if (fn_idx < 0) { return 0 - 3301; }
  if (arg_count != fn_params(fn_idx)) { return 0 - 3308; }
  let idx: i32 = alloc_ir();
  ir_set(idx, op_call(), fn_idx);
  return args_ok + 1;
}

fn emit_ir_args(first: i32, count: i32, total: i32) -> i32 {
  let n: i32 = count;
  let cur: i32 = first;
  let acc: i32 = total;
  while (n > 0) {
    let expr: i32 = ast_a(cur);
    let r: i32 = emit_ir_expr(expr);
    if (r < 0) { return r; }
    acc = acc + r;
    cur = ast_c(cur);
    n = n - 1;
  }
  return acc;
}

fn emit_ir_int(node: i32) -> i32 {
  let idx: i32 = alloc_ir();
  ir_set(idx, op_const(), ast_a(node));
  return 1;
}

fn emit_ir_ident(node: i32) -> i32 {
  let ident_id: i32 = ast_a(node);
  let local_idx: i32 = lookup_local(ident_id);
  if (local_idx < 0) { return 0 - 4000 - ident_id; }
  let idx: i32 = alloc_ir();
  ir_set(idx, op_load(), ident_id);
  return 1;
}

fn emit_ir_binop(node: i32, op: i32) -> i32 {
  let left: i32 = ast_a(node);
  let right: i32 = ast_b(node);

  let r1: i32 = emit_ir_expr(left);
  if (r1 < 0) { return r1; }

  let r2: i32 = emit_ir_expr(right);
  if (r2 < 0) { return r2; }

  let idx: i32 = alloc_ir();
  ir_set(idx, op, 0);
  return r1 + r2 + 1;
}

// ============================================================================
// Stage 6: Minimal Type Checker (i32 + bool)
// ============================================================================
fn type_i32() -> i32 { return 1; }
fn type_bool() -> i32 { return 2; }

fn typecheck_call(node: i32) -> i32 {
  let fn_id: i32 = ast_a(node);
  let first_arg: i32 = ast_b(node);
  let arg_count: i32 = ast_c(node);

  let expected: i32 = call_param_count(fn_id);
  if (expected >= 0) {
    if (arg_count != expected) { return 0 - 7202; }
  } else {
    let fn_idx: i32 = lookup_fn(fn_id);
    if (fn_idx < 0) { return 0 - 7201; }
    if (arg_count != fn_params(fn_idx)) { return 0 - 7202; }
  }

  let n: i32 = arg_count;
  let cur: i32 = first_arg;
  while (n > 0) {
    let expr: i32 = ast_a(cur);
    let ty: i32 = typecheck_expr(expr);
    if (ty < 0) { return ty; }
    if (ty != type_i32()) { return 0 - 7203; }
    cur = ast_c(cur);
    n = n - 1;
  }
  return type_i32();
}

fn typecheck_expr(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);
  if (kind == nk_int()) { return type_i32(); }
  if (kind == nk_bool()) { return type_bool(); }
  if (kind == nk_string()) { return type_i32(); }
  if (kind == nk_ident()) { return type_i32(); }
  if (kind == nk_call()) { return typecheck_call(node); }

  if (kind == nk_add() || kind == nk_sub() || kind == nk_mul() || kind == nk_div()) {
    let left: i32 = ast_a(node);
    let right: i32 = ast_b(node);
    let l: i32 = typecheck_expr(left);
    if (l < 0) { return l; }
    let r: i32 = typecheck_expr(right);
    if (r < 0) { return r; }
    if (l != type_i32() || r != type_i32()) { return 0 - 7210 - kind; }
    return type_i32();
  }

  if (kind == nk_lt() || kind == nk_gt() || kind == nk_eq() || kind == nk_ne() || kind == nk_le() || kind == nk_ge()) {
    let left2: i32 = ast_a(node);
    let right2: i32 = ast_b(node);
    let l2: i32 = typecheck_expr(left2);
    if (l2 < 0) { return l2; }
    let r2: i32 = typecheck_expr(right2);
    if (r2 < 0) { return r2; }
    if (l2 != type_i32() || r2 != type_i32()) { return 0 - 7220 - kind; }
    return type_bool();
  }

  if (kind == nk_and() || kind == nk_or()) {
    let left3: i32 = ast_a(node);
    let right3: i32 = ast_b(node);
    let l3: i32 = typecheck_expr(left3);
    if (l3 < 0) { return l3; }
    let r3: i32 = typecheck_expr(right3);
    if (r3 < 0) { return r3; }
    if (!type_is_truthy(l3) || !type_is_truthy(r3)) { return 0 - 7225 - kind; }
    return type_bool();
  }
  if (kind == nk_not()) {
    let inner: i32 = ast_a(node);
    let t: i32 = typecheck_expr(inner);
    if (t < 0) { return t; }
    if (!type_is_truthy(t)) { return 0 - 7226; }
    return type_bool();
  }

  return 0 - 7100 - kind;
}

fn type_is_truthy(t: i32) -> i32 {
  if (t == type_i32()) { return 1; }
  if (t == type_bool()) { return 1; }
  return 0;
}

fn string_unescaped_len(start: i32, len: i32) -> i32 {
  let i: i32 = 0;
  let count: i32 = 0;
  while (i < len) {
    let c: i32 = char_at_dyn(start + i);
    if (c == 92) {
      if (i + 1 < len) {
        count = count + 1;
        i = i + 2;
      } else {
        count = count + 1;
        i = i + 1;
      }
    } else {
      count = count + 1;
      i = i + 1;
    }
  }
  return count;
}

fn assign_string_offsets_expr(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);
  if (kind == nk_string()) {
    if (ast_c(node) == 0) {
      let start: i32 = ast_a(node);
      let raw_len: i32 = ast_b(node);
      let data_pos: i32 = get_str_data_pos();
      let real_len: i32 = string_unescaped_len(start, raw_len);
      ast_set_c(node, data_pos);
      set_str_data_pos(data_pos + real_len);
    }
    return 1;
  }
  if (kind == nk_int() || kind == nk_bool() || kind == nk_ident()) { return 1; }
  if (kind == nk_call()) {
    let first: i32 = ast_b(node);
    let count: i32 = ast_c(node);
    let cur: i32 = first;
    let n: i32 = count;
    while (n > 0) {
      let arg: i32 = ast_a(cur);
      let r: i32 = assign_string_offsets_expr(arg);
      if (r < 0) { return r; }
      cur = ast_c(cur);
      n = n - 1;
    }
    return 1;
  }
  if (kind == nk_not()) {
    return assign_string_offsets_expr(ast_a(node));
  }
  if (kind == nk_not()) {
    return gen_wat_data_expr(ast_a(node));
  }
  if (kind == nk_add() || kind == nk_sub() || kind == nk_mul() || kind == nk_div()
      || kind == nk_lt() || kind == nk_gt() || kind == nk_eq() || kind == nk_ne()
      || kind == nk_le() || kind == nk_ge() || kind == nk_and() || kind == nk_or()) {
    let left: i32 = ast_a(node);
    let right: i32 = ast_b(node);
    let r1: i32 = assign_string_offsets_expr(left);
    if (r1 < 0) { return r1; }
    let r2: i32 = assign_string_offsets_expr(right);
    if (r2 < 0) { return r2; }
    return 1;
  }
  return 1;
}

fn assign_string_offsets_stmt(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);
  if (kind == nk_let() || kind == nk_assign()) {
    return assign_string_offsets_expr(ast_b(node));
  }
  if (kind == nk_return()) {
    return assign_string_offsets_expr(ast_a(node));
  }
  if (kind == nk_if()) {
    let r1: i32 = assign_string_offsets_expr(ast_a(node));
    if (r1 < 0) { return r1; }
    let r2: i32 = assign_string_offsets_block(ast_b(node));
    if (r2 < 0) { return r2; }
    let else_block: i32 = ast_c(node);
    if (else_block >= 0) {
      let r3: i32 = assign_string_offsets_block(else_block);
      if (r3 < 0) { return r3; }
    }
    return 1;
  }
  if (kind == nk_while()) {
    let r4: i32 = assign_string_offsets_expr(ast_a(node));
    if (r4 < 0) { return r4; }
    return assign_string_offsets_block(ast_b(node));
  }
  return assign_string_offsets_expr(node);
}

fn assign_string_offsets_block(block_node: i32) -> i32 {
  if (ast_kind(block_node) != nk_block()) { return 1; }
  let first: i32 = ast_a(block_node);
  let count: i32 = ast_b(block_node);
  let cur: i32 = first;
  let n: i32 = count;
  while (n > 0) {
    let stmt_node: i32 = ast_a(cur);
    let r: i32 = assign_string_offsets_stmt(stmt_node);
    if (r < 0) { return r; }
    cur = ast_c(cur);
    n = n - 1;
  }
  return 1;
}

fn assign_string_offsets_program(count: i32) -> i32 {
  let i: i32 = 0;
  while (i < count) {
    let body: i32 = get_fn_ast(i);
    let r: i32 = assign_string_offsets_block(body);
    if (r < 0) { return r; }
    i = i + 1;
  }
  return 1;
}

fn typecheck_stmt(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);
  if (kind == nk_let() || kind == nk_assign()) {
    let expr: i32 = ast_b(node);
    let ty: i32 = typecheck_expr(expr);
    if (ty < 0) { return ty; }
    if (ty != type_i32()) { return 0 - 7230 - kind; }
    return 1;
  }
  if (kind == nk_return()) {
    let expr2: i32 = ast_a(node);
    let ty2: i32 = typecheck_expr(expr2);
    if (ty2 < 0) { return ty2; }
    if (ty2 != type_i32()) { return 0 - 7231; }
    return 1;
  }
  if (kind == nk_if()) {
    let cond: i32 = ast_a(node);
    let then_block: i32 = ast_b(node);
    let else_block: i32 = ast_c(node);
    let cty: i32 = typecheck_expr(cond);
    if (cty < 0) { return cty; }
    if (cty != type_bool()) { return 0 - 7232; }
    let t: i32 = typecheck_block_node(then_block);
    if (t < 0) { return t; }
    if (else_block >= 0) {
      let e: i32 = typecheck_block_node(else_block);
      if (e < 0) { return e; }
    }
    return 1;
  }
  if (kind == nk_while()) {
    let cond2: i32 = ast_a(node);
    let body: i32 = ast_b(node);
    let cty2: i32 = typecheck_expr(cond2);
    if (cty2 < 0) { return cty2; }
    if (cty2 != type_bool()) { return 0 - 7233; }
    let b: i32 = typecheck_block_node(body);
    if (b < 0) { return b; }
    return 1;
  }
  // expression statement
  if (kind == nk_call() || kind == nk_int() || kind == nk_bool() || kind == nk_string() || kind == nk_ident()
      || kind == nk_add() || kind == nk_sub() || kind == nk_mul() || kind == nk_div()
      || kind == nk_lt() || kind == nk_gt() || kind == nk_eq() || kind == nk_ne()
      || kind == nk_le() || kind == nk_ge()
      || kind == nk_and() || kind == nk_or() || kind == nk_not()) {
    let t: i32 = typecheck_expr(node);
    if (t < 0) { return t; }
    return 1;
  }

  return 0 - 7240 - kind;
}

fn typecheck_block_node(block_node: i32) -> i32 {
  if (ast_kind(block_node) != nk_block()) { return 0 - 7250; }
  let first: i32 = ast_a(block_node);
  let count: i32 = ast_b(block_node);
  let cur: i32 = first;
  let n: i32 = count;
  while (n > 0) {
    if (ast_kind(cur) != nk_stmt()) { return 0 - 7251; }
    let stmt: i32 = ast_a(cur);
    let r: i32 = typecheck_stmt(stmt);
    if (r < 0) { return r; }
    cur = ast_c(cur);
    n = n - 1;
  }
  return 1;
}

fn typecheck_fn(fn_idx: i32) -> i32 {
  set_current_fn(fn_idx);
  let body: i32 = get_fn_ast(fn_idx);
  let r: i32 = typecheck_block_node(body);
  set_current_fn(0 - 1);
  return r;
}

fn typecheck_fns(idx: i32, count: i32) -> i32 {
  if (idx >= count) { return 1; }
  let r: i32 = typecheck_fn(idx);
  if (r < 0) { return r; }
  return typecheck_fns(idx + 1, count);
}

// Emit IR for a statement
fn emit_ir_stmt(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);

  if (kind == nk_let()) {
    return emit_ir_let(node);
  }
  if (kind == nk_return()) {
    return emit_ir_return(node);
  }
  if (kind == nk_if()) {
    return emit_ir_if(node);
  }
  if (kind == nk_while()) {
    return emit_ir_while(node);
  }
  if (kind == nk_assign()) {
    return emit_ir_assign(node);
  }
  if (kind == nk_call()) {
    return emit_ir_call_stmt(node);
  }
  if (kind == nk_int()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_bool()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_string()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_ident()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_add()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_sub()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_mul()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_div()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_lt()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_gt()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_eq()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_ne()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_le()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_ge()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_and()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_or()) { return emit_ir_expr_stmt(node); }
  if (kind == nk_not()) { return emit_ir_expr_stmt(node); }

  return 0 - 1000 - kind;
}

// Emit call as a statement (drop return value)
fn emit_ir_call_stmt(node: i32) -> i32 {
  let fn_id: i32 = ast_a(node);
  let r: i32 = emit_ir_call(node);
  if (r < 0) { return r; }
  if (fn_id == intrin_mem_store_id()) { return r; }
  if (fn_id == intrin_mem_store8_id()) { return r; }
  let idx: i32 = alloc_ir();
  ir_set(idx, op_drop(), 0);
  return r + 1;
}

// Emit expression as a statement (drop result)
fn emit_ir_expr_stmt(node: i32) -> i32 {
  let r: i32 = emit_ir_expr(node);
  if (r < 0) { return r; }
  let idx: i32 = alloc_ir();
  ir_set(idx, op_drop(), 0);
  return r + 1;
}

fn emit_ir_assign(node: i32) -> i32 {
  let ident_id: i32 = ast_a(node);
  let expr_node: i32 = ast_b(node);

  // Emit expression
  let r: i32 = emit_ir_expr(expr_node);
  if (r < 0) { return r; }

  // Emit store
  let idx: i32 = alloc_ir();
  ir_set(idx, op_store(), ident_id);
  return r + 1;
}

fn emit_ir_let(node: i32) -> i32 {
  let ident_id: i32 = ast_a(node);
  let expr_node: i32 = ast_b(node);

  // Emit expression
  let r: i32 = emit_ir_expr(expr_node);
  if (r < 0) { return r; }

  // Emit store
  let idx: i32 = alloc_ir();
  ir_set(idx, op_store(), ident_id);
  return r + 1;
}

fn emit_ir_return(node: i32) -> i32 {
  let expr_node: i32 = ast_a(node);

  // Emit expression
  let r: i32 = emit_ir_expr(expr_node);
  if (r < 0) { return r; }

  // Emit return
  let idx: i32 = alloc_ir();
  ir_set(idx, op_ret(), 0);
  return r + 1;
}

fn emit_ir_if(node: i32) -> i32 {
  let cond_node: i32 = ast_a(node);
  let then_block: i32 = ast_b(node);
  let else_block: i32 = ast_c(node);

  if (else_block >= 0) {
    // if/else via nested blocks:
    // block $end
    //   block $else
    //     cond; i32.const 0; i32.eq; br_if $else
    //     then...
    //     br $end
    //   end
    //   else...
    // end
    let end_blk: i32 = alloc_ir();
    ir_set(end_blk, op_block(), 0);
    let else_blk: i32 = alloc_ir();
    ir_set(else_blk, op_block(), 0);

    let r1: i32 = emit_ir_expr(cond_node);
    if (r1 < 0) { return r1; }
    let zero_idx: i32 = alloc_ir();
    ir_set(zero_idx, op_const(), 0);
    let eq_idx: i32 = alloc_ir();
    ir_set(eq_idx, op_eq(), 0);
    let br_if_idx: i32 = alloc_ir();
    ir_set(br_if_idx, op_br_if(), 0);

    let r2: i32 = emit_ir_block_stmts(then_block);
    if (r2 < 0) { return r2; }
    let br_idx: i32 = alloc_ir();
    ir_set(br_idx, op_br(), 1);
    let end_else: i32 = alloc_ir();
    ir_set(end_else, op_end(), 0);

    let r3: i32 = emit_ir_block_stmts(else_block);
    if (r3 < 0) { return r3; }
    let end_if: i32 = alloc_ir();
    ir_set(end_if, op_end(), 0);

    return r1 + r2 + r3 + 8;
  }

  // No else: single block with early br_if
  let blk_idx: i32 = alloc_ir();
  ir_set(blk_idx, op_block(), 0);
  let r4: i32 = emit_ir_expr(cond_node);
  if (r4 < 0) { return r4; }
  let zero_idx2: i32 = alloc_ir();
  ir_set(zero_idx2, op_const(), 0);
  let eq_idx2: i32 = alloc_ir();
  ir_set(eq_idx2, op_eq(), 0);
  let br_idx2: i32 = alloc_ir();
  ir_set(br_idx2, op_br_if(), 0);
  let r5: i32 = emit_ir_block_stmts(then_block);
  if (r5 < 0) { return r5; }
  let end_idx2: i32 = alloc_ir();
  ir_set(end_idx2, op_end(), 0);

  return r4 + r5 + 5;
}

fn emit_ir_while(node: i32) -> i32 {
  let cond_node: i32 = ast_a(node);
  let body_block: i32 = ast_b(node);

  // Emit outer block + loop start
  let block_idx: i32 = alloc_ir();
  ir_set(block_idx, op_block(), 0);
  let loop_idx: i32 = alloc_ir();
  ir_set(loop_idx, op_loop(), 0);

  // Emit condition
  let r1: i32 = emit_ir_expr(cond_node);
  if (r1 < 0) { return r1; }

  // Compare against 0 to exit loop if condition is false (cond == 0)
  let zero_idx: i32 = alloc_ir();
  ir_set(zero_idx, op_const(), 0);
  let eq_idx: i32 = alloc_ir();
  ir_set(eq_idx, op_eq(), 0);

  // Emit br_if to exit loop if condition is false
  let br_idx: i32 = alloc_ir();
  ir_set(br_idx, op_br_if(), 1);

  // Emit body
  let r2: i32 = emit_ir_block_stmts(body_block);
  if (r2 < 0) { return r2; }

  // Emit br to loop start
  let br_back: i32 = alloc_ir();
  ir_set(br_back, op_br(), 0);

  // Emit loop end + block end
  let end_loop: i32 = alloc_ir();
  ir_set(end_loop, op_end(), 0);
  let end_block: i32 = alloc_ir();
  ir_set(end_block, op_end(), 0);

  return r1 + r2 + 8;
}

fn emit_ir_block_stmts(block_node: i32) -> i32 {
  if (ast_kind(block_node) != nk_block()) { return 0 - 2000 - ast_kind(block_node); }
  let first_stmt: i32 = ast_a(block_node);
  let stmt_count: i32 = ast_b(block_node);
  return emit_ir_stmt_list(first_stmt, stmt_count, 0);
}

fn emit_ir_stmt_list(node: i32, count: i32, total: i32) -> i32 {
  let n: i32 = count;
  let cur: i32 = node;
  let acc: i32 = total;
  while (n > 0) {
    if (cur < 0) { return 0 - 5000; }
    if (ast_kind(cur) != nk_stmt()) { return 0 - 5001 - ast_kind(cur); }
    let stmt_node: i32 = ast_a(cur);
    let r: i32 = emit_ir_stmt(stmt_node);
    if (r < 0) { return r; }
    acc = acc + r;
    cur = ast_c(cur);
    n = n - 1;
  }
  return acc;
}

// ============================================================================
// Stage 1.6 Test: General Codegen
// ============================================================================
fn test_general_codegen() -> i32 {
  // Test emitting IR from a simple expression: 1 + 2
  codegen_init();
  parser_init(0);

  // Build AST manually: add(int(1), int(2))
  ast_set(0, nk_int(), 1, 0, 0);
  ast_set(1, nk_int(), 2, 0, 0);
  ast_set(2, nk_add(), 0, 1, 0);

  // Emit IR for the expression
  let r: i32 = emit_ir_expr(2);
  if (r < 0) { return 0; }

  // Should have emitted: const 1; const 2; add
  if (get_ir_count() != 3) { return 0; }
  if (ir_opcode(0) != op_const()) { return 0; }
  if (ir_arg(0) != 1) { return 0; }
  if (ir_opcode(1) != op_const()) { return 0; }
  if (ir_arg(1) != 2) { return 0; }
  if (ir_opcode(2) != op_add()) { return 0; }

  // Test let statement: let x = 1 + 2;
  codegen_init();
  set_local_count(0);
  add_local(100); // x has ident_id 100

  // Build AST: let(x, add(int(1), int(2)))
  ast_set(0, nk_int(), 1, 0, 0);
  ast_set(1, nk_int(), 2, 0, 0);
  ast_set(2, nk_add(), 0, 1, 0);
  ast_set(3, nk_let(), 100, 2, 0);

  // Emit IR for let statement
  let r2: i32 = emit_ir_stmt(3);
  if (r2 < 0) { return 0; }

  // Should have: const 1; const 2; add; store x
  if (get_ir_count() != 4) { return 0; }
  if (ir_opcode(3) != op_store()) { return 0; }
  if (ir_arg(3) != 100) { return 0; }

  // End-to-end test: parse + codegen
  let e2e_ok: i32 = test_end_to_end();
  if (e2e_ok != 1) { return 0; }

  return 1;
}

// ============================================================================
// Stage 1.7: General WAT Lowering
// ============================================================================

fn state_wat_count() -> i32 { return state_base() + 20; }
fn get_wat_count() -> i32 { return __mem_load(state_wat_count()); }
fn set_wat_count(n: i32) -> i32 { __mem_store(state_wat_count(), n); return 0; }

// Source buffer configuration for dynamic input (Stage 3)
fn state_src_base() -> i32 { return state_base() + 24; }
fn get_src_base() -> i32 { return __mem_load(state_src_base()); }
fn set_src_base(base: i32) -> i32 { __mem_store(state_src_base(), base); return 0; }

// Source buffer at 0x604000 (512KB)
fn src_buffer_addr() -> i32 { return 19005440; }
fn src_buffer_size() -> i32 { return 524288; }

// ============================================================================
// Stage 4: Function Table
// ============================================================================
// Function table at 0x684000 (24KB reserved)
// Each entry: 12 bytes (ident_id: i32, param_count: i32, local_count: i32)
fn fn_table_addr() -> i32 { return 19660800; }
fn fn_entry_size() -> i32 { return 12; }
fn fn_table_max() -> i32 { return 1024; }

fn state_fn_count() -> i32 { return state_base() + 28; }
fn get_fn_count() -> i32 { return __mem_load(state_fn_count()); }
fn set_fn_count(n: i32) -> i32 { __mem_store(state_fn_count(), n); return 0; }

fn fn_entry_addr(idx: i32, field: i32) -> i32 {
  return fn_table_addr() + idx * fn_entry_size() + field;
}

fn fn_set(idx: i32, ident_id: i32, param_cnt: i32, local_cnt: i32) -> i32 {
  __mem_store(fn_entry_addr(idx, 0), ident_id);
  __mem_store(fn_entry_addr(idx, 4), param_cnt);
  __mem_store(fn_entry_addr(idx, 8), local_cnt);
  return 0;
}

fn fn_ident(idx: i32) -> i32 { return __mem_load(fn_entry_addr(idx, 0)); }
fn fn_params(idx: i32) -> i32 { return __mem_load(fn_entry_addr(idx, 4)); }
fn fn_locals(idx: i32) -> i32 { return __mem_load(fn_entry_addr(idx, 8)); }
fn set_fn_param_count(idx: i32, count: i32) -> i32 {
  __mem_store(fn_entry_addr(idx, 4), count);
  return 0;
}

// Register a function, returns its index
fn register_fn(ident_id: i32, param_cnt: i32) -> i32 {
  let idx: i32 = get_fn_count();
  fn_set(idx, ident_id, param_cnt, 0);
  set_fn_count(idx + 1);
  return idx;
}

// Look up function by ident_id, returns index or -1
fn lookup_fn(ident_id: i32) -> i32 {
  let count: i32 = get_fn_count();
  let i: i32 = 0;
  while (i < count) {
    if (fn_ident(i) == ident_id) { return i; }
    i = i + 1;
  }
  return 0 - 1;
}

// Read character from dynamic source (memory buffer or fallback to hardcoded)
fn char_at_dyn(pos: i32) -> i32 {
  let base: i32 = get_src_base();
  if (base > 0) {
    return __mem_load8(base + pos);
  }
  return char_at(pos);
}

// Initialize source buffer for dynamic input
fn init_src_buffer() -> i32 {
  set_src_base(src_buffer_addr());
  return 0;
}

// Clear source buffer (revert to hardcoded)
fn clear_src_buffer() -> i32 {
  set_src_base(0);
  return 0;
}

// Store a byte in the source buffer
fn src_store(pos: i32, byte: i32) -> i32 {
  let base: i32 = get_src_base();
  __mem_store8(base + pos, byte);
  return 0;
}

// ============================================================================
// Stage 3: Dynamic Lexer (reads from memory buffer)
// ============================================================================

fn lex_dyn(pos: i32) -> i32 {
  let p: i32 = skip_ws_dyn(pos);
  let c: i32 = char_at_dyn(p);
  if (c == 0) { return pack_tok(tok_eof(), p); }

  if (is_ident_start(c) == 1) {
    let ident_end: i32 = scan_ident_dyn(p);
    let ident_k: i32 = ident_kind_dyn(p, ident_end);
    return pack_tok(ident_k, ident_end);
  }
  if (is_digit(c) == 1) {
    let int_end: i32 = scan_int_dyn(p);
    return pack_tok(tok_int(), int_end);
  }
  if (c == 34) {
    let str_end: i32 = scan_string_dyn(p + 1);
    return pack_tok(tok_string(), str_end);
  }

  if (c == 40) { return pack_tok(tok_lparen(), p + 1); }
  if (c == 41) { return pack_tok(tok_rparen(), p + 1); }
  if (c == 123) { return pack_tok(tok_lbrace(), p + 1); }
  if (c == 125) { return pack_tok(tok_rbrace(), p + 1); }
  if (c == 58) { return pack_tok(tok_colon(), p + 1); }
  if (c == 59) { return pack_tok(tok_semi(), p + 1); }
  if (c == 44) { return pack_tok(tok_comma(), p + 1); }
  if (c == 43) { return pack_tok(tok_plus(), p + 1); }
  if (c == 42) { return pack_tok(tok_star(), p + 1); }
  if (c == 47) { return pack_tok(tok_slash(), p + 1); }
  if (c == 60) {
    if (char_at_dyn(p + 1) == 61) { return pack_tok(tok_le(), p + 2); }
    return pack_tok(tok_lt(), p + 1);
  }
  if (c == 62) {
    if (char_at_dyn(p + 1) == 61) { return pack_tok(tok_ge(), p + 2); }
    return pack_tok(tok_gt(), p + 1);
  }
  if (c == 33) {
    if (char_at_dyn(p + 1) == 61) { return pack_tok(tok_ne(), p + 2); }
    return pack_tok(tok_bang(), p + 1);
  }
  if (c == 61) {
    if (char_at_dyn(p + 1) == 61) { return pack_tok(tok_eqeq(), p + 2); }
    return pack_tok(tok_eq(), p + 1);
  }
  if (c == 45) {
    if (char_at_dyn(p + 1) == 62) { return pack_tok(tok_arrow(), p + 2); }
    return pack_tok(tok_minus(), p + 1);
  }
  if (c == 38) {
    if (char_at_dyn(p + 1) == 38) { return pack_tok(tok_and(), p + 2); }
    return pack_tok(tok_eof(), p + 1);
  }
  if (c == 124) {
    if (char_at_dyn(p + 1) == 124) { return pack_tok(tok_or(), p + 2); }
    return pack_tok(tok_eof(), p + 1);
  }
  return pack_tok(tok_eof(), p + 1);
}

fn skip_ws_dyn(pos: i32) -> i32 {
  let c: i32 = char_at_dyn(pos);
  if (is_space(c) == 1) {
    return skip_ws_dyn(pos + 1);
  }
  // Skip // comments
  if (c == 47) {
    if (char_at_dyn(pos + 1) == 47) {
      return skip_line_comment(pos + 2);
    }
  }
  return pos;
}

fn skip_line_comment(pos: i32) -> i32 {
  let c: i32 = char_at_dyn(pos);
  if (c == 0) { return pos; }
  if (c == 10) { return skip_ws_dyn(pos + 1); }
  return skip_line_comment(pos + 1);
}

fn scan_ident_dyn(pos: i32) -> i32 {
  let c: i32 = char_at_dyn(pos);
  if (is_ident_cont(c) == 1) {
    return scan_ident_dyn(pos + 1);
  }
  return pos;
}

fn scan_int_dyn(pos: i32) -> i32 {
  let c: i32 = char_at_dyn(pos);
  if (is_digit(c) == 1) {
    return scan_int_dyn(pos + 1);
  }
  return pos;
}

fn scan_string_dyn(pos: i32) -> i32 {
  let c: i32 = char_at_dyn(pos);
  if (c == 0) { return pos; }
  if (c == 34) { return pos + 1; }
  if (c == 92) { return scan_string_dyn(pos + 2); }
  return scan_string_dyn(pos + 1);
}

fn ident_kind_dyn(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 2) {
    if (char_at_dyn(start) == 102) {
      if (char_at_dyn(start + 1) == 110) { return tok_fn(); }
    }
    if (char_at_dyn(start) == 105) {
      if (char_at_dyn(start + 1) == 102) { return tok_if(); }
    }
  }
  if (len == 3) {
    if (char_at_dyn(start) == 108) {
      if (char_at_dyn(start + 1) == 101) {
        if (char_at_dyn(start + 2) == 116) { return tok_let(); }
      }
    }
    if (char_at_dyn(start) == 105) {
      if (char_at_dyn(start + 1) == 51) {
        if (char_at_dyn(start + 2) == 50) { return tok_i32(); }
      }
    }
  }
  if (len == 4) {
    if (char_at_dyn(start) == 101) {
      if (char_at_dyn(start + 1) == 108) {
        if (char_at_dyn(start + 2) == 115) {
          if (char_at_dyn(start + 3) == 101) { return tok_else(); }
        }
      }
    }
    // "true"
    if (char_at_dyn(start) == 116) {
      if (char_at_dyn(start + 1) == 114) {
        if (char_at_dyn(start + 2) == 117) {
          if (char_at_dyn(start + 3) == 101) { return tok_true(); }
        }
      }
    }
  }
  if (len == 5) {
    if (char_at_dyn(start) == 119) {
      if (char_at_dyn(start + 1) == 104) {
        if (char_at_dyn(start + 2) == 105) {
          if (char_at_dyn(start + 3) == 108) {
            if (char_at_dyn(start + 4) == 101) { return tok_while(); }
          }
        }
      }
    }
    // "false"
    if (char_at_dyn(start) == 102) {
      if (char_at_dyn(start + 1) == 97) {
        if (char_at_dyn(start + 2) == 108) {
          if (char_at_dyn(start + 3) == 115) {
            if (char_at_dyn(start + 4) == 101) { return tok_false(); }
          }
        }
      }
    }
  }
  if (len == 6) {
    if (char_at_dyn(start) == 114) {
      if (char_at_dyn(start + 1) == 101) {
        if (char_at_dyn(start + 2) == 116) {
          if (char_at_dyn(start + 3) == 117) {
            if (char_at_dyn(start + 4) == 114) {
              if (char_at_dyn(start + 5) == 110) { return tok_return(); }
            }
          }
        }
      }
    }
  }
  return tok_ident();
}

fn int_value_dyn(start: i32, end: i32) -> i32 {
  if (start >= end) { return 0; }
  let v: i32 = int_value_dyn(start + 1, end);
  let d: i32 = char_at_dyn(start) - 48;
  let pow: i32 = pow10(end - start - 1);
  return d * pow + v;
}

fn ident_id_dyn(start: i32, end: i32) -> i32 {
  let i: i32 = start;
  let h: i32 = 0;
  while (i < end) {
    h = h * 131 + char_at_dyn(i);
    i = i + 1;
  }
  return h;
}

fn intrinsic_id_dyn(start: i32, end: i32) -> i32 {
  let len: i32 = end - start;
  if (len == 10) {
    // "__mem_load"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 109) {
          if (char_at_dyn(start + 3) == 101) {
            if (char_at_dyn(start + 4) == 109) {
              if (char_at_dyn(start + 5) == 95) {
                if (char_at_dyn(start + 6) == 108) {
                  if (char_at_dyn(start + 7) == 111) {
                    if (char_at_dyn(start + 8) == 97) {
                      if (char_at_dyn(start + 9) == 100) { return intrin_mem_load_id(); }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    // "__fd_write"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 102) {
          if (char_at_dyn(start + 3) == 100) {
            if (char_at_dyn(start + 4) == 95) {
              if (char_at_dyn(start + 5) == 119) {
                if (char_at_dyn(start + 6) == 114) {
                  if (char_at_dyn(start + 7) == 105) {
                    if (char_at_dyn(start + 8) == 116) {
                      if (char_at_dyn(start + 9) == 101) { return intrin_fd_write_id(); }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (len == 10) {
    // "__fd_close"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 102) {
          if (char_at_dyn(start + 3) == 100) {
            if (char_at_dyn(start + 4) == 95) {
              if (char_at_dyn(start + 5) == 99) {
                if (char_at_dyn(start + 6) == 108) {
                  if (char_at_dyn(start + 7) == 111) {
                    if (char_at_dyn(start + 8) == 115) {
                      if (char_at_dyn(start + 9) == 101) { return intrin_fd_close_id(); }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (len == 11) {
    // "__mem_store"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 109) {
          if (char_at_dyn(start + 3) == 101) {
            if (char_at_dyn(start + 4) == 109) {
              if (char_at_dyn(start + 5) == 95) {
                if (char_at_dyn(start + 6) == 115) {
                  if (char_at_dyn(start + 7) == 116) {
                    if (char_at_dyn(start + 8) == 111) {
                      if (char_at_dyn(start + 9) == 114) {
                        if (char_at_dyn(start + 10) == 101) { return intrin_mem_store_id(); }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    // "__mem_load8"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 109) {
          if (char_at_dyn(start + 3) == 101) {
            if (char_at_dyn(start + 4) == 109) {
              if (char_at_dyn(start + 5) == 95) {
                if (char_at_dyn(start + 6) == 108) {
                  if (char_at_dyn(start + 7) == 111) {
                    if (char_at_dyn(start + 8) == 97) {
                      if (char_at_dyn(start + 9) == 100) {
                        if (char_at_dyn(start + 10) == 56) { return intrin_mem_load8_id(); }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    // "__path_open"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 112) {
          if (char_at_dyn(start + 3) == 97) {
            if (char_at_dyn(start + 4) == 116) {
              if (char_at_dyn(start + 5) == 104) {
                if (char_at_dyn(start + 6) == 95) {
                  if (char_at_dyn(start + 7) == 111) {
                    if (char_at_dyn(start + 8) == 112) {
                      if (char_at_dyn(start + 9) == 101) {
                        if (char_at_dyn(start + 10) == 110) { return intrin_path_open_id(); }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (len == 12) {
    // "__mem_store8"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 109) {
          if (char_at_dyn(start + 3) == 101) {
            if (char_at_dyn(start + 4) == 109) {
              if (char_at_dyn(start + 5) == 95) {
                if (char_at_dyn(start + 6) == 115) {
                  if (char_at_dyn(start + 7) == 116) {
                    if (char_at_dyn(start + 8) == 111) {
                      if (char_at_dyn(start + 9) == 114) {
                        if (char_at_dyn(start + 10) == 101) {
                          if (char_at_dyn(start + 11) == 56) { return intrin_mem_store8_id(); }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (len == 9) {
    // "__fd_read"
    if (char_at_dyn(start) == 95) {
      if (char_at_dyn(start + 1) == 95) {
        if (char_at_dyn(start + 2) == 102) {
          if (char_at_dyn(start + 3) == 100) {
            if (char_at_dyn(start + 4) == 95) {
              if (char_at_dyn(start + 5) == 114) {
                if (char_at_dyn(start + 6) == 101) {
                  if (char_at_dyn(start + 7) == 97) {
                    if (char_at_dyn(start + 8) == 100) { return intrin_fd_read_id(); }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

// Dynamic parser functions
fn peek_tok_dyn() -> i32 {
  return lex_dyn(get_pos());
}

fn next_tok_dyn() -> i32 {
  let tok: i32 = peek_tok_dyn();
  set_pos(lex_next(tok));
  return tok;
}

fn expect_dyn(kind: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == kind) {
    next_tok_dyn();
    return 1;
  }
  return 0;
}

// Parse primary expression with dynamic input
fn parse_primary_dyn() -> i32 {
  let tok: i32 = peek_tok_dyn();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_true()) { return parse_bool_dyn(1); }
  if (kind == tok_false()) { return parse_bool_dyn(0); }
  if (kind == tok_int()) {
    return parse_int_dyn();
  }
  if (kind == tok_string()) {
    return parse_string_dyn();
  }
  if (kind == tok_ident()) {
    return parse_ident_or_call_dyn();
  }
  if (kind == tok_lparen()) {
    next_tok_dyn();
    let inner: i32 = parse_expr_dyn();
    if (expect_dyn(tok_rparen()) != 1) { return 0 - 810; }
    return inner;
  }
  return 0 - 800 - kind;
}

fn parse_bool_dyn(val: i32) -> i32 {
  next_tok_dyn();
  let node: i32 = alloc_ast();
  ast_set(node, nk_bool(), val, 0, 0);
  return node;
}

fn parse_string_dyn() -> i32 {
  let start: i32 = skip_ws_dyn(get_pos());
  next_tok_dyn();
  let end: i32 = get_pos();
  let node: i32 = alloc_ast();
  // Store raw content start/len; offset assigned later
  ast_set(node, nk_string(), start + 1, end - start - 2, 0);
  return node;
}

// Parse identifier or function call
fn parse_ident_or_call_dyn() -> i32 {
  let start: i32 = skip_ws_dyn(get_pos());
  next_tok_dyn();
  let end: i32 = scan_ident_dyn(start);
  let id: i32 = ident_id_dyn(start, end);
  let intr: i32 = intrinsic_id_dyn(start, end);
  if (intr != 0) { id = intr; }

  // Check if followed by (
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_lparen()) {
    return parse_call_dyn(id);
  }

  // Just an identifier
  if (intr != 0) { return 0 - 835; }
  if (lookup_local(id) < 0) { return 0 - 836; }
  let node: i32 = alloc_ast();
  ast_set(node, nk_ident(), id, 0, 0);
  return node;
}

// Parse function call: name(args...)
// nk_call: arg_a = fn_id, arg_b = first_arg_node, arg_c = arg_count
fn parse_call_dyn(fn_id: i32) -> i32 {
  if (expect_dyn(tok_lparen()) != 1) { return 0 - 820; }

  let first_arg: i32 = 0;
  let arg_count: i32 = 0;
  let last_arg: i32 = 0;

  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) != tok_rparen()) {
    let arg0: i32 = parse_expr_dyn();
    if (arg0 < 0) { return arg0; }
    let link0: i32 = wrap_arg_node(arg0);
    first_arg = link0;
    last_arg = link0;
    arg_count = 1;

    tok = peek_tok_dyn();
    while (lex_kind(tok) == tok_comma()) {
      next_tok_dyn();
      let argn: i32 = parse_expr_dyn();
      if (argn < 0) { return argn; }
      let linkn: i32 = wrap_arg_node(argn);
      ast_set_c(last_arg, linkn);
      last_arg = linkn;
      arg_count = arg_count + 1;
      tok = peek_tok_dyn();
    }
  }

  if (expect_dyn(tok_rparen()) != 1) { return 0 - 821; }

  let node: i32 = alloc_ast();
  ast_set(node, nk_call(), fn_id, first_arg, arg_count);
  return node;
}

fn parse_int_dyn() -> i32 {
  let start: i32 = skip_ws_dyn(get_pos());
  next_tok_dyn();
  let end: i32 = scan_int_dyn(start);
  let val: i32 = int_value_dyn(start, end);
  let node: i32 = alloc_ast();
  ast_set(node, nk_int(), val, 0, 0);
  return node;
}

fn parse_mul_dyn() -> i32 {
  let left: i32 = parse_unary_dyn();
  if (left < 0) { return left; }
  return parse_mul_rest_dyn(left);
}

fn parse_mul_rest_dyn(left: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  let kind: i32 = lex_kind(tok);
  if (kind == tok_star()) { return parse_mul_op_dyn(left, nk_mul()); }
  if (kind == tok_slash()) { return parse_mul_op_dyn(left, nk_div()); }
  return left;
}

fn parse_mul_op_dyn(left: i32, nk: i32) -> i32 {
  next_tok_dyn();
  let right: i32 = parse_unary_dyn();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return parse_mul_rest_dyn(node);
}

fn parse_unary_dyn() -> i32 {
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_bang()) {
    next_tok_dyn();
    let inner: i32 = parse_unary_dyn();
    if (inner < 0) { return inner; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_not(), inner, 0, 0);
    return node;
  }
  return parse_primary_dyn();
}

fn parse_add_dyn() -> i32 {
  let left: i32 = parse_mul_dyn();
  if (left < 0) { return left; }
  return parse_add_rest_dyn(left);
}

fn parse_add_rest_dyn(left: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  let kind: i32 = lex_kind(tok);
  if (kind == tok_plus()) { return parse_add_op_dyn(left, nk_add()); }
  if (kind == tok_minus()) { return parse_add_op_dyn(left, nk_sub()); }
  return left;
}

fn parse_add_op_dyn(left: i32, nk: i32) -> i32 {
  next_tok_dyn();
  let right: i32 = parse_mul_dyn();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return parse_add_rest_dyn(node);
}

fn parse_cmp_dyn() -> i32 {
  let left: i32 = parse_add_dyn();
  if (left < 0) { return left; }
  let tok: i32 = peek_tok_dyn();
  let kind: i32 = lex_kind(tok);
  if (kind == tok_eqeq()) { return parse_cmp_op_dyn(left, nk_eq()); }
  if (kind == tok_ne()) { return parse_cmp_op_dyn(left, nk_ne()); }
  if (kind == tok_lt()) { return parse_cmp_op_dyn(left, nk_lt()); }
  if (kind == tok_gt()) { return parse_cmp_op_dyn(left, nk_gt()); }
  if (kind == tok_le()) { return parse_cmp_op_dyn(left, nk_le()); }
  if (kind == tok_ge()) { return parse_cmp_op_dyn(left, nk_ge()); }
  return left;
}

fn parse_cmp_op_dyn(left: i32, nk: i32) -> i32 {
  next_tok_dyn();
  let right: i32 = parse_add_dyn();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return node;
}

fn parse_expr_dyn() -> i32 {
  return parse_or_dyn();
}

fn parse_and_dyn() -> i32 {
  let left: i32 = parse_cmp_dyn();
  if (left < 0) { return left; }
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_and()) {
    next_tok_dyn();
    let right: i32 = parse_cmp_dyn();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_and(), left, right, 0);
    return parse_and_dyn_rest(node);
  }
  return left;
}

fn parse_and_dyn_rest(left: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_and()) {
    next_tok_dyn();
    let right: i32 = parse_cmp_dyn();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_and(), left, right, 0);
    return parse_and_dyn_rest(node);
  }
  return left;
}

fn parse_or_dyn() -> i32 {
  let left: i32 = parse_and_dyn();
  if (left < 0) { return left; }
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_or()) {
    next_tok_dyn();
    let right: i32 = parse_and_dyn();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_or(), left, right, 0);
    return parse_or_dyn_rest(node);
  }
  return left;
}

fn parse_or_dyn_rest(left: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_or()) {
    next_tok_dyn();
    let right: i32 = parse_and_dyn();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_or(), left, right, 0);
    return parse_or_dyn_rest(node);
  }
  return left;
}

// Statement parsing with dynamic input
fn parse_stmt_dyn() -> i32 {
  let tok: i32 = peek_tok_dyn();
  let kind: i32 = lex_kind(tok);
  if (kind == tok_let()) {
    let r: i32 = parse_let_dyn();
    if (r < 0) { return set_parse_error(r); }
    return r;
  }
  if (kind == tok_return()) {
    let r: i32 = parse_return_dyn();
    if (r < 0) { return set_parse_error(r); }
    return r;
  }
  if (kind == tok_if()) {
    let r: i32 = parse_if_dyn();
    if (r < 0) { return set_parse_error(r); }
    return r;
  }
  if (kind == tok_while()) {
    let r: i32 = parse_while_dyn();
    if (r < 0) { return set_parse_error(r); }
    return r;
  }
  if (kind == tok_ident()) {
    let r: i32 = parse_assign_or_expr_dyn();
    if (r < 0) { return set_parse_error(r); }
    return r;
  }
  if (kind == tok_lparen()) {
    let expr: i32 = parse_expr_dyn();
    if (expr < 0) { return set_parse_error(expr); }
    let _has_semi: i32 = expect_dyn(tok_semi());
    return expr;
  }
  return set_parse_error(0 - 700 - kind);
}

// Parse assignment (x = expr;) or expression statement
fn parse_assign_or_expr_dyn() -> i32 {
  let start: i32 = skip_ws_dyn(get_pos());
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) != tok_ident()) { return 0 - 710; }
  next_tok_dyn();
  let end: i32 = scan_ident_dyn(start);
  let id: i32 = ident_id_dyn(start, end);

  // Check if followed by = (assignment)
  let next: i32 = peek_tok_dyn();
  if (lex_kind(next) == tok_eq()) {
    next_tok_dyn();
    if (lookup_local(id) < 0) { return 0 - 712; }
    let expr: i32 = parse_expr_dyn();
    if (expr < 0) { return expr; }
    if (expect_dyn(tok_semi()) != 1) { return 0 - 711; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_assign(), id, expr, 0);
    return node;
  }

  // Not an assignment, rewind and try as expression statement
  set_pos(start);
  let expr: i32 = parse_expr_dyn();
  if (expr < 0) { return expr; }
  let _has_semi2: i32 = expect_dyn(tok_semi());
  return expr;
}

fn parse_let_dyn() -> i32 {
  if (expect_dyn(tok_let()) != 1) { return 0 - 720; }
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) != tok_ident()) { return 0 - 721; }
  let start: i32 = skip_ws_dyn(get_pos());
  next_tok_dyn();
  let end: i32 = scan_ident_dyn(start);
  let id: i32 = ident_id_dyn(start, end);
  if (expect_dyn(tok_colon()) != 1) { return 0 - 722; }
  if (expect_dyn(tok_i32()) != 1) { return 0 - 723; }
  if (expect_dyn(tok_eq()) != 1) { return 0 - 724; }
  let expr: i32 = parse_expr_dyn();
  if (expr < 0) { return expr; }
  if (expect_dyn(tok_semi()) != 1) { return 0 - 725; }
  add_local(id);
  let node: i32 = alloc_ast();
  ast_set(node, nk_let(), id, expr, 0);
  return node;
}

fn parse_return_dyn() -> i32 {
  if (expect_dyn(tok_return()) != 1) { return 0 - 730; }
  let expr: i32 = parse_expr_dyn();
  if (expr < 0) { return expr; }
  // Allow optional semicolon to avoid hard failures on formatting
  let _has_semi: i32 = expect_dyn(tok_semi());
  let node: i32 = alloc_ast();
  ast_set(node, nk_return(), expr, 0, 0);
  return node;
}

fn parse_if_dyn() -> i32 {
  if (expect_dyn(tok_if()) != 1) { return 0 - 740; }
  if (expect_dyn(tok_lparen()) != 1) { return 0 - 741; }
  let cond: i32 = parse_expr_dyn();
  if (cond < 0) { return cond; }
  if (expect_dyn(tok_rparen()) != 1) { return 0 - 742; }
  if (expect_dyn(tok_lbrace()) != 1) { return 0 - 743; }
  let then_block: i32 = parse_block_dyn();
  if (then_block < 0) { return then_block; }
  if (expect_dyn(tok_rbrace()) != 1) { return 0 - 744; }
  let else_block: i32 = 0 - 1;
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_else()) {
    next_tok_dyn();
    if (expect_dyn(tok_lbrace()) != 1) { return 0 - 745; }
    else_block = parse_block_dyn();
    if (else_block < 0) { return else_block; }
    if (expect_dyn(tok_rbrace()) != 1) { return 0 - 746; }
  }
  let node: i32 = alloc_ast();
  ast_set(node, nk_if(), cond, then_block, else_block);
  return node;
}

fn parse_while_dyn() -> i32 {
  if (expect_dyn(tok_while()) != 1) { return 0 - 750; }
  if (expect_dyn(tok_lparen()) != 1) { return 0 - 751; }
  let cond: i32 = parse_expr_dyn();
  if (cond < 0) { return cond; }
  if (expect_dyn(tok_rparen()) != 1) { return 0 - 752; }
  if (expect_dyn(tok_lbrace()) != 1) { return 0 - 753; }
  let body: i32 = parse_block_dyn();
  if (body < 0) { return body; }
  if (expect_dyn(tok_rbrace()) != 1) { return 0 - 754; }
  let node: i32 = alloc_ast();
  ast_set(node, nk_while(), cond, body, 0);
  return node;
}

fn parse_block_dyn() -> i32 {
  let first_stmt: i32 = 0 - 1;
  let last_stmt: i32 = 0 - 1;
  let count: i32 = 0;

  let done: i32 = 0;
  while (done == 0) {
    let tok: i32 = peek_tok_dyn();
    let kind: i32 = lex_kind(tok);
    if (kind == tok_rbrace()) {
      done = 1;
    } else {
      if (kind == tok_eof()) {
        done = 1;
      } else {
        let stmt: i32 = parse_stmt_dyn();
        if (stmt < 0) { return set_parse_error(stmt); }
        let link: i32 = wrap_stmt_node(stmt);

        if (first_stmt < 0) {
          first_stmt = link;
        } else {
          ast_set_c(last_stmt, link);
        }
        last_stmt = link;
        count = count + 1;
      }
    }
  }

  let node: i32 = alloc_ast();
  ast_set(node, nk_block(), first_stmt, count, 0);
  return node;
}

fn parse_stmts_dyn(count: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  let kind: i32 = lex_kind(tok);
  if (kind == tok_rbrace()) { return count; }
  if (kind == tok_eof()) { return count; }
  let stmt: i32 = parse_stmt_dyn();
  if (stmt < 0) { return 0 - 1; }
  return parse_stmts_dyn(count + 1);
}

// Parse function header with dynamic input
fn parse_fn_header_dyn() -> i32 {
  if (expect_dyn(tok_fn()) != 1) { return 0; }
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) != tok_ident()) { return 0; }
  next_tok_dyn();
  if (expect_dyn(tok_lparen()) != 1) { return 0; }
  if (expect_dyn(tok_rparen()) != 1) { return 0; }
  if (expect_dyn(tok_arrow()) != 1) { return 0; }
  if (expect_dyn(tok_i32()) != 1) { return 0; }
  if (expect_dyn(tok_lbrace()) != 1) { return 0; }
  return 1;
}

// Parse function body with dynamic input
fn parse_fn_body_dyn() -> i32 {
  let first_stmt: i32 = 0 - 1;
  let last_stmt: i32 = 0 - 1;
  let count: i32 = 0;

  let done: i32 = 0;
  while (done == 0) {
    let tok: i32 = peek_tok_dyn();
    let kind: i32 = lex_kind(tok);
    if (kind == tok_rbrace()) {
      done = 1;
    } else {
      if (kind == tok_eof()) {
        done = 1;
      } else {
        let stmt: i32 = parse_stmt_dyn();
        if (stmt < 0) { return stmt; }
        let link: i32 = wrap_stmt_node(stmt);

        if (first_stmt < 0) {
          first_stmt = link;
        } else {
          ast_set_c(last_stmt, link);
        }
        last_stmt = link;
        count = count + 1;
      }
    }
  }

  if (expect_dyn(tok_rbrace()) != 1) { return 0 - 1; }
  let node: i32 = alloc_ast();
  ast_set(node, nk_block(), first_stmt, count, 0);
  return node;
}

// Compile function from dynamic source buffer
fn compile_fn_dyn() -> i32 {
  parser_init(0);
  codegen_init();
  wat_init();
  let hdr: i32 = parse_fn_header_dyn();
  if (hdr != 1) { return 301; }
  let body: i32 = parse_fn_body_dyn();
  if (body < 0) { return 302; }
  let ir_ok: i32 = emit_ir_block_stmts(body);
  if (ir_ok < 0) { return ir_ok; }
  let wat_ok: i32 = emit_wat_from_ir_general();
  if (wat_ok != 1) { return 304; }
  return 1;
}

// ============================================================================
// Stage 3 Test: Compile from dynamic input
// ============================================================================

fn test_dynamic_compile() -> i32 {
  // Load a DIFFERENT program into memory and compile it
  // Program: fn main() -> i32 { let a: i32 = 5; let b: i32 = 3; return a * b; }
  // This should produce: const 5; store a; const 3; store b; load a; load b; mul; ret
  init_src_buffer();
  load_test_program();

  let ok: i32 = compile_fn_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return ok;
  }

  // Verify IR: should have 8 instructions
  let ir_cnt: i32 = get_ir_count();
  if (ir_cnt != 8) {
    clear_src_buffer();
    return 310;
  }

  // Verify: const 5
  if (ir_opcode(0) != op_const()) { clear_src_buffer(); return 311; }
  if (ir_arg(0) != 5) { clear_src_buffer(); return 312; }

  // Verify: store a
  if (ir_opcode(1) != op_store()) { clear_src_buffer(); return 313; }

  // Verify: const 3
  if (ir_opcode(2) != op_const()) { clear_src_buffer(); return 314; }
  if (ir_arg(2) != 3) { clear_src_buffer(); return 315; }

  // Verify: store b
  if (ir_opcode(3) != op_store()) { clear_src_buffer(); return 316; }

  // Verify: load a, load b, mul
  if (ir_opcode(4) != op_load()) { clear_src_buffer(); return 317; }
  if (ir_opcode(5) != op_load()) { clear_src_buffer(); return 318; }
  if (ir_opcode(6) != op_mul()) { clear_src_buffer(); return 319; }

  // Verify: ret
  if (ir_opcode(7) != op_ret()) { clear_src_buffer(); return 320; }

  // Verify WAT output
  if (get_wat_count() != 8) { clear_src_buffer(); return 321; }
  if (wat_opcode(0) != w_const()) { clear_src_buffer(); return 322; }
  if (wat_arg(0) != 5) { clear_src_buffer(); return 323; }
  if (wat_opcode(6) != w_mul()) { clear_src_buffer(); return 324; }
  if (wat_opcode(7) != w_return()) { clear_src_buffer(); return 325; }

  clear_src_buffer();
  return 1;
}

// Load test program: "fn main() -> i32 { let a: i32 = 5; let b: i32 = 3; return a * b; }"
fn load_test_program() -> i32 {
  let i: i32 = 0;
  // f
  src_store(i, 102); i = i + 1;
  // n
  src_store(i, 110); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // m
  src_store(i, 109); i = i + 1;
  // a
  src_store(i, 97); i = i + 1;
  // i
  src_store(i, 105); i = i + 1;
  // n
  src_store(i, 110); i = i + 1;
  // (
  src_store(i, 40); i = i + 1;
  // )
  src_store(i, 41); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // -
  src_store(i, 45); i = i + 1;
  // >
  src_store(i, 62); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // i
  src_store(i, 105); i = i + 1;
  // 3
  src_store(i, 51); i = i + 1;
  // 2
  src_store(i, 50); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // {
  src_store(i, 123); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // l
  src_store(i, 108); i = i + 1;
  // e
  src_store(i, 101); i = i + 1;
  // t
  src_store(i, 116); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // a
  src_store(i, 97); i = i + 1;
  // :
  src_store(i, 58); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // i
  src_store(i, 105); i = i + 1;
  // 3
  src_store(i, 51); i = i + 1;
  // 2
  src_store(i, 50); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // =
  src_store(i, 61); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // 5
  src_store(i, 53); i = i + 1;
  // ;
  src_store(i, 59); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // l
  src_store(i, 108); i = i + 1;
  // e
  src_store(i, 101); i = i + 1;
  // t
  src_store(i, 116); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // b
  src_store(i, 98); i = i + 1;
  // :
  src_store(i, 58); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // i
  src_store(i, 105); i = i + 1;
  // 3
  src_store(i, 51); i = i + 1;
  // 2
  src_store(i, 50); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // =
  src_store(i, 61); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // 3
  src_store(i, 51); i = i + 1;
  // ;
  src_store(i, 59); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // r
  src_store(i, 114); i = i + 1;
  // e
  src_store(i, 101); i = i + 1;
  // t
  src_store(i, 116); i = i + 1;
  // u
  src_store(i, 117); i = i + 1;
  // r
  src_store(i, 114); i = i + 1;
  // n
  src_store(i, 110); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // a
  src_store(i, 97); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // *
  src_store(i, 42); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // b
  src_store(i, 98); i = i + 1;
  // ;
  src_store(i, 59); i = i + 1;
  // space
  src_store(i, 32); i = i + 1;
  // }
  src_store(i, 125); i = i + 1;
  // null terminator
  src_store(i, 0);
  return 0;
}

// Test: compile a program with if statement from dynamic input
fn test_dynamic_if() -> i32 {
  // Program: fn main() -> i32 { let x: i32 = 5; if (x > 3) { return 1; } return 0; }
  init_src_buffer();
  load_if_program();

  let ok: i32 = compile_fn_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // Verify we got some IR with control flow
  let ir_cnt: i32 = get_ir_count();
  if (ir_cnt < 5) {
    clear_src_buffer();
    return 0;
  }

  // Should start with: const 5; store x
  if (ir_opcode(0) != op_const()) { clear_src_buffer(); return 0; }
  if (ir_arg(0) != 5) { clear_src_buffer(); return 0; }
  if (ir_opcode(1) != op_store()) { clear_src_buffer(); return 0; }

  // Should have block/br_if for the if
  let has_block: i32 = find_ir_opcode(op_block(), 0, ir_cnt);
  if (has_block != 1) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

fn find_ir_opcode(op: i32, idx: i32, cnt: i32) -> i32 {
  if (idx >= cnt) { return 0; }
  if (ir_opcode(idx) == op) { return 1; }
  return find_ir_opcode(op, idx + 1, cnt);
}

// Load: "fn main() -> i32 { let x: i32 = 5; if (x > 3) { return 1; } return 0; }"
fn load_if_program() -> i32 {
  let i: i32 = 0;
  // "fn main() -> i32 { "
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  // "let x: i32 = 5; "
  i = store_str(i, 108); // l
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 32);  // space
  i = store_str(i, 120); // x
  i = store_str(i, 58);  // :
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 61);  // =
  i = store_str(i, 32);  // space
  i = store_str(i, 53);  // 5
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  // "if (x > 3) { "
  i = store_str(i, 105); // i
  i = store_str(i, 102); // f
  i = store_str(i, 32);  // space
  i = store_str(i, 40);  // (
  i = store_str(i, 120); // x
  i = store_str(i, 32);  // space
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 51);  // 3
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  // "return 1; "
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 49);  // 1
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  // "} "
  i = store_str(i, 125); // }
  i = store_str(i, 32);  // space
  // "return 0; }"
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 48);  // 0
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

fn store_str(pos: i32, byte: i32) -> i32 {
  src_store(pos, byte);
  return pos + 1;
}

// ============================================================================
// Stage 4 Test: Function calls
// ============================================================================

fn test_function_call() -> i32 {
  // Test parsing and compiling a program with a function call
  // Program: fn main() -> i32 { return foo(); }
  // We'll manually build the AST and test codegen

  parser_init(0);
  codegen_init();
  set_fn_count(0);

  // Register function "foo" with ident_id 1000
  register_fn(1000, 0);

  // Build AST: return foo();
  // Node 0: call foo
  ast_set(0, nk_call(), 1000, 0, 0);
  // Node 1: return (node 0)
  ast_set(1, nk_return(), 0, 0, 0);

  // Emit IR
  let r: i32 = emit_ir_stmt(1);
  if (r < 0) { return 0; }

  // Should have: call foo; ret
  if (get_ir_count() != 2) { return 0; }
  if (ir_opcode(0) != op_call()) { return 0; }
  if (ir_arg(0) != 0) { return 0; }
  if (ir_opcode(1) != op_ret()) { return 0; }

  // Lower to WAT
  let w: i32 = emit_wat_from_ir_general();
  if (w != 1) { return 0; }

  // Should have: call; return
  if (get_wat_count() != 2) { return 0; }
  if (wat_opcode(0) != w_call()) { return 0; }
  if (wat_arg(0) != 0) { return 0; }
  if (wat_opcode(1) != w_return()) { return 0; }

  return 1;
}

// Test parsing a function call from dynamic input
fn test_parse_call_dyn() -> i32 {
  // Program: fn main() -> i32 { return add(); }
  init_src_buffer();
  load_call_program();

  // Register "add" function with expected ident_id hash
  // hash("add") = 1677817
  set_fn_count(0);
  register_fn(1677817, 0);

  let ok: i32 = compile_fn_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // Should have: call; ret
  if (get_ir_count() != 2) { clear_src_buffer(); return 0; }
  if (ir_opcode(0) != op_call()) { clear_src_buffer(); return 0; }
  if (ir_opcode(1) != op_ret()) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// ============================================================================
// Stage 4: Multi-function parsing
// ============================================================================

// Function AST storage: track each function's body node
fn state_fn_ast_base() -> i32 { return state_base() + 32; }
fn fn_ast_addr(idx: i32) -> i32 { return fn_table_addr() + 16384 + idx * 4; }

fn set_fn_ast(idx: i32, body_node: i32) -> i32 {
  __mem_store(fn_ast_addr(idx), body_node);
  return 0;
}

fn get_fn_ast(idx: i32) -> i32 {
  return __mem_load(fn_ast_addr(idx));
}

// Parse a single function definition, returns function index
fn parse_fn_def_dyn() -> i32 {
  if (expect_dyn(tok_fn()) != 1) { return set_parse_error(0 - 601); }

  // Parse function name
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) != tok_ident()) { return set_parse_error(0 - 602); }
  let start: i32 = skip_ws_dyn(get_pos());
  next_tok_dyn();
  let end: i32 = scan_ident_dyn(start);
  let fn_id: i32 = ident_id_dyn(start, end);

  // Reset locals for this function (params will be added first)
  set_local_count(0);

  // Register function now so we can track locals while parsing params/body
  let fn_idx: i32 = register_fn(fn_id, 0);
  set_current_fn(fn_idx);

  // Parse parameters
  if (expect_dyn(tok_lparen()) != 1) { return set_parse_error(0 - 603); }
  let param_count: i32 = parse_params_dyn();
  if (param_count < 0) { set_current_fn(0 - 1); return set_parse_error(0 - 604); }
  if (expect_dyn(tok_rparen()) != 1) { set_current_fn(0 - 1); return set_parse_error(0 - 605); }
  set_fn_param_count(fn_idx, param_count);

  // Parse -> type
  if (expect_dyn(tok_arrow()) != 1) { set_current_fn(0 - 1); return set_parse_error(0 - 606); }
  if (expect_dyn(tok_i32()) != 1) { set_current_fn(0 - 1); return set_parse_error(0 - 607); }

  // Parse { body }
  if (expect_dyn(tok_lbrace()) != 1) { set_current_fn(0 - 1); return set_parse_error(0 - 608); }

  let body: i32 = parse_block_dyn();
  if (body < 0) { set_current_fn(0 - 1); return set_parse_error(body); }

  if (expect_dyn(tok_rbrace()) != 1) { set_current_fn(0 - 1); return set_parse_error(0 - 610); }

  // Store function's body AST and local count
  set_fn_ast(fn_idx, body);
  set_fn_local_count(fn_idx, get_local_count());
  set_current_fn(0 - 1);

  return fn_idx;
}

// Parse function parameters: (name: type, name: type, ...)
// Returns parameter count
fn parse_params_dyn() -> i32 {
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_rparen()) { return 0; }
  return parse_param_list_dyn(0);
}

fn parse_param_list_dyn(count: i32) -> i32 {
  // Parse param name
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) != tok_ident()) { return 0 - 1; }
  let start: i32 = skip_ws_dyn(get_pos());
  next_tok_dyn();
  let end: i32 = scan_ident_dyn(start);
  let param_id: i32 = ident_id_dyn(start, end);

  // Parse : type
  if (expect_dyn(tok_colon()) != 1) { return 0 - 1; }
  if (expect_dyn(tok_i32()) != 1) { return 0 - 1; }

  // Register parameter as a local (params come first in local indices)
  add_local(param_id);

  // Check for more params
  let next: i32 = peek_tok_dyn();
  if (lex_kind(next) == tok_comma()) {
    next_tok_dyn();
    return parse_param_list_dyn(count + 1);
  }

  return count + 1;
}

// Store function's local count
fn set_fn_local_count(idx: i32, count: i32) -> i32 {
  __mem_store(fn_entry_addr(idx, 8), count);
  return 0;
}

// Parse multiple functions until EOF
fn parse_program_dyn() -> i32 {
  return parse_fns_dyn(0);
}

fn parse_fns_dyn(count: i32) -> i32 {
  let tok: i32 = peek_tok_dyn();
  if (lex_kind(tok) == tok_eof()) { return count; }
  if (lex_kind(tok) != tok_fn()) { return count; }

  let fn_idx: i32 = parse_fn_def_dyn();
  if (fn_idx < 0) { return fn_idx; }

  return parse_fns_dyn(count + 1);
}

// Compile all functions in the program
fn compile_program_dyn() -> i32 {
  parser_init(0);
  set_fn_count(0);

  // First pass: parse all functions
  let fn_count: i32 = parse_program_dyn();
  if (fn_count < 0) { return 0; }

  let str_ok: i32 = assign_string_offsets_program(fn_count);
  if (str_ok < 0) { return 0; }

  // Second pass: emit IR for each function
  // For now, just emit main's code
  let main_idx: i32 = find_main_fn();
  if (main_idx < 0) { return 0; }

  let tc: i32 = typecheck_fn(main_idx);
  if (tc < 0) { return 0; }

  codegen_init();
  wat_init();

  set_current_fn(main_idx);
  set_local_count(fn_locals(main_idx));
  let body: i32 = get_fn_ast(main_idx);
  let ir_ok: i32 = emit_ir_block_stmts(body);
  if (ir_ok < 0) { return 0; }

  let wat_ok: i32 = emit_wat_from_ir_general();
  if (wat_ok != 1) { return 0; }
  set_current_fn(0 - 1);

  return 1;
}

// Compile program and write WAT to stdout
fn compile_program_to_stdout() -> i32 {
  if (get_src_base() <= 0) { init_src_buffer(); }
  parser_init(0);
  set_fn_count(0);

  let fn_count: i32 = parse_program_dyn();
  if (fn_count < 0) { return fn_count; }

  let str_ok2: i32 = assign_string_offsets_program(fn_count);
  if (str_ok2 < 0) { return str_ok2; }

  let tc2: i32 = typecheck_fns(0, fn_count);
  if (tc2 < 0) { return tc2; }

  let dbg: i32 = debug_enabled();
  if (dbg == 2) {
    debug_dump_main_counts();
    return 910;
  }

  let len: i32 = gen_wat_module_all();
  if (len <= 0) { return 502; }

  let rc: i32 = out_flush();
  if (rc != 0) { return 503; }
  return 1;
}

// Compile program and write WAT to a file via WASI path_open/fd_write
fn compile_program_to_file(path_ptr: i32, path_len: i32) -> i32 {
  if (get_src_base() <= 0) { init_src_buffer(); }
  parser_init(0);
  set_fn_count(0);

  let fn_count: i32 = parse_program_dyn();
  if (fn_count < 0) { return fn_count; }

  let str_ok3: i32 = assign_string_offsets_program(fn_count);
  if (str_ok3 < 0) { return str_ok3; }

  let tc3: i32 = typecheck_fns(0, fn_count);
  if (tc3 < 0) { return tc3; }

  let dbg: i32 = debug_enabled();
  if (dbg == 2) {
    debug_dump_main_counts();
    return 910;
  }

  let len: i32 = gen_wat_module_all();
  if (len <= 0) { return 502; }

  __mem_store(state_out_fd(), 0);
  let rc_open: i32 = __path_open(3, 0, path_ptr, path_len, 9, 64, 0, 0, state_out_fd());
  if (rc_open != 0) { return 520; }
  let fd: i32 = __mem_load(state_out_fd());

  let rc_write: i32 = out_flush_fd(fd);
  if (rc_write != 0) {
    __fd_close(fd);
    return 521;
  }

  let rc_close: i32 = __fd_close(fd);
  if (rc_close != 0) { return 522; }
  return 1;
}

// Read source from stdin and compile to WAT on stdout
fn compile_stdin_to_stdout() -> i32 {
  let nread: i32 = read_src_from_stdin();
  if (nread <= 0) { return 401; }
  let rc: i32 = compile_program_to_stdout();
  if (rc != 1) { return rc; }
  return 1;
}

// Compile all functions in program (full version)
fn compile_all_fns_dyn() -> i32 {
  parser_init(0);
  set_fn_count(0);

  // First pass: parse all functions
  let fn_count: i32 = parse_program_dyn();
  if (fn_count < 0) { return 0; }

  let str_ok4: i32 = assign_string_offsets_program(fn_count);
  if (str_ok4 < 0) { return str_ok4; }

  let tc4: i32 = typecheck_fns(0, fn_count);
  if (tc4 < 0) { return tc4; }

  // Second pass: emit IR/WAT for each function
  return compile_fns_ir(0, fn_count);
}

fn compile_fns_ir(idx: i32, count: i32) -> i32 {
  if (idx >= count) { return 1; }

  // Emit IR for this function
  codegen_init();
  set_current_fn(idx);
  set_local_count(fn_locals(idx));
  let body: i32 = get_fn_ast(idx);
  let ir_ok: i32 = emit_ir_block_stmts(body);
  if (ir_ok < 0) { return 0; }

  // Store IR count for this function
  set_fn_ir_count(idx, get_ir_count());
  set_current_fn(0 - 1);

  return compile_fns_ir(idx + 1, count);
}

// Per-function IR count storage
fn fn_ir_count_addr(idx: i32) -> i32 { return fn_table_addr() + 20480 + idx * 4; }

fn set_fn_ir_count(idx: i32, count: i32) -> i32 {
  __mem_store(fn_ir_count_addr(idx), count);
  return 0;
}

fn get_fn_ir_count(idx: i32) -> i32 {
  return __mem_load(fn_ir_count_addr(idx));
}

// ============================================================================
// Stage 5: WAT Text Output
// ============================================================================
// Output buffer at 0x6901B0 (48MB)
fn out_buffer_addr() -> i32 { return 19922944; }
fn out_buffer_size() -> i32 { return 50331648; }
fn io_vec_addr() -> i32 { return 73400320; }
fn io_nwritten_addr() -> i32 { return io_vec_addr() + 8; }
fn io_nread_addr() -> i32 { return io_vec_addr() + 12; }

// Per-function local identifier table (stored after output buffer)
fn fn_local_table_addr() -> i32 { return out_buffer_addr() + out_buffer_size(); }
fn fn_local_stride() -> i32 { return 512; }
fn fn_local_entry_addr(fn_idx: i32, local_idx: i32) -> i32 {
  return fn_local_table_addr() + fn_idx * fn_local_stride() * 4 + local_idx * 4;
}
fn fn_local_ident(fn_idx: i32, local_idx: i32) -> i32 {
  return __mem_load(fn_local_entry_addr(fn_idx, local_idx));
}
fn fn_set_local_ident(fn_idx: i32, local_idx: i32, ident_id: i32) -> i32 {
  __mem_store(fn_local_entry_addr(fn_idx, local_idx), ident_id);
  return 0;
}

// Temporary stack for WAT emission (block entry depths)
fn wat_block_stack_base() -> i32 { return state_base() + 4096; }

fn state_out_pos() -> i32 { return state_base() + 36; }
fn state_emit_stdout_flag() -> i32 { return state_base() + 40; }
fn state_stdin_flag() -> i32 { return state_base() + 44; }
fn state_debug_flag() -> i32 { return state_base() + 48; }
fn state_err_code() -> i32 { return state_base() + 52; }
fn state_err_pos() -> i32 { return state_base() + 56; }
fn state_err_tok() -> i32 { return state_base() + 60; }
fn state_current_fn() -> i32 { return state_base() + 64; }
fn state_out_fd() -> i32 { return state_base() + 68; }
fn state_emit_file_flag() -> i32 { return state_base() + 72; }
fn state_err_line() -> i32 { return state_base() + 76; }
fn state_err_col() -> i32 { return state_base() + 80; }
fn get_out_pos() -> i32 { return __mem_load(state_out_pos()); }
fn set_out_pos(p: i32) -> i32 { __mem_store(state_out_pos(), p); return 0; }
fn get_current_fn() -> i32 { return __mem_load(state_current_fn()); }
fn set_current_fn(idx: i32) -> i32 { __mem_store(state_current_fn(), idx); return 0; }

fn out_init() -> i32 {
  set_out_pos(0);
  return 0;
}

// Flush output buffer to stdout via WASI fd_write
fn out_flush() -> i32 {
  let len: i32 = get_out_pos();
  __mem_store(io_vec_addr(), out_buffer_addr());
  __mem_store(io_vec_addr() + 4, len);
  __mem_store(io_nwritten_addr(), 0);
  return __fd_write(1, io_vec_addr(), 1, io_nwritten_addr());
}

// Flush output buffer to a specific fd via WASI fd_write
fn out_flush_fd(fd: i32) -> i32 {
  let len: i32 = get_out_pos();
  __mem_store(io_vec_addr(), out_buffer_addr());
  __mem_store(io_vec_addr() + 4, len);
  __mem_store(io_nwritten_addr(), 0);
  return __fd_write(fd, io_vec_addr(), 1, io_nwritten_addr());
}

// Read a file into the source buffer via WASI path_open/fd_read
fn read_file_into_src(path_ptr: i32, path_len: i32) -> i32 {
  init_src_buffer();
  let max_len: i32 = src_buffer_size() - 1;
  let total: i32 = 0;
  let done: i32 = 0;

  __mem_store(state_out_fd(), 0);
  let rc_open: i32 = __path_open(3, 0, path_ptr, path_len, 0, 1, 0, 0, state_out_fd());
  if (rc_open != 0) { return 530; }
  let fd: i32 = __mem_load(state_out_fd());

  while (done == 0) {
    if (total >= max_len) {
      done = 1;
    } else {
      let remain: i32 = max_len - total;
      __mem_store(io_vec_addr(), src_buffer_addr() + total);
      __mem_store(io_vec_addr() + 4, remain);
      __mem_store(io_nread_addr(), 0);
      let rc: i32 = __fd_read(fd, io_vec_addr(), 1, io_nread_addr());
      if (rc != 0) {
        __fd_close(fd);
        return 531;
      }
      let nread: i32 = __mem_load(io_nread_addr());
      if (nread <= 0) {
        done = 1;
      } else {
        total = total + nread;
      }
    }
  }

  __mem_store8(src_buffer_addr() + total, 0);
  let rc_close: i32 = __fd_close(fd);
  if (rc_close != 0) { return 532; }
  return total;
}

// Read stdin into source buffer, null-terminate, and return bytes read
fn read_src_from_stdin() -> i32 {
  init_src_buffer();
  let max_len: i32 = src_buffer_size() - 1;
  let total: i32 = 0;
  let done: i32 = 0;

  while (done == 0) {
    if (total >= max_len) {
      done = 1;
    } else {
      let remain: i32 = max_len - total;
      __mem_store(io_vec_addr(), src_buffer_addr() + total);
      __mem_store(io_vec_addr() + 4, remain);
      __mem_store(io_nread_addr(), 0);
      let rc: i32 = __fd_read(0, io_vec_addr(), 1, io_nread_addr());
      if (rc != 0) { return 0; }
      let nread: i32 = __mem_load(io_nread_addr());
      if (nread <= 0) {
        done = 1;
      } else {
        total = total + nread;
      }
    }
  }

  __mem_store8(src_buffer_addr() + total, 0);
  return total;
}

// Compute line/column from position and store in error state
fn set_error_line_col(pos: i32) -> i32 {
  let i: i32 = 0;
  let line: i32 = 1;
  let col: i32 = 1;
  while (i < pos) {
    let c: i32 = char_at_dyn(i);
    if (c == 10) {
      line = line + 1;
      col = 1;
    } else {
      col = col + 1;
    }
    i = i + 1;
  }
  __mem_store(state_err_line(), line);
  __mem_store(state_err_col(), col);
  return 0;
}

// Append a single byte to output
fn out_byte(b: i32) -> i32 {
  let pos: i32 = get_out_pos();
  __mem_store8(out_buffer_addr() + pos, b);
  set_out_pos(pos + 1);
  return 0;
}

// Append a character (same as byte)
fn out_char(c: i32) -> i32 {
  return out_byte(c);
}

// Append a newline
fn out_nl() -> i32 {
  return out_char(10);
}

// Append a space
fn out_sp() -> i32 {
  return out_char(32);
}

// Append multiple spaces for indentation
fn out_indent(n: i32) -> i32 {
  if (n <= 0) { return 0; }
  out_sp();
  return out_indent(n - 1);
}

// Append a string literal (hardcoded strings via helper functions)
fn out_str_module() -> i32 {
  out_char(40);  // (
  out_char(109); // m
  out_char(111); // o
  out_char(100); // d
  out_char(117); // u
  out_char(108); // l
  out_char(101); // e
  return 0;
}

fn out_str_memory() -> i32 {
  out_char(40);  // (
  out_char(109); // m
  out_char(101); // e
  out_char(109); // m
  out_char(111); // o
  out_char(114); // r
  out_char(121); // y
  out_sp();
  out_char(50);  // 2
  out_char(48);  // 0
  out_char(52);  // 4
  out_char(56);  // 8
  out_char(41);  // )
  return 0;
}

fn out_str_memory_kw() -> i32 {
  out_char(109); // m
  out_char(101); // e
  out_char(109); // m
  out_char(111); // o
  out_char(114); // r
  out_char(121); // y
  return 0;
}

fn out_str_func() -> i32 {
  out_char(40);  // (
  out_char(102); // f
  out_char(117); // u
  out_char(110); // n
  out_char(99);  // c
  return 0;
}

fn out_str_param() -> i32 {
  out_char(40);  // (
  out_char(112); // p
  out_char(97);  // a
  out_char(114); // r
  out_char(97);  // a
  out_char(109); // m
  return 0;
}

fn out_str_result() -> i32 {
  out_char(40);  // (
  out_char(114); // r
  out_char(101); // e
  out_char(115); // s
  out_char(117); // u
  out_char(108); // l
  out_char(116); // t
  return 0;
}

fn out_str_local() -> i32 {
  out_char(40);  // (
  out_char(108); // l
  out_char(111); // o
  out_char(99);  // c
  out_char(97);  // a
  out_char(108); // l
  return 0;
}

fn out_str_i32() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  return 0;
}

fn out_str_i64() -> i32 {
  out_char(105); // i
  out_char(54);  // 6
  out_char(52);  // 4
  return 0;
}

fn out_str_const() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(99);  // c
  out_char(111); // o
  out_char(110); // n
  out_char(115); // s
  out_char(116); // t
  return 0;
}

fn out_str_local_get() -> i32 {
  out_char(108); // l
  out_char(111); // o
  out_char(99);  // c
  out_char(97);  // a
  out_char(108); // l
  out_char(46);  // .
  out_char(103); // g
  out_char(101); // e
  out_char(116); // t
  return 0;
}

fn out_str_local_set() -> i32 {
  out_char(108); // l
  out_char(111); // o
  out_char(99);  // c
  out_char(97);  // a
  out_char(108); // l
  out_char(46);  // .
  out_char(115); // s
  out_char(101); // e
  out_char(116); // t
  return 0;
}

fn out_str_i32_load() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(108); // l
  out_char(111); // o
  out_char(97);  // a
  out_char(100); // d
  return 0;
}

fn out_str_i32_store() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(115); // s
  out_char(116); // t
  out_char(111); // o
  out_char(114); // r
  out_char(101); // e
  return 0;
}

fn out_str_i32_load8_u() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(108); // l
  out_char(111); // o
  out_char(97);  // a
  out_char(100); // d
  out_char(56);  // 8
  out_char(95);  // _
  out_char(117); // u
  return 0;
}

fn out_str_i32_store8() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(115); // s
  out_char(116); // t
  out_char(111); // o
  out_char(114); // r
  out_char(101); // e
  out_char(56);  // 8
  return 0;
}

fn out_str_add() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(97);  // a
  out_char(100); // d
  out_char(100); // d
  return 0;
}

fn out_str_sub() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(115); // s
  out_char(117); // u
  out_char(98);  // b
  return 0;
}

fn out_str_mul() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(109); // m
  out_char(117); // u
  out_char(108); // l
  return 0;
}

fn out_str_div() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(100); // d
  out_char(105); // i
  out_char(118); // v
  out_char(95);  // _
  out_char(115); // s
  return 0;
}

fn out_str_lt() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(108); // l
  out_char(116); // t
  out_char(95);  // _
  out_char(115); // s
  return 0;
}

fn out_str_gt() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(103); // g
  out_char(116); // t
  out_char(95);  // _
  out_char(115); // s
  return 0;
}

fn out_str_eq() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(101); // e
  out_char(113); // q
  return 0;
}

fn out_str_ne() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(110); // n
  out_char(101); // e
  return 0;
}

fn out_str_le() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(108); // l
  out_char(101); // e
  out_char(95);  // _
  out_char(115); // s
  return 0;
}

fn out_str_ge() -> i32 {
  out_char(105); // i
  out_char(51);  // 3
  out_char(50);  // 2
  out_char(46);  // .
  out_char(103); // g
  out_char(101); // e
  out_char(95);  // _
  out_char(115); // s
  return 0;
}

fn out_str_return() -> i32 {
  out_char(114); // r
  out_char(101); // e
  out_char(116); // t
  out_char(117); // u
  out_char(114); // r
  out_char(110); // n
  return 0;
}

fn out_str_drop() -> i32 {
  out_char(100); // d
  out_char(114); // r
  out_char(111); // o
  out_char(112); // p
  return 0;
}

fn out_str_call() -> i32 {
  out_char(99);  // c
  out_char(97);  // a
  out_char(108); // l
  out_char(108); // l
  return 0;
}

fn out_str_block() -> i32 {
  out_char(98);  // b
  out_char(108); // l
  out_char(111); // o
  out_char(99);  // c
  out_char(107); // k
  return 0;
}

fn out_str_loop() -> i32 {
  out_char(108); // l
  out_char(111); // o
  out_char(111); // o
  out_char(112); // p
  return 0;
}

fn out_str_br() -> i32 {
  out_char(98);  // b
  out_char(114); // r
  return 0;
}

fn out_str_br_if() -> i32 {
  out_char(98);  // b
  out_char(114); // r
  out_char(95);  // _
  out_char(105); // i
  out_char(102); // f
  return 0;
}

fn out_str_end() -> i32 {
  out_char(101); // e
  out_char(110); // n
  out_char(100); // d
  return 0;
}

fn out_str_export() -> i32 {
  out_char(40);  // (
  out_char(101); // e
  out_char(120); // x
  out_char(112); // p
  out_char(111); // o
  out_char(114); // r
  out_char(116); // t
  return 0;
}

fn out_str_data() -> i32 {
  out_char(40);  // (
  out_char(100); // d
  out_char(97);  // a
  out_char(116); // t
  out_char(97);  // a
  return 0;
}

fn out_str_import() -> i32 {
  out_char(40);  // (
  out_char(105); // i
  out_char(109); // m
  out_char(112); // p
  out_char(111); // o
  out_char(114); // r
  out_char(116); // t
  return 0;
}

fn out_str_wasi_snapshot() -> i32 {
  out_char(34);  // "
  out_char(119); // w
  out_char(97);  // a
  out_char(115); // s
  out_char(105); // i
  out_char(95);  // _
  out_char(115); // s
  out_char(110); // n
  out_char(97);  // a
  out_char(112); // p
  out_char(115); // s
  out_char(104); // h
  out_char(111); // o
  out_char(116); // t
  out_char(95);  // _
  out_char(112); // p
  out_char(114); // r
  out_char(101); // e
  out_char(118); // v
  out_char(105); // i
  out_char(101); // e
  out_char(119); // w
  out_char(49);  // 1
  out_char(34);  // "
  return 0;
}

fn out_str_fd_write() -> i32 {
  out_char(34);  // "
  out_char(102); // f
  out_char(100); // d
  out_char(95);  // _
  out_char(119); // w
  out_char(114); // r
  out_char(105); // i
  out_char(116); // t
  out_char(101); // e
  out_char(34);  // "
  return 0;
}

fn out_str_fd_read() -> i32 {
  out_char(34);  // "
  out_char(102); // f
  out_char(100); // d
  out_char(95);  // _
  out_char(114); // r
  out_char(101); // e
  out_char(97);  // a
  out_char(100); // d
  out_char(34);  // "
  return 0;
}

fn out_str_path_open() -> i32 {
  out_char(34);  // "
  out_char(112); // p
  out_char(97);  // a
  out_char(116); // t
  out_char(104); // h
  out_char(95);  // _
  out_char(111); // o
  out_char(112); // p
  out_char(101); // e
  out_char(110); // n
  out_char(34);  // "
  return 0;
}

fn out_str_fd_close() -> i32 {
  out_char(34);  // "
  out_char(102); // f
  out_char(100); // d
  out_char(95);  // _
  out_char(99);  // c
  out_char(108); // l
  out_char(111); // o
  out_char(115); // s
  out_char(101); // e
  out_char(34);  // "
  return 0;
}

fn out_hex_digit(n: i32) -> i32 {
  if (n < 10) { return out_char(48 + n); }
  return out_char(97 + (n - 10));
}

fn out_hex_byte(n: i32) -> i32 {
  out_char(92); // \
  let hi: i32 = n / 16;
  let lo: i32 = n - hi * 16;
  out_hex_digit(hi);
  out_hex_digit(lo);
  return 0;
}

// Output a decimal number
fn out_num(n: i32) -> i32 {
  if (n < 0) {
    out_char(45); // -
    return out_num_pos(0 - n);
  }
  return out_num_pos(n);
}

fn out_num_pos(n: i32) -> i32 {
  if (n < 10) {
    out_char(48 + n);
    return 0;
  }
  let d: i32 = n / 10;
  let r: i32 = n - d * 10;
  out_num_pos(d);
  out_char(48 + r);
  return 0;
}

// Output $name for a local variable index
fn out_local_name(idx: i32) -> i32 {
  out_char(36);  // $
  out_char(108); // l
  out_num(idx);
  return 0;
}

// Output $fname for a function
fn out_fn_name(fn_idx: i32) -> i32 {
  out_char(36);  // $
  out_char(102); // f
  out_num(fn_idx);
  return 0;
}

// Generate WAT for a single instruction
fn gen_wat_instr(idx: i32) -> i32 {
  let op: i32 = wat_opcode(idx);
  let arg: i32 = wat_arg(idx);

  out_indent(2);

  if (op == w_const()) {
    out_str_const();
    out_sp();
    out_num(arg);
    out_nl();
    return 0;
  }
  if (op == w_local_get()) {
    out_str_local_get();
    out_sp();
    out_local_name(arg);
    out_nl();
    return 0;
  }
  if (op == w_local_set()) {
    out_str_local_set();
    out_sp();
    out_local_name(arg);
    out_nl();
    return 0;
  }
  if (op == w_i32_load()) {
    out_str_i32_load();
    out_nl();
    return 0;
  }
  if (op == w_i32_store()) {
    out_str_i32_store();
    out_nl();
    return 0;
  }
  if (op == w_i32_load8_u()) {
    out_str_i32_load8_u();
    out_nl();
    return 0;
  }
  if (op == w_i32_store8()) {
    out_str_i32_store8();
    out_nl();
    return 0;
  }
  if (op == w_add()) {
    out_str_add();
    out_nl();
    return 0;
  }
  if (op == w_sub()) {
    out_str_sub();
    out_nl();
    return 0;
  }
  if (op == w_mul()) {
    out_str_mul();
    out_nl();
    return 0;
  }
  if (op == w_div()) {
    out_str_div();
    out_nl();
    return 0;
  }
  if (op == w_lt()) {
    out_str_lt();
    out_nl();
    return 0;
  }
  if (op == w_gt()) {
    out_str_gt();
    out_nl();
    return 0;
  }
  if (op == w_eq()) {
    out_str_eq();
    out_nl();
    return 0;
  }
  if (op == w_ne()) {
    out_str_ne();
    out_nl();
    return 0;
  }
  if (op == w_le()) {
    out_str_le();
    out_nl();
    return 0;
  }
  if (op == w_ge()) {
    out_str_ge();
    out_nl();
    return 0;
  }
  if (op == w_return()) {
    out_str_return();
    out_nl();
    return 0;
  }
  if (op == w_drop()) {
    out_str_drop();
    out_nl();
    return 0;
  }
  if (op == w_call()) {
    out_str_call();
    out_sp();
    out_fn_name(arg);
    out_nl();
    return 0;
  }
  if (op == w_block()) {
    out_str_block();
    out_nl();
    return 0;
  }
  if (op == w_loop()) {
    out_str_loop();
    out_nl();
    return 0;
  }
  if (op == w_br()) {
    out_str_br();
    out_sp();
    out_num(arg);
    out_nl();
    return 0;
  }
  if (op == w_br_if()) {
    out_str_br_if();
    out_sp();
    out_num(arg);
    out_nl();
    return 0;
  }
  if (op == w_end()) {
    out_str_end();
    out_nl();
    return 0;
  }

  return 0;
}

fn call_param_count(fn_id: i32) -> i32 {
  if (fn_id == intrin_fd_write_id()) { return 4; }
  if (fn_id == intrin_fd_read_id()) { return 4; }
  if (fn_id == intrin_path_open_id()) { return 9; }
  if (fn_id == intrin_fd_close_id()) { return 1; }
  if (fn_id >= 0) {
    if (fn_id < get_fn_count()) { return fn_params(fn_id); }
  }
  return 0;
}

fn call_result_count(fn_id: i32) -> i32 {
  if (fn_id < 0) { return 0; }
  return 1;
}

// Generate WAT for all instructions
fn gen_wat_instrs(start: i32, count: i32) -> i32 {
  let i: i32 = start;
  let n: i32 = count;
  let sp: i32 = 0;
  let bp: i32 = 0;
  let base: i32 = wat_block_stack_base();

  while (n > 0) {
    let op: i32 = wat_opcode(i);
    let arg: i32 = wat_arg(i);

    if (op == w_block()) {
      __mem_store(base + bp * 4, sp);
      bp = bp + 1;
      gen_wat_instr(i);
    } else {
      if (op == w_loop()) {
        __mem_store(base + bp * 4, sp);
        bp = bp + 1;
        gen_wat_instr(i);
      } else {
        if (op == w_end()) {
          bp = bp - 1;
          let entry: i32 = __mem_load(base + bp * 4);
          while (sp > entry) {
            out_indent(2);
            out_str_drop();
            out_nl();
            sp = sp - 1;
          }
          gen_wat_instr(i);
          sp = entry;
        } else {
          gen_wat_instr(i);

          // Update stack depth for this op
          if (op == w_const()) { sp = sp + 1; }
          if (op == w_local_get()) { sp = sp + 1; }
          if (op == w_local_set()) { sp = sp - 1; }
          if (op == w_add()) { sp = sp - 1; }
          if (op == w_sub()) { sp = sp - 1; }
          if (op == w_mul()) { sp = sp - 1; }
          if (op == w_div()) { sp = sp - 1; }
          if (op == w_lt()) { sp = sp - 1; }
          if (op == w_gt()) { sp = sp - 1; }
          if (op == w_eq()) { sp = sp - 1; }
          if (op == w_ne()) { sp = sp - 1; }
          if (op == w_le()) { sp = sp - 1; }
          if (op == w_ge()) { sp = sp - 1; }
          if (op == w_i32_store()) { sp = sp - 2; }
          if (op == w_i32_store8()) { sp = sp - 2; }
          if (op == w_br_if()) { sp = sp - 1; }
          if (op == w_drop()) { sp = sp - 1; }
          if (op == w_return()) { sp = sp - 1; }
          if (op == w_call()) {
            let params: i32 = call_param_count(arg);
            let results: i32 = call_result_count(arg);
            sp = sp - params + results;
          }
        }
      }
    }

    i = i + 1;
    n = n - 1;
  }
  return 0;
}

// Generate WAT for a function
fn gen_wat_fn(fn_idx: i32) -> i32 {
  let param_count: i32 = fn_params(fn_idx);
  let local_count: i32 = fn_locals(fn_idx);

  // (func $fname
  out_indent(1);
  out_str_func();
  out_sp();
  out_fn_name(fn_idx);

  // Parameters
  gen_wat_params(0, param_count);

  // Result
  out_sp();
  out_str_result();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_nl();

  // Local variables (excluding params)
  gen_wat_locals(param_count, local_count);

  // Generate body
  // For now, generate from the stored WAT opcodes
  gen_wat_instrs(0, get_wat_count());

  // Close function
  out_indent(1);
  out_char(41); // )
  out_nl();
  return 0;
}

fn gen_wat_params(idx: i32, count: i32) -> i32 {
  let i: i32 = idx;
  while (i < count) {
    out_sp();
    out_str_param();
    out_sp();
    out_local_name(i);
    out_sp();
    out_str_i32();
    out_char(41); // )
    i = i + 1;
  }
  return 0;
}

fn gen_wat_locals(start: i32, total: i32) -> i32 {
  let i: i32 = start;
  while (i < total) {
    out_indent(2);
    out_str_local();
    out_sp();
    out_local_name(i);
    out_sp();
    out_str_i32();
    out_char(41); // )
    out_nl();
    i = i + 1;
  }
  return 0;
}

fn gen_wat_import_fd_write(fn_id: i32) -> i32 {
  out_indent(1);
  out_str_import();
  out_sp();
  out_str_wasi_snapshot();
  out_sp();
  out_str_fd_write();
  out_sp();
  out_str_func();
  out_sp();
  out_fn_name(fn_id);

  // (param i32) x4
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )

  // (result i32)
  out_sp();
  out_str_result();
  out_sp();
  out_str_i32();
  out_char(41); // )

  out_char(41); // ) func
  out_char(41); // ) import
  out_nl();
  return 0;
}

fn gen_wat_import_fd_read(fn_id: i32) -> i32 {
  out_indent(1);
  out_str_import();
  out_sp();
  out_str_wasi_snapshot();
  out_sp();
  out_str_fd_read();
  out_sp();
  out_str_func();
  out_sp();
  out_fn_name(fn_id);

  // (param i32) x4
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )

  // (result i32)
  out_sp();
  out_str_result();
  out_sp();
  out_str_i32();
  out_char(41); // )

  out_char(41); // ) func
  out_char(41); // ) import
  out_nl();
  return 0;
}

fn gen_wat_import_path_open(fn_id: i32) -> i32 {
  out_indent(1);
  out_str_import();
  out_sp();
  out_str_wasi_snapshot();
  out_sp();
  out_str_path_open();
  out_sp();
  out_str_func();
  out_sp();
  out_fn_name(fn_id);

  // (param i32) x5
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )

  // (param i64) x2
  out_sp();
  out_str_param();
  out_sp();
  out_str_i64();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i64();
  out_char(41); // )

  // (param i32) x2
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )

  // (result i32)
  out_sp();
  out_str_result();
  out_sp();
  out_str_i32();
  out_char(41); // )

  out_char(41); // ) func
  out_char(41); // ) import
  out_nl();
  return 0;
}

fn gen_wat_import_fd_close(fn_id: i32) -> i32 {
  out_indent(1);
  out_str_import();
  out_sp();
  out_str_wasi_snapshot();
  out_sp();
  out_str_fd_close();
  out_sp();
  out_str_func();
  out_sp();
  out_fn_name(fn_id);

  // (param i32)
  out_sp();
  out_str_param();
  out_sp();
  out_str_i32();
  out_char(41); // )

  // (result i32)
  out_sp();
  out_str_result();
  out_sp();
  out_str_i32();
  out_char(41); // )

  out_char(41); // ) func
  out_char(41); // ) import
  out_nl();
  return 0;
}

fn gen_wat_imports() -> i32 {
  gen_wat_import_fd_write(intrin_fd_write_id());
  gen_wat_import_fd_read(intrin_fd_read_id());
  gen_wat_import_path_open(intrin_path_open_id());
  gen_wat_import_fd_close(intrin_fd_close_id());
  return 0;
}

fn emit_wat_data_segment(start: i32, raw_len: i32, offset: i32) -> i32 {
  out_indent(1);
  out_str_data();
  out_sp();
  out_char(40); // (
  out_str_const();
  out_sp();
  out_num(offset);
  out_char(41); // )
  out_sp();
  out_char(34); // "

  let i: i32 = 0;
  while (i < raw_len) {
    let c: i32 = char_at_dyn(start + i);
    if (c == 92) {
      if (i + 1 < raw_len) {
        let e: i32 = char_at_dyn(start + i + 1);
        if (e == 110) { out_hex_byte(10); }
        else if (e == 114) { out_hex_byte(13); }
        else if (e == 116) { out_hex_byte(9); }
        else if (e == 48) { out_hex_byte(0); }
        else if (e == 34) { out_hex_byte(34); }
        else if (e == 92) { out_hex_byte(92); }
        else { out_hex_byte(e); }
        i = i + 2;
      } else {
        out_hex_byte(92);
        i = i + 1;
      }
    } else {
      if (c >= 32) {
        if (c == 34 || c == 92) {
          out_hex_byte(c);
        } else {
          out_char(c);
        }
      } else {
        out_hex_byte(c);
      }
      i = i + 1;
    }
  }

  out_char(34); // "
  out_char(41); // )
  out_nl();
  return 0;
}

fn gen_wat_data_expr(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);
  if (kind == nk_string()) {
    return emit_wat_data_segment(ast_a(node), ast_b(node), ast_c(node));
  }
  if (kind == nk_call()) {
    let cur: i32 = ast_b(node);
    let n: i32 = ast_c(node);
    while (n > 0) {
      let arg: i32 = ast_a(cur);
      gen_wat_data_expr(arg);
      cur = ast_c(cur);
      n = n - 1;
    }
    return 0;
  }
  if (kind == nk_add() || kind == nk_sub() || kind == nk_mul() || kind == nk_div()
      || kind == nk_lt() || kind == nk_gt() || kind == nk_eq() || kind == nk_ne()
      || kind == nk_le() || kind == nk_ge() || kind == nk_and() || kind == nk_or()) {
    gen_wat_data_expr(ast_a(node));
    gen_wat_data_expr(ast_b(node));
    return 0;
  }
  return 0;
}

fn gen_wat_data_stmt(node: i32) -> i32 {
  let kind: i32 = ast_kind(node);
  if (kind == nk_let() || kind == nk_assign()) {
    return gen_wat_data_expr(ast_b(node));
  }
  if (kind == nk_return()) {
    return gen_wat_data_expr(ast_a(node));
  }
  if (kind == nk_if()) {
    gen_wat_data_expr(ast_a(node));
    gen_wat_data_block(ast_b(node));
    let else_block: i32 = ast_c(node);
    if (else_block >= 0) { gen_wat_data_block(else_block); }
    return 0;
  }
  if (kind == nk_while()) {
    gen_wat_data_expr(ast_a(node));
    return gen_wat_data_block(ast_b(node));
  }
  return gen_wat_data_expr(node);
}

fn gen_wat_data_block(block_node: i32) -> i32 {
  if (ast_kind(block_node) != nk_block()) { return 0; }
  let cur: i32 = ast_a(block_node);
  let n: i32 = ast_b(block_node);
  while (n > 0) {
    let stmt: i32 = ast_a(cur);
    gen_wat_data_stmt(stmt);
    cur = ast_c(cur);
    n = n - 1;
  }
  return 0;
}

fn gen_wat_data_segments(count: i32) -> i32 {
  let i: i32 = 0;
  while (i < count) {
    let body: i32 = get_fn_ast(i);
    gen_wat_data_block(body);
    i = i + 1;
  }
  return 0;
}

// Generate complete WAT module
fn gen_wat_module() -> i32 {
  out_init();

  // Module header
  out_str_module();
  out_nl();

  // Imports
  gen_wat_imports();

  // Memory declaration
  out_indent(1);
  out_str_memory();
  out_nl();
  out_indent(1);
  out_str_export();
  out_sp();
  out_char(34); // "
  out_char(109); // m
  out_char(101); // e
  out_char(109); // m
  out_char(111); // o
  out_char(114); // r
  out_char(121); // y
  out_char(34); // "
  out_sp();
  out_char(40); // (
  out_str_memory_kw();
  out_sp();
  out_num(0);
  out_char(41); // )
  out_char(41); // )
  out_nl();

  // Data segments (string literals)
  gen_wat_data_segments(get_fn_count());

  // Generate main function (for now, just main)
  let main_idx: i32 = find_main_fn();
  if (main_idx >= 0) {
    gen_wat_fn(main_idx);
  }

  // Close module
  out_char(41); // )
  out_nl();

  // Null terminate
  out_char(0);

  return get_out_pos();
}

// Generate complete WAT module with all functions
fn gen_wat_module_all() -> i32 {
  out_init();

  // Module header
  out_str_module();
  out_nl();

  // Imports
  gen_wat_imports();

  // Memory declaration
  out_indent(1);
  out_str_memory();
  out_nl();
  out_indent(1);
  out_str_export();
  out_sp();
  out_char(34); // "
  out_char(109); // m
  out_char(101); // e
  out_char(109); // m
  out_char(111); // o
  out_char(114); // r
  out_char(121); // y
  out_char(34); // "
  out_sp();
  out_char(40); // (
  out_str_memory_kw();
  out_sp();
  out_num(0);
  out_char(41); // )
  out_char(41); // )
  out_nl();

  // Data segments (string literals)
  gen_wat_data_segments(get_fn_count());

  // Generate all functions
  gen_wat_all_fns(0, get_fn_count());

  // Export main
  let main_idx: i32 = find_main_fn();
  if (main_idx >= 0) {
    out_indent(1);
    out_str_export();
    out_sp();
    out_char(34); // "
    out_char(109); // m
    out_char(97);  // a
    out_char(105); // i
    out_char(110); // n
    out_char(34); // "
    out_sp();
    out_str_func();
    out_sp();
    out_fn_name(main_idx);
    out_char(41); // )
    out_char(41); // )
    out_nl();
  }

  // Close module
  out_char(41); // )
  out_nl();

  // Null terminate
  out_char(0);

  return get_out_pos();
}

fn gen_wat_all_fns(idx: i32, count: i32) -> i32 {
  let i: i32 = idx;
  while (i < count) {
    // Compile this function's body
    codegen_init();
    wat_init();
    set_current_fn(i);
    set_local_count(fn_locals(i));

    let body: i32 = get_fn_ast(i);
    let ir_ok: i32 = emit_ir_block_stmts(body);
    if (ir_ok < 0) {
      if (debug_enabled() == 1) { debug_dump_codegen(ir_ok, i); }
      return ir_ok;
    }
    let wat_ok: i32 = emit_wat_from_ir_general();
    if (wat_ok < 0) {
      if (debug_enabled() == 1) { debug_dump_codegen(wat_ok, i); }
      return wat_ok;
    }
    // Generate WAT for this function
    gen_wat_fn(i);
    set_current_fn(0 - 1);

    i = i + 1;
  }
  return 0;
}

// Get output buffer content at position
fn out_get(pos: i32) -> i32 {
  return __mem_load8(out_buffer_addr() + pos);
}

// Get source buffer content at position
fn src_get(pos: i32) -> i32 {
  return __mem_load8(src_buffer_addr() + pos);
}

// Find main function (ident_id hash for "main")
fn main_ident_id() -> i32 { return 246720401; }

fn find_main_fn() -> i32 {
  return lookup_fn(main_ident_id());
}

// Test multi-function program
fn test_multi_fn() -> i32 {
  // Program with two functions:
  // fn add() -> i32 { return 42; }
  // fn main() -> i32 { return add(); }
  init_src_buffer();
  load_multi_fn_program();

  let ok: i32 = compile_program_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // Verify we have 2 functions registered
  if (get_fn_count() != 2) { clear_src_buffer(); return 0; }

  // main's IR should have: call add; ret
  if (get_ir_count() != 2) { clear_src_buffer(); return 0; }
  if (ir_opcode(0) != op_call()) { clear_src_buffer(); return 0; }
  if (ir_opcode(1) != op_ret()) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test function with parameters
fn test_fn_params() -> i32 {
  // Program: fn add(a: i32, b: i32) -> i32 { return a + b; } fn main() -> i32 { return add(3, 5); }
  init_src_buffer();
  load_params_program();

  let ok: i32 = compile_program_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // Verify we have 2 functions
  if (get_fn_count() != 2) { clear_src_buffer(); return 0; }

  // Check that add has 2 parameters
  // hash("add") = 1677817
  let add_idx: i32 = lookup_fn(1677817);
  if (add_idx < 0) { clear_src_buffer(); return 0; }
  if (fn_params(add_idx) != 2) { clear_src_buffer(); return 0; }

  // main's IR should have: const 3; const 5; call add; ret
  if (get_ir_count() < 4) { clear_src_buffer(); return 0; }
  if (ir_opcode(0) != op_const()) { clear_src_buffer(); return 0; }
  if (ir_arg(0) != 3) { clear_src_buffer(); return 0; }
  if (ir_opcode(1) != op_const()) { clear_src_buffer(); return 0; }
  if (ir_arg(1) != 5) { clear_src_buffer(); return 0; }
  if (ir_opcode(2) != op_call()) { clear_src_buffer(); return 0; }
  if (ir_opcode(3) != op_ret()) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test assignment statement
fn test_assignment() -> i32 {
  // Program: fn main() -> i32 { let x: i32 = 1; x = x + 1; return x; }
  init_src_buffer();
  load_assign_program();

  let ok: i32 = compile_program_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // main's IR should have:
  // const 1; store x; load x; const 1; add; store x; load x; ret
  if (get_ir_count() < 8) { clear_src_buffer(); return 0; }
  if (ir_opcode(0) != op_const()) { clear_src_buffer(); return 0; }
  if (ir_arg(0) != 1) { clear_src_buffer(); return 0; }
  if (ir_opcode(1) != op_store()) { clear_src_buffer(); return 0; }
  // x = x + 1: load x; const 1; add; store x
  if (ir_opcode(2) != op_load()) { clear_src_buffer(); return 0; }
  if (ir_opcode(3) != op_const()) { clear_src_buffer(); return 0; }
  if (ir_arg(3) != 1) { clear_src_buffer(); return 0; }
  if (ir_opcode(4) != op_add()) { clear_src_buffer(); return 0; }
  if (ir_opcode(5) != op_store()) { clear_src_buffer(); return 0; }
  // return x: load x; ret
  if (ir_opcode(6) != op_load()) { clear_src_buffer(); return 0; }
  if (ir_opcode(7) != op_ret()) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test comments
fn test_comments() -> i32 {
  // Program: fn main() -> i32 { // comment\n return 42; }
  init_src_buffer();
  load_comment_program();

  let ok: i32 = compile_program_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // Should have: const 42; ret
  if (get_ir_count() != 2) { clear_src_buffer(); return 0; }
  if (ir_opcode(0) != op_const()) { clear_src_buffer(); return 0; }
  if (ir_arg(0) != 42) { clear_src_buffer(); return 0; }
  if (ir_opcode(1) != op_ret()) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test WAT text generation
fn test_wat_text_gen() -> i32 {
  // Compile a simple program and generate WAT text
  // Program: fn main() -> i32 { return 42; }
  init_src_buffer();
  load_simple_return();

  let ok: i32 = compile_program_dyn();
  if (ok != 1) {
    clear_src_buffer();
    return 0;
  }

  // Generate WAT text
  let len: i32 = gen_wat_module();
  if (len < 50) { clear_src_buffer(); return 0; }

  // Verify output starts with "(module"
  if (out_get(0) != 40) { clear_src_buffer(); return 0; }  // (
  if (out_get(1) != 109) { clear_src_buffer(); return 0; } // m
  if (out_get(2) != 111) { clear_src_buffer(); return 0; } // o
  if (out_get(3) != 100) { clear_src_buffer(); return 0; } // d
  if (out_get(4) != 117) { clear_src_buffer(); return 0; } // u
  if (out_get(5) != 108) { clear_src_buffer(); return 0; } // l
  if (out_get(6) != 101) { clear_src_buffer(); return 0; } // e

  // Verify output contains "i32.const"
  let has_const: i32 = find_str_in_out(105, 51, 50, 46, 99); // i32.c
  if (has_const != 1) { clear_src_buffer(); return 0; }

  // Verify output contains "return"
  let has_ret: i32 = find_str_in_out(114, 101, 116, 117, 114); // retur
  if (has_ret != 1) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Find a 5-char sequence in output buffer
fn find_str_in_out(c0: i32, c1: i32, c2: i32, c3: i32, c4: i32) -> i32 {
  let len: i32 = get_out_pos();
  return find_str_from(c0, c1, c2, c3, c4, 0, len);
}

fn find_str_from(c0: i32, c1: i32, c2: i32, c3: i32, c4: i32, pos: i32, len: i32) -> i32 {
  if (pos + 5 > len) { return 0; }
  if (out_get(pos) == c0) {
    if (out_get(pos + 1) == c1) {
      if (out_get(pos + 2) == c2) {
        if (out_get(pos + 3) == c3) {
          if (out_get(pos + 4) == c4) {
            return 1;
          }
        }
      }
    }
  }
  return find_str_from(c0, c1, c2, c3, c4, pos + 1, len);
}

// Test multi-function WAT generation
fn test_wat_multi_fn() -> i32 {
  // Compile a two-function program and generate WAT
  // Program: fn add() -> i32 { return 42; } fn main() -> i32 { return add(); }
  init_src_buffer();
  load_multi_fn_program();

  parser_init(0);
  set_fn_count(0);
  let fn_count: i32 = parse_program_dyn();
  if (fn_count != 2) {
    clear_src_buffer();
    return 0;
  }

  // Generate WAT for all functions
  let len: i32 = gen_wat_module_all();
  if (len < 100) { clear_src_buffer(); return 0; }

  // Verify output contains two (func declarations
  // Look for "func" twice
  let func_count: i32 = count_str_in_out(102, 117, 110, 99); // func
  if (func_count < 2) { clear_src_buffer(); return 0; }

  // Verify output contains "call"
  let has_call: i32 = find_str_in_out(99, 97, 108, 108, 32); // "call "
  if (has_call != 1) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test WAT output to stdout (via out_flush)
fn test_wat_stdout() -> i32 {
  if (emit_wat_stdout_enabled() != 1) { return 1; }
  // Program: fn main() -> i32 { return 42; }
  init_src_buffer();
  load_simple_return();

  let rc: i32 = compile_program_to_stdout();
  if (rc != 1) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test WAT output to file (via path_open/fd_write)
fn test_wat_file() -> i32 {
  if (emit_wat_file_enabled() != 1) { return 1; }
  // Program: fn main() -> i32 { return 42; }
  init_src_buffer();
  load_simple_return();
  write_output_path();

  let rc: i32 = compile_program_to_file(file_path_addr(), file_path_len());
  if (rc != 1) { clear_src_buffer(); return 0; }

  let out_len: i32 = get_out_pos();
  let nread: i32 = read_file_into_src(file_path_addr(), file_path_len());
  if (nread != out_len) { clear_src_buffer(); return 0; }
  if (compare_out_with_src(out_len) != 1) { clear_src_buffer(); return 0; }

  clear_src_buffer();
  return 1;
}

// Test stdin -> stdout compile path (skips if disabled)
fn test_wat_stdin() -> i32 {
  if (compile_stdin_enabled() != 1) { return 1; }
  let rc: i32 = compile_stdin_to_stdout();
  if (rc != 1) { clear_src_buffer(); return rc; }
  clear_src_buffer();
  return 1;
}

// Count occurrences of a 4-char sequence in output
fn count_str_in_out(c0: i32, c1: i32, c2: i32, c3: i32) -> i32 {
  let len: i32 = get_out_pos();
  return count_str_from(c0, c1, c2, c3, 0, len, 0);
}

fn count_str_from(c0: i32, c1: i32, c2: i32, c3: i32, pos: i32, len: i32, count: i32) -> i32 {
  if (pos + 4 > len) { return count; }
  let found: i32 = 0;
  if (out_get(pos) == c0) {
    if (out_get(pos + 1) == c1) {
      if (out_get(pos + 2) == c2) {
        if (out_get(pos + 3) == c3) {
          found = 1;
        }
      }
    }
  }
  return count_str_from(c0, c1, c2, c3, pos + 1, len, count + found);
}

// Compare output buffer with source buffer for len bytes
fn compare_out_with_src(len: i32) -> i32 {
  let i: i32 = 0;
  while (i < len) {
    if (out_get(i) != src_get(i)) { return 0; }
    i = i + 1;
  }
  return 1;
}

// Write "out.wat" to the fixed file path buffer
fn write_output_path() -> i32 {
  let base: i32 = file_path_addr();
  __mem_store8(base + 0, 111); // o
  __mem_store8(base + 1, 117); // u
  __mem_store8(base + 2, 116); // t
  __mem_store8(base + 3, 46);  // .
  __mem_store8(base + 4, 119); // w
  __mem_store8(base + 5, 97);  // a
  __mem_store8(base + 6, 116); // t
  __mem_store8(base + 7, 0);   // null
  return 0;
}

// Load: "fn main() -> i32 { return 42; }"
fn load_simple_return() -> i32 {
  let i: i32 = 0;
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 52);  // 4
  i = store_str(i, 50);  // 2
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

// Load: "fn main() -> i32 { // comment\n return 42; }"
fn load_comment_program() -> i32 {
  let i: i32 = 0;
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  // "// comment\n"
  i = store_str(i, 47);  // /
  i = store_str(i, 47);  // /
  i = store_str(i, 32);  // space
  i = store_str(i, 99);  // c
  i = store_str(i, 111); // o
  i = store_str(i, 109); // m
  i = store_str(i, 109); // m
  i = store_str(i, 101); // e
  i = store_str(i, 110); // n
  i = store_str(i, 116); // t
  i = store_str(i, 10);  // newline
  // "return 42; }"
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 52);  // 4
  i = store_str(i, 50);  // 2
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

// Load: "fn main() -> i32 { let x: i32 = 1; x = x + 1; return x; }"
fn load_assign_program() -> i32 {
  let i: i32 = 0;
  // "fn main() -> i32 { let x: i32 = 1; x = x + 1; return x; }"
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  // "let x: i32 = 1; "
  i = store_str(i, 108); // l
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 32);  // space
  i = store_str(i, 120); // x
  i = store_str(i, 58);  // :
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 61);  // =
  i = store_str(i, 32);  // space
  i = store_str(i, 49);  // 1
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  // "x = x + 1; "
  i = store_str(i, 120); // x
  i = store_str(i, 32);  // space
  i = store_str(i, 61);  // =
  i = store_str(i, 32);  // space
  i = store_str(i, 120); // x
  i = store_str(i, 32);  // space
  i = store_str(i, 43);  // +
  i = store_str(i, 32);  // space
  i = store_str(i, 49);  // 1
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  // "return x; }"
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 120); // x
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

// Load: "fn add(a: i32, b: i32) -> i32 { return a + b; } fn main() -> i32 { return add(3, 5); }"
fn load_params_program() -> i32 {
  let i: i32 = 0;
  // "fn add(a: i32, b: i32) -> i32 { return a + b; } "
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 97);  // a
  i = store_str(i, 100); // d
  i = store_str(i, 100); // d
  i = store_str(i, 40);  // (
  i = store_str(i, 97);  // a
  i = store_str(i, 58);  // :
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 44);  // ,
  i = store_str(i, 32);  // space
  i = store_str(i, 98);  // b
  i = store_str(i, 58);  // :
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 97);  // a
  i = store_str(i, 32);  // space
  i = store_str(i, 43);  // +
  i = store_str(i, 32);  // space
  i = store_str(i, 98);  // b
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 32);  // space
  // "fn main() -> i32 { return add(3, 5); }"
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 97);  // a
  i = store_str(i, 100); // d
  i = store_str(i, 100); // d
  i = store_str(i, 40);  // (
  i = store_str(i, 51);  // 3
  i = store_str(i, 44);  // ,
  i = store_str(i, 32);  // space
  i = store_str(i, 53);  // 5
  i = store_str(i, 41);  // )
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

// Load: "fn add() -> i32 { return 42; } fn main() -> i32 { return add(); }"
fn load_multi_fn_program() -> i32 {
  let i: i32 = 0;
  // "fn add() -> i32 { return 42; } "
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 97);  // a
  i = store_str(i, 100); // d
  i = store_str(i, 100); // d
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 52);  // 4
  i = store_str(i, 50);  // 2
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 32);  // space
  // "fn main() -> i32 { return add(); }"
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 97);  // a
  i = store_str(i, 100); // d
  i = store_str(i, 100); // d
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

// Load: "fn main() -> i32 { return add(); }"
fn load_call_program() -> i32 {
  let i: i32 = 0;
  // "fn main() -> i32 { return add(); }"
  i = store_str(i, 102); // f
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 109); // m
  i = store_str(i, 97);  // a
  i = store_str(i, 105); // i
  i = store_str(i, 110); // n
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 32);  // space
  i = store_str(i, 45);  // -
  i = store_str(i, 62);  // >
  i = store_str(i, 32);  // space
  i = store_str(i, 105); // i
  i = store_str(i, 51);  // 3
  i = store_str(i, 50);  // 2
  i = store_str(i, 32);  // space
  i = store_str(i, 123); // {
  i = store_str(i, 32);  // space
  // "return add(); }"
  i = store_str(i, 114); // r
  i = store_str(i, 101); // e
  i = store_str(i, 116); // t
  i = store_str(i, 117); // u
  i = store_str(i, 114); // r
  i = store_str(i, 110); // n
  i = store_str(i, 32);  // space
  i = store_str(i, 97);  // a
  i = store_str(i, 100); // d
  i = store_str(i, 100); // d
  i = store_str(i, 40);  // (
  i = store_str(i, 41);  // )
  i = store_str(i, 59);  // ;
  i = store_str(i, 32);  // space
  i = store_str(i, 125); // }
  i = store_str(i, 0);   // null
  return 0;
}

fn alloc_wat() -> i32 {
  let idx: i32 = get_wat_count();
  set_wat_count(idx + 1);
  return idx;
}

fn wat_init() -> i32 {
  set_wat_count(0);
  return 0;
}

// Lower all IR instructions to WAT
fn emit_wat_from_ir_general() -> i32 {
  wat_init();
  let ir_count: i32 = get_ir_count();
  return emit_wat_ir_range(0, ir_count);
}

fn emit_wat_ir_range(idx: i32, count: i32) -> i32 {
  let i: i32 = idx;
  while (i < count) {
    let r: i32 = emit_wat_ir_op(i);
    if (r < 0) { return r; }
    i = i + 1;
  }
  return 1;
}

fn emit_wat_ir_op(idx: i32) -> i32 {
  let op: i32 = ir_opcode(idx);
  let arg: i32 = ir_arg(idx);

  if (op == op_const()) {
    return emit_wat_const(arg);
  }
  if (op == op_store()) {
    return emit_wat_store(arg);
  }
  if (op == op_load()) {
    return emit_wat_load(arg);
  }
  if (op == op_ret()) {
    return emit_wat_return();
  }
  if (op == op_add()) {
    return emit_wat_simple(w_add());
  }
  if (op == op_sub()) {
    return emit_wat_simple(w_sub());
  }
  if (op == op_mul()) {
    return emit_wat_simple(w_mul());
  }
  if (op == op_div()) {
    return emit_wat_simple(w_div());
  }
  if (op == op_lt()) {
    return emit_wat_simple(w_lt());
  }
  if (op == op_gt()) {
    return emit_wat_simple(w_gt());
  }
  if (op == op_eq()) {
    return emit_wat_simple(w_eq());
  }
  if (op == op_ne()) {
    return emit_wat_simple(w_ne());
  }
  if (op == op_le()) {
    return emit_wat_simple(w_le());
  }
  if (op == op_ge()) {
    return emit_wat_simple(w_ge());
  }
  if (op == op_mem_load()) {
    return emit_wat_simple(w_i32_load());
  }
  if (op == op_mem_store()) {
    return emit_wat_simple(w_i32_store());
  }
  if (op == op_mem_load8()) {
    return emit_wat_simple(w_i32_load8_u());
  }
  if (op == op_mem_store8()) {
    return emit_wat_simple(w_i32_store8());
  }
  if (op == op_block()) {
    return emit_wat_simple(w_block());
  }
  if (op == op_loop()) {
    return emit_wat_simple(w_loop());
  }
  if (op == op_end()) {
    return emit_wat_simple(w_end());
  }
  if (op == op_br()) {
    return emit_wat_br(arg);
  }
  if (op == op_br_if()) {
    return emit_wat_br_if(arg);
  }
  if (op == op_call()) {
    return emit_wat_call(arg);
  }
  if (op == op_drop()) {
    return emit_wat_simple(w_drop());
  }

  if (debug_enabled() == 1) { debug_dump_ir_bad(op, idx); }
  return 0 - 6000 - op;
}

fn emit_wat_call(fn_id: i32) -> i32 {
  let idx: i32 = alloc_wat();
  wat_set(idx, w_call(), fn_id);
  return 1;
}

fn emit_wat_const(val: i32) -> i32 {
  let idx: i32 = alloc_wat();
  wat_set(idx, w_const(), val);
  return 1;
}

fn emit_wat_store(ident_id: i32) -> i32 {
  let local_idx: i32 = map_local_general(ident_id);
  let idx: i32 = alloc_wat();
  wat_set(idx, w_local_set(), local_idx);
  return 1;
}

fn emit_wat_load(ident_id: i32) -> i32 {
  let local_idx: i32 = map_local_general(ident_id);
  let idx: i32 = alloc_wat();
  wat_set(idx, w_local_get(), local_idx);
  return 1;
}

fn emit_wat_return() -> i32 {
  let idx: i32 = alloc_wat();
  wat_set(idx, w_return(), 0);
  return 1;
}

fn emit_wat_simple(w_op: i32) -> i32 {
  let idx: i32 = alloc_wat();
  wat_set(idx, w_op, 0);
  return 1;
}

fn emit_wat_br(depth: i32) -> i32 {
  let idx: i32 = alloc_wat();
  wat_set(idx, w_br(), depth);
  return 1;
}

fn emit_wat_br_if(depth: i32) -> i32 {
  let idx: i32 = alloc_wat();
  wat_set(idx, w_br_if(), depth);
  return 1;
}

// Map identifier ID to local index using symbol table
fn map_local_general(ident_id: i32) -> i32 {
  let found: i32 = lookup_local(ident_id);
  if (found >= 0) { return found; }
  // Fallback for hardcoded idents
  if (ident_id == 120) { return 0; }
  if (ident_id == 121) { return 1; }
  return 0;
}

// ============================================================================
// Stage 1.7: Complete Pipeline - General Function Compiler
// ============================================================================

// Parse function header: fn name() -> type {
// Returns 1 on success, sets position after {
fn parse_fn_header() -> i32 {
  if (expect(tok_fn()) != 1) { return 0; }

  // Parse function name
  let tok: i32 = peek_tok();
  if (lex_kind(tok) != tok_ident()) { return 0; }
  next_tok();

  // Parse ()
  if (expect(tok_lparen()) != 1) { return 0; }
  if (expect(tok_rparen()) != 1) { return 0; }

  // Parse -> type
  if (expect(tok_arrow()) != 1) { return 0; }
  if (expect(tok_i32()) != 1) { return 0; }

  // Parse {
  if (expect(tok_lbrace()) != 1) { return 0; }

  return 1;
}

// Parse function body using general parser
// Returns block node index, or -1 on error
fn parse_fn_body_general() -> i32 {
  let first_stmt: i32 = 0 - 1;
  let last_stmt: i32 = 0 - 1;
  let count: i32 = 0;

  let done: i32 = 0;
  while (done == 0) {
    let tok: i32 = peek_tok();
    let kind: i32 = lex_kind(tok);
    if (kind == tok_rbrace()) {
      done = 1;
    } else {
      if (kind == tok_eof()) {
        done = 1;
      } else {
        let stmt: i32 = parse_stmt();
        if (stmt < 0) { return 0 - 1; }
        let link: i32 = wrap_stmt_node(stmt);

        if (first_stmt < 0) {
          first_stmt = link;
        } else {
          ast_set_c(last_stmt, link);
        }
        last_stmt = link;
        count = count + 1;
      }
    }
  }

  // Expect closing }
  if (expect(tok_rbrace()) != 1) { return 0 - 1; }

  // Create block node for the function body
  let node: i32 = alloc_ast();
  ast_set(node, nk_block(), first_stmt, count, 0);
  return node;
}

// Compile a function using the general pipeline
// Returns 1 on success
fn compile_fn_general() -> i32 {
  // Initialize all state
  parser_init(0);
  codegen_init();
  wat_init();

  // Parse function header
  let hdr: i32 = parse_fn_header();
  if (hdr != 1) { return 201; }

  // Parse function body
  let body: i32 = parse_fn_body_general();
  if (body < 0) { return 202; }

  // Emit IR from body statements
  let ir_ok: i32 = emit_ir_block_stmts(body);
  if (ir_ok < 0) { return ir_ok; }

  // Lower IR to WAT
  let wat_ok: i32 = emit_wat_from_ir_general();
  if (wat_ok != 1) { return 204; }

  return 1;
}

// Test the general compiler with hardcoded input
fn test_general_compile() -> i32 {
  // The hardcoded char_at() contains: fn main() -> i32 { let x: i32 = 1; let y: i32 = 2; return x + y; }
  let ok: i32 = compile_fn_general();
  if (ok != 1) { return ok; }

  // Verify AST was built correctly
  // Should have: let x = 1, let y = 2, return x + y
  // First find the block node (should be last allocated)
  let ast_cnt: i32 = get_ast_count();
  let body_node: i32 = ast_cnt - 1;

  if (ast_kind(body_node) != nk_block()) { return 102; }
  let first_stmt: i32 = ast_a(body_node);
  let stmt_count: i32 = ast_b(body_node);
  if (stmt_count != 3) { return 103; }

  // Verify IR was emitted
  // Expected: const 1; store x; const 2; store y; load x; load y; add; ret
  let ir_cnt: i32 = get_ir_count();
  if (ir_cnt != 8) { return 104; }

  // Verify IR sequence
  if (ir_opcode(0) != op_const()) { return 105; }
  if (ir_arg(0) != 1) { return 106; }
  if (ir_opcode(1) != op_store()) { return 107; }
  if (ir_opcode(2) != op_const()) { return 108; }
  if (ir_arg(2) != 2) { return 109; }
  if (ir_opcode(3) != op_store()) { return 110; }
  if (ir_opcode(4) != op_load()) { return 111; }
  if (ir_opcode(5) != op_load()) { return 112; }
  if (ir_opcode(6) != op_add()) { return 113; }
  if (ir_opcode(7) != op_ret()) { return 114; }

  // Verify WAT was emitted
  let wat_cnt: i32 = get_wat_count();
  if (wat_cnt != 8) { return 115; }

  // Verify WAT sequence
  if (wat_opcode(0) != w_const()) { return 116; }
  if (wat_arg(0) != 1) { return 117; }
  if (wat_opcode(1) != w_local_set()) { return 118; }
  if (wat_arg(1) != 0) { return 119; }
  if (wat_opcode(2) != w_const()) { return 120; }
  if (wat_arg(2) != 2) { return 121; }
  if (wat_opcode(3) != w_local_set()) { return 122; }
  if (wat_arg(3) != 1) { return 123; }
  if (wat_opcode(4) != w_local_get()) { return 124; }
  if (wat_arg(4) != 0) { return 125; }
  if (wat_opcode(5) != w_local_get()) { return 126; }
  if (wat_arg(5) != 1) { return 127; }
  if (wat_opcode(6) != w_add()) { return 128; }
  if (wat_opcode(7) != w_return()) { return 129; }

  return 1;
}

// Test control flow: if statement
fn test_if_codegen() -> i32 {
  // Manually build AST for: if (1 < 2) { return 1; }
  parser_init(0);
  codegen_init();

  // Build AST:
  // Node 0: int 1
  ast_set(0, nk_int(), 1, 0, 0);
  // Node 1: int 2
  ast_set(1, nk_int(), 2, 0, 0);
  // Node 2: 1 < 2
  ast_set(2, nk_lt(), 0, 1, 0);
  // Node 3: int 1 (return value)
  ast_set(3, nk_int(), 1, 0, 0);
  // Node 4: return 1
  ast_set(4, nk_return(), 3, 0, 0);
  // Node 5: stmt wrapper for return
  ast_set(5, nk_stmt(), 4, 0, 0);
  // Node 6: block containing return
  ast_set(6, nk_block(), 5, 1, 0);
  // Node 7: if (1 < 2) { return 1; }
  ast_set(7, nk_if(), 2, 6, 0 - 1);

  // Emit IR for the if statement
  let r: i32 = emit_ir_stmt(7);
  if (r < 0) { return 0; }

  // Should emit: block; const 1; const 2; lt; const 0; eq; br_if; const 1; ret; end
  let ir_cnt: i32 = get_ir_count();
  if (ir_cnt < 8) { return 0; }

  // Verify block + condition
  if (ir_opcode(0) != op_block()) { return 0; }
  if (ir_opcode(1) != op_const()) { return 0; }
  if (ir_opcode(2) != op_const()) { return 0; }
  if (ir_opcode(3) != op_lt()) { return 0; }
  if (ir_opcode(4) != op_const()) { return 0; }
  if (ir_opcode(5) != op_eq()) { return 0; }
  if (ir_opcode(6) != op_br_if()) { return 0; }

  return 1;
}

// Test while loop codegen
fn test_while_codegen() -> i32 {
  // Manually build AST for: while (x < 10) { x = x + 1; }
  parser_init(0);
  codegen_init();
  set_local_count(0);
  add_local(100); // x has ident_id 100

  // Build AST:
  // Node 0: ident x
  ast_set(0, nk_ident(), 100, 0, 0);
  // Node 1: int 10
  ast_set(1, nk_int(), 10, 0, 0);
  // Node 2: x < 10
  ast_set(2, nk_lt(), 0, 1, 0);
  // Node 3: ident x (for x + 1)
  ast_set(3, nk_ident(), 100, 0, 0);
  // Node 4: int 1
  ast_set(4, nk_int(), 1, 0, 0);
  // Node 5: x + 1
  ast_set(5, nk_add(), 3, 4, 0);
  // Node 6: let x = x + 1 (assignment)
  ast_set(6, nk_let(), 100, 5, 0);
  // Node 7: stmt wrapper for let
  ast_set(7, nk_stmt(), 6, 0, 0);
  // Node 8: block containing let
  ast_set(8, nk_block(), 7, 1, 0);
  // Node 9: while (x < 10) { let x = x + 1; }
  ast_set(9, nk_while(), 2, 8, 0);

  // Emit IR for the while statement
  let r: i32 = emit_ir_stmt(9);
  if (r < 0) { return 0; }

  // Should emit: block; loop; load x; const 10; lt; const 0; eq; br_if 1; load x; const 1; add; store x; br 0; end; end
  let ir_cnt: i32 = get_ir_count();
  if (ir_cnt < 8) { return 0; }

  // Verify loop structure
  if (ir_opcode(0) != op_block()) { return 0; }
  if (ir_opcode(1) != op_loop()) { return 0; }

  return 1;
}

// End-to-end test: parse "1 + 2 * 3" and emit IR
fn test_end_to_end() -> i32 {
  // Use test input: "1 + 2 * 3"
  let test_base: i32 = src_buffer_addr();
  __mem_store8(test_base + 0, 49);  // '1'
  __mem_store8(test_base + 1, 32);  // ' '
  __mem_store8(test_base + 2, 43);  // '+'
  __mem_store8(test_base + 3, 32);  // ' '
  __mem_store8(test_base + 4, 50);  // '2'
  __mem_store8(test_base + 5, 32);  // ' '
  __mem_store8(test_base + 6, 42);  // '*'
  __mem_store8(test_base + 7, 32);  // ' '
  __mem_store8(test_base + 8, 51);  // '3'
  __mem_store8(test_base + 9, 0);   // null

  parser_init(0);
  set_test_input_base(test_base);

  // Parse expression
  let ast_node: i32 = parse_expr_with_test_input();
  if (ast_node < 0) { return 0; }

  // Clear test mode and emit IR
  set_test_input_base(0 - 1);
  codegen_init();

  let r: i32 = emit_ir_expr(ast_node);
  if (r < 0) { return 0; }

  // Expected IR for 1 + (2 * 3):
  // const 1; const 2; const 3; mul; add
  if (get_ir_count() != 5) { return 0; }
  if (ir_opcode(0) != op_const()) { return 0; }
  if (ir_arg(0) != 1) { return 0; }
  if (ir_opcode(1) != op_const()) { return 0; }
  if (ir_arg(1) != 2) { return 0; }
  if (ir_opcode(2) != op_const()) { return 0; }
  if (ir_arg(2) != 3) { return 0; }
  if (ir_opcode(3) != op_mul()) { return 0; }
  if (ir_opcode(4) != op_add()) { return 0; }

  // Now lower IR to WAT
  let w: i32 = emit_wat_from_ir_general();
  if (w != 1) { return 0; }

  // Expected WAT: i32.const 1; i32.const 2; i32.const 3; i32.mul; i32.add
  if (get_wat_count() != 5) { return 0; }
  if (wat_opcode(0) != w_const()) { return 0; }
  if (wat_arg(0) != 1) { return 0; }
  if (wat_opcode(1) != w_const()) { return 0; }
  if (wat_arg(1) != 2) { return 0; }
  if (wat_opcode(2) != w_const()) { return 0; }
  if (wat_arg(2) != 3) { return 0; }
  if (wat_opcode(3) != w_mul()) { return 0; }
  if (wat_opcode(4) != w_add()) { return 0; }

  return 1;
}

// ============================================================================
// Stage 1.5: General Parser Infrastructure
// ============================================================================
// Parser state stored in memory at 0x600000+:
//   0x600000: parse_pos (current position in input)
//   0x600004: ast_count (next AST node index)
//   0x600008: local_count (number of locals)
//   0x600100+: symbol table (8 bytes per entry: ident_id, local_idx)

fn state_base() -> i32 { return 18874368; }
fn state_pos() -> i32 { return state_base(); }
fn state_ast() -> i32 { return state_base() + 4; }
fn state_locals() -> i32 { return state_base() + 8; }
fn state_ir_count() -> i32 { return state_base() + 16; }
fn sym_base() -> i32 { return state_base() + 256; }
fn state_str_data_pos() -> i32 { return state_base() + 84; }

// File output path storage (fixed buffer under state_base)
fn file_path_addr() -> i32 { return state_base() + 128; }
fn file_path_len() -> i32 { return 7; } // "out.wat"
fn sym_entry_size() -> i32 { return 8; }

fn get_pos() -> i32 { return __mem_load(state_pos()); }
fn set_pos(p: i32) -> i32 { __mem_store(state_pos(), p); return 0; }

fn get_ast_count() -> i32 { return __mem_load(state_ast()); }
fn set_ast_count(n: i32) -> i32 { __mem_store(state_ast(), n); return 0; }

fn get_local_count() -> i32 { return __mem_load(state_locals()); }
fn set_local_count(n: i32) -> i32 { __mem_store(state_locals(), n); return 0; }

fn get_ir_count() -> i32 { return __mem_load(state_ir_count()); }
fn set_ir_count(n: i32) -> i32 { __mem_store(state_ir_count(), n); return 0; }
fn get_str_data_pos() -> i32 { return __mem_load(state_str_data_pos()); }
fn set_str_data_pos(n: i32) -> i32 { __mem_store(state_str_data_pos(), n); return 0; }

// Allocate an IR instruction, returns the index
fn alloc_ir() -> i32 {
  let idx: i32 = get_ir_count();
  set_ir_count(idx + 1);
  return idx;
}

// Allocate an AST node, returns the index
fn alloc_ast() -> i32 {
  let idx: i32 = get_ast_count();
  set_ast_count(idx + 1);
  return idx;
}

fn wrap_stmt_node(stmt: i32) -> i32 {
  let node: i32 = alloc_ast();
  ast_set(node, nk_stmt(), stmt, 0, 0);
  return node;
}

fn wrap_arg_node(arg: i32) -> i32 {
  let node: i32 = alloc_ast();
  ast_set(node, nk_stmt(), arg, 0, 0);
  return node;
}

// Symbol table: map identifier IDs to local indices
fn sym_addr(idx: i32, field: i32) -> i32 {
  return sym_base() + idx * sym_entry_size() + field;
}

fn sym_set(idx: i32, ident: i32, local_idx: i32) -> i32 {
  __mem_store(sym_addr(idx, 0), ident);
  __mem_store(sym_addr(idx, 4), local_idx);
  return 0;
}

fn sym_ident(idx: i32) -> i32 { return __mem_load(sym_addr(idx, 0)); }
fn sym_local(idx: i32) -> i32 { return __mem_load(sym_addr(idx, 4)); }

// Look up identifier, return local index or -1 if not found
fn lookup_local(ident_id: i32) -> i32 {
  let cur_fn: i32 = get_current_fn();
  if (cur_fn >= 0) {
    let count: i32 = fn_locals(cur_fn);
    let i: i32 = 0;
    while (i < count) {
      if (fn_local_ident(cur_fn, i) == ident_id) { return i; }
      i = i + 1;
    }
    return 0 - 1;
  }

  let count2: i32 = get_local_count();
  let j: i32 = 0;
  while (j < count2) {
    if (sym_ident(j) == ident_id) { return sym_local(j); }
    j = j + 1;
  }
  return 0 - 1;
}

// Add a local variable, returns the local index
fn add_local(ident_id: i32) -> i32 {
  let idx: i32 = get_local_count();
  sym_set(idx, ident_id, idx);
  let cur_fn: i32 = get_current_fn();
  if (cur_fn >= 0) { fn_set_local_ident(cur_fn, idx, ident_id); }
  set_local_count(idx + 1);
  return idx;
}

// ============================================================================
// Stage 1.5: General-purpose parser
// ============================================================================

// Initialize parser state
fn parser_init(start_pos: i32) -> i32 {
  set_pos(start_pos);
  set_ast_count(0);
  set_local_count(0);
  set_current_fn(0 - 1);
  set_str_data_pos(0);
  return 0;
}

// Peek at current token without consuming it
fn peek_tok() -> i32 {
  let p: i32 = get_pos();
  return lex(p);
}

// Consume current token and advance position
fn next_tok() -> i32 {
  let tok: i32 = peek_tok();
  set_pos(lex_next(tok));
  return tok;
}

// Expect a specific token kind, return 1 if found (and consumed), 0 otherwise
fn expect(kind: i32) -> i32 {
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == kind) {
    next_tok();
    return 1;
  }
  return 0;
}

// ============================================================================
// Expression parsing with precedence
// ============================================================================
// Precedence levels (lowest to highest):
//   1: comparison (==, !=, <, >, <=, >=)
//   2: additive (+, -)
//   3: multiplicative (*, /)
//   4: primary (integer, identifier, parenthesized)

// Parse a primary expression: integer, identifier, or (expr)
fn parse_primary() -> i32 {
  let tok: i32 = peek_tok();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_true()) {
    return parse_bool_literal(1);
  }
  if (kind == tok_false()) {
    return parse_bool_literal(0);
  }
  if (kind == tok_int()) {
    return parse_int_literal();
  }
  if (kind == tok_string()) {
    return parse_string_literal();
  }

  if (kind == tok_ident()) {
    return parse_ident_expr();
  }

  if (kind == tok_lparen()) {
    next_tok();
    let inner: i32 = parse_expr();
    if (expect(tok_rparen()) != 1) { return 0 - 1; }
    return inner;
  }

  return 0 - 1;
}

fn parse_bool_literal(val: i32) -> i32 {
  next_tok();
  let node: i32 = alloc_ast();
  ast_set(node, nk_bool(), val, 0, 0);
  return node;
}

fn parse_string_literal() -> i32 {
  let start: i32 = skip_ws(get_pos());
  next_tok();
  let end: i32 = get_pos();
  let node: i32 = alloc_ast();
  ast_set(node, nk_string(), start + 1, end - start - 2, 0);
  return node;
}

fn parse_int_literal() -> i32 {
  let start: i32 = skip_ws(get_pos());
  next_tok();
  let val: i32 = int_value_range(start, get_pos());
  let node: i32 = alloc_ast();
  ast_set(node, nk_int(), val, 0, 0);
  return node;
}

fn parse_ident_expr() -> i32 {
  let start: i32 = skip_ws(get_pos());
  next_tok();
  let id: i32 = ident_id_range(start, get_pos());
  if (lookup_local(id) < 0) { return 0 - 432; }
  let node: i32 = alloc_ast();
  ast_set(node, nk_ident(), id, 0, 0);
  return node;
}

// Parse multiplicative: primary (* | /) primary ...
fn parse_mul() -> i32 {
  let left: i32 = parse_unary();
  if (left < 0) { return left; }
  return parse_mul_rest(left);
}

fn parse_mul_rest(left: i32) -> i32 {
  let tok: i32 = peek_tok();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_star()) {
    return parse_mul_op(left, nk_mul());
  }

  if (kind == tok_slash()) {
    return parse_mul_op(left, nk_div());
  }

  return left;
}

fn parse_mul_op(left: i32, nk: i32) -> i32 {
  next_tok();
  let right: i32 = parse_unary();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return parse_mul_rest(node);
}

fn parse_unary() -> i32 {
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == tok_bang()) {
    next_tok();
    let inner: i32 = parse_unary();
    if (inner < 0) { return inner; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_not(), inner, 0, 0);
    return node;
  }
  return parse_primary();
}

// Parse additive: mul (+ | -) mul ...
fn parse_add() -> i32 {
  let left: i32 = parse_mul();
  if (left < 0) { return left; }
  return parse_add_rest(left);
}

fn parse_add_rest(left: i32) -> i32 {
  let tok: i32 = peek_tok();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_plus()) {
    return parse_add_op(left, nk_add());
  }

  if (kind == tok_minus()) {
    return parse_add_op(left, nk_sub());
  }

  return left;
}

fn parse_add_op(left: i32, nk: i32) -> i32 {
  next_tok();
  let right: i32 = parse_mul();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return parse_add_rest(node);
}

// Parse comparison: add (== | != | < | > | <= | >=) add
fn parse_cmp() -> i32 {
  let left: i32 = parse_add();
  if (left < 0) { return left; }

  let tok: i32 = peek_tok();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_eqeq()) { return parse_cmp_op(left, nk_eq()); }
  if (kind == tok_ne()) { return parse_cmp_op(left, nk_ne()); }
  if (kind == tok_lt()) { return parse_cmp_op(left, nk_lt()); }
  if (kind == tok_gt()) { return parse_cmp_op(left, nk_gt()); }
  if (kind == tok_le()) { return parse_cmp_op(left, nk_le()); }
  if (kind == tok_ge()) { return parse_cmp_op(left, nk_ge()); }

  return left;
}

fn parse_cmp_op(left: i32, nk: i32) -> i32 {
  next_tok();
  let right: i32 = parse_add();
  if (right < 0) { return right; }
  let node: i32 = alloc_ast();
  ast_set(node, nk, left, right, 0);
  return node;
}

// Top-level expression
fn parse_expr() -> i32 {
  return parse_or();
}

fn parse_and() -> i32 {
  let left: i32 = parse_cmp();
  if (left < 0) { return left; }
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == tok_and()) {
    next_tok();
    let right: i32 = parse_cmp();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_and(), left, right, 0);
    return parse_and_rest(node);
  }
  return left;
}

fn parse_and_rest(left: i32) -> i32 {
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == tok_and()) {
    next_tok();
    let right: i32 = parse_cmp();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_and(), left, right, 0);
    return parse_and_rest(node);
  }
  return left;
}

fn parse_or() -> i32 {
  let left: i32 = parse_and();
  if (left < 0) { return left; }
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == tok_or()) {
    next_tok();
    let right: i32 = parse_and();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_or(), left, right, 0);
    return parse_or_rest(node);
  }
  return left;
}

fn parse_or_rest(left: i32) -> i32 {
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == tok_or()) {
    next_tok();
    let right: i32 = parse_and();
    if (right < 0) { return right; }
    let node: i32 = alloc_ast();
    ast_set(node, nk_or(), left, right, 0);
    return parse_or_rest(node);
  }
  return left;
}

// ============================================================================
// Statement parsing
// ============================================================================

// Parse a single statement
fn parse_stmt() -> i32 {
  let tok: i32 = peek_tok();
  let kind: i32 = lex_kind(tok);

  if (kind == tok_let()) {
    return parse_let_stmt();
  }

  if (kind == tok_return()) {
    return parse_return_stmt();
  }

  if (kind == tok_if()) {
    return parse_if_stmt();
  }

  if (kind == tok_while()) {
    return parse_while_stmt();
  }

  // Expression statement (not yet supported)
  return 0 - 1;
}

// Parse: let ident: type = expr;
fn parse_let_stmt() -> i32 {
  if (expect(tok_let()) != 1) { return 0 - 1; }

  let tok: i32 = peek_tok();
  if (lex_kind(tok) != tok_ident()) { return 0 - 1; }
  let start: i32 = skip_ws(get_pos());
  next_tok();
  let end: i32 = get_pos();
  let id: i32 = ident_id_range(start, end);

  if (expect(tok_colon()) != 1) { return 0 - 1; }
  if (expect(tok_i32()) != 1) { return 0 - 1; }
  if (expect(tok_eq()) != 1) { return 0 - 1; }

  let expr: i32 = parse_expr();
  if (expr < 0) { return expr; }

  if (expect(tok_semi()) != 1) { return 0 - 1; }

  // Register the local variable
  add_local(id);

  let node: i32 = alloc_ast();
  ast_set(node, nk_let(), id, expr, 0);
  return node;
}

// Parse: return expr;
fn parse_return_stmt() -> i32 {
  if (expect(tok_return()) != 1) { return 0 - 1; }

  let expr: i32 = parse_expr();
  if (expr < 0) { return expr; }

  if (expect(tok_semi()) != 1) { return 0 - 1; }

  let node: i32 = alloc_ast();
  ast_set(node, nk_return(), expr, 0, 0);
  return node;
}

// Parse: if (expr) { stmts } [else { stmts }]
fn parse_if_stmt() -> i32 {
  if (expect(tok_if()) != 1) { return 0 - 1; }
  if (expect(tok_lparen()) != 1) { return 0 - 1; }

  let cond: i32 = parse_expr();
  if (cond < 0) { return cond; }

  if (expect(tok_rparen()) != 1) { return 0 - 1; }
  if (expect(tok_lbrace()) != 1) { return 0 - 1; }

  let then_block: i32 = parse_block_stmts();
  if (then_block < 0) { return then_block; }

  if (expect(tok_rbrace()) != 1) { return 0 - 1; }

  let else_block: i32 = 0 - 1;
  let tok: i32 = peek_tok();
  if (lex_kind(tok) == tok_else()) {
    next_tok();
    if (expect(tok_lbrace()) != 1) { return 0 - 1; }
    else_block = parse_block_stmts();
    if (else_block < 0) { return else_block; }
    if (expect(tok_rbrace()) != 1) { return 0 - 1; }
  }

  let node: i32 = alloc_ast();
  ast_set(node, nk_if(), cond, then_block, else_block);
  return node;
}

// Parse: while (expr) { stmts }
fn parse_while_stmt() -> i32 {
  if (expect(tok_while()) != 1) { return 0 - 1; }
  if (expect(tok_lparen()) != 1) { return 0 - 1; }

  let cond: i32 = parse_expr();
  if (cond < 0) { return cond; }

  if (expect(tok_rparen()) != 1) { return 0 - 1; }
  if (expect(tok_lbrace()) != 1) { return 0 - 1; }

  let body: i32 = parse_block_stmts();
  if (body < 0) { return body; }

  if (expect(tok_rbrace()) != 1) { return 0 - 1; }

  let node: i32 = alloc_ast();
  ast_set(node, nk_while(), cond, body, 0);
  return node;
}

// Parse multiple statements until }, returns block node
// Block node: nk_block, arg_a = first_stmt_idx, arg_b = stmt_count
fn parse_block_stmts() -> i32 {
  let first_stmt: i32 = 0 - 1;
  let last_stmt: i32 = 0 - 1;
  let count: i32 = 0;

  let done2: i32 = 0;
  while (done2 == 0) {
    let tok: i32 = peek_tok();
    let kind: i32 = lex_kind(tok);
    if (kind == tok_rbrace()) {
      done2 = 1;
    } else {
      if (kind == tok_eof()) {
        done2 = 1;
      } else {
        let stmt: i32 = parse_stmt();
        if (stmt < 0) { return 0 - 1; }
        let link: i32 = wrap_stmt_node(stmt);

        if (first_stmt < 0) {
          first_stmt = link;
        } else {
          ast_set_c(last_stmt, link);
        }
        last_stmt = link;
        count = count + 1;
      }
    }
  }

  let node: i32 = alloc_ast();
  ast_set(node, nk_block(), first_stmt, count, 0);
  return node;
}

// ============================================================================
// Helper functions for general parser
// ============================================================================

// Get integer value from current position range
fn int_value_range(start: i32, end: i32) -> i32 {
  // Find end of digits
  let actual_end: i32 = find_int_end(start);
  return int_value(start, actual_end);
}

fn find_int_end(pos: i32) -> i32 {
  let c: i32 = char_at(pos);
  if (is_digit(c) == 1) {
    return find_int_end(pos + 1);
  }
  return pos;
}

// Get identifier ID from current position range
fn ident_id_range(start: i32, end: i32) -> i32 {
  // Find end of identifier
  let actual_end: i32 = find_ident_end(start);
  return ident_id_dynamic(start, actual_end);
}

fn find_ident_end(pos: i32) -> i32 {
  let c: i32 = char_at(pos);
  if (is_ident_cont(c) == 1) {
    return find_ident_end(pos + 1);
  }
  return pos;
}

// Dynamic identifier lookup - assigns IDs based on first occurrence
// ID 1 = main, then sequential for other identifiers
fn ident_id_dynamic(start: i32, end: i32) -> i32 {
  let i: i32 = start;
  let h: i32 = 0;
  while (i < end) {
    h = h * 131 + char_at(i);
    i = i + 1;
  }
  return h;
}
