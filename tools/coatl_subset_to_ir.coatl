// Coatl Subset to IR Compiler
fn src_base() -> i32 { return 1048576; }
fn src_max() -> i32 { return 1048576; }
fn out_base() -> i32 { return 2097152; }
fn out_max() -> i32 { return 1048576; }
fn tok_base() -> i32 { return 3145728; }
fn tok_max() -> i32 { return 1048576; }
fn state_base() -> i32 { return 4194304; }

fn args_base() -> i32 { return state_base(); }
fn fd_slot() -> i32 { return state_base() + 8192; }
fn iov_addr() -> i32 { return state_base() + 8200; }
fn io_n_addr() -> i32 { return state_base() + 8208; }
fn slot_input() -> i32 { return state_base() + 8216; }
fn slot_output() -> i32 { return state_base() + 8220; }
fn out_pos_addr() -> i32 { return state_base() + 8400; }
fn parse_pos_addr() -> i32 { return state_base() + 8408; }
fn parse_end_addr() -> i32 { return state_base() + 8412; }
fn tok_count_addr() -> i32 { return state_base() + 8416; }
fn tok_idx_addr() -> i32 { return state_base() + 8420; }

// Symbol table for type tracking
fn sym_table_base() -> i32 { return state_base() + 10000; }
fn sym_table_max() -> i32 { return 1024; }
fn sym_count_addr() -> i32 { return state_base() + 8424; }

// --- Tokenizer ---
fn tok_kind(idx: i32) -> i32 { return __mem_load(tok_base() + idx * 12); }
fn tok_off(idx: i32) -> i32 { return __mem_load(tok_base() + idx * 12 + 4); }
fn tok_len(idx: i32) -> i32 { return __mem_load(tok_base() + idx * 12 + 8); }

fn add_tok(kind: i32, off: i32, len: i32) -> i32 {
  let count: i32 = __mem_load(tok_count_addr());
  let addr: i32 = tok_base() + count * 12;
  __mem_store(addr, kind); __mem_store(addr + 4, off); __mem_store(addr + 8, len);
  __mem_store(tok_count_addr(), count + 1); return 0;
}

fn k_ident() -> i32 { return 1; }
fn k_num() -> i32 { return 2; }
fn k_str() -> i32 { return 3; }
fn k_sym() -> i32 { return 4; }
fn k_eof() -> i32 { return 5; }

fn is_alpha(c: i32) -> i32 {
  if (c >= 65 && c <= 90) { return 1; }
  if (c >= 97 && c <= 122) { return 1; }
  if (c == 95) { return 1; }
  return 0;
}
fn is_digit(c: i32) -> i32 { if (c >= 48 && c <= 57) { return 1; } return 0; }
fn is_alnum(c: i32) -> i32 { if (is_alpha(c) == 1 || is_digit(c) == 1) { return 1; } return 0; }

fn tokenize() -> i32 {
  __mem_store(tok_count_addr(), 0);
  let p: i32 = 0; let end: i32 = __mem_load(parse_end_addr());
  while (p < end) {
    let c: i32 = __mem_load8(src_base() + p);
    if (c <= 32) { p = p + 1; continue; }
    if (c == 47 && __mem_load8(src_base() + p + 1) == 47) { // // comment
      p = p + 2; while (p < end && __mem_load8(src_base() + p) != 10) { p = p + 1; }
      continue;
    }
    if (c == 40 || c == 41 || c == 123 || c == 125 || c == 91 || c == 93 || c == 58 || c == 44 || c == 59 || c == 43 || c == 42 || c == 47 || c == 46 || c == 33) {
      add_tok(k_sym(), p, 1); p = p + 1; continue;
    }
    if (c == 45) { // '-' or '->'
      if (__mem_load8(src_base() + p + 1) == 62) { add_tok(k_sym(), p, 2); p = p + 2; }
      else { add_tok(k_sym(), p, 1); p = p + 1; }
      continue;
    }
    if (c == 61) { // '=' or '=='
      if (__mem_load8(src_base() + p + 1) == 61) { add_tok(k_sym(), p, 2); p = p + 2; }
      else { add_tok(k_sym(), p, 1); p = p + 1; }
      continue;
    }
    if (c == 60) { // '<' or '<='
      if (__mem_load8(src_base() + p + 1) == 61) { add_tok(k_sym(), p, 2); p = p + 2; }
      else { add_tok(k_sym(), p, 1); p = p + 1; }
      continue;
    }
    if (c == 62) { // '>' or '>='
      if (__mem_load8(src_base() + p + 1) == 61) { add_tok(k_sym(), p, 2); p = p + 2; }
      else { add_tok(k_sym(), p, 1); p = p + 1; }
      continue;
    }
    if (c == 38 && __mem_load8(src_base() + p + 1) == 38) { add_tok(k_sym(), p, 2); p = p + 2; continue; }
    if (c == 124 && __mem_load8(src_base() + p + 1) == 124) { add_tok(k_sym(), p, 2); p = p + 2; continue; }
    if (c == 33 && __mem_load8(src_base() + p + 1) == 61) { add_tok(k_sym(), p, 2); p = p + 2; continue; }
    if (c == 34) {
      let start: i32 = p; p = p + 1;
      while (p < end && __mem_load8(src_base() + p) != 34) {
        if (__mem_load8(src_base() + p) == 92) { p = p + 2; } else { p = p + 1; }
      }
      p = p + 1; add_tok(k_str(), start, p - start); continue;
    }
    if (is_digit(c) == 1) {
      let start: i32 = p; while (p < end && (is_digit(__mem_load8(src_base() + p)) == 1 || __mem_load8(src_base() + p) == 46)) { p = p + 1; }
      if (__mem_load8(src_base() + p) == 105 && __mem_load8(src_base() + p + 1) == 54 && __mem_load8(src_base() + p + 2) == 52) { p = p + 3; } 
      add_tok(k_num(), start, p - start); continue;
    }
    if (is_alpha(c) == 1) {
      let start: i32 = p; while (p < end && is_alnum(__mem_load8(src_base() + p)) == 1) { p = p + 1; }
      add_tok(k_ident(), start, p - start); continue;
    }
    p = p + 1;
  }
  add_tok(k_eof(), end, 0); return 0;
}

// --- Output ---
fn out_char(c: i32) -> i32 {
  let p: i32 = __mem_load(out_pos_addr()); __mem_store8(out_base() + p, c); __mem_store(out_pos_addr(), p + 1); return 0;
}
fn out_str(ptr: i32, len: i32) -> i32 {
  let i: i32 = 0; while (i < len) { out_char(__mem_load8(ptr + i)); i = i + 1; } return 0;
}
fn out_int(val: i32) -> i32 {
  if (val < 0) { out_char(45); return out_int(0 - val); }
  if (val >= 10) { out_int(val / 10); }
  return out_char(48 + val - (val / 10) * 10);
}
fn out_sp() -> i32 { return out_char(32); }
fn out_nl() -> i32 { return out_char(10); }

// --- Parser ---
fn peek_k() -> i32 { return tok_kind(__mem_load(tok_idx_addr())); }
fn peek_tok() -> i32 { return __mem_load(tok_idx_addr()); }
fn peek_tok_kind_at(n: i32) -> i32 {
  let i: i32 = __mem_load(tok_idx_addr()) + n;
  if (i >= __mem_load(tok_count_addr())) { return k_eof(); }
  return tok_kind(i);
}
fn peek_tok_at(n: i32) -> i32 { return __mem_load(tok_idx_addr()) + n; }
fn next_tok() -> i32 { let i: i32 = __mem_load(tok_idx_addr()); __mem_store(tok_idx_addr(), i + 1); return i; }

fn tok_equals(idx: i32, s_ptr: i32, s_len: i32) -> i32 {
  if (tok_len(idx) != s_len) { return 0; }
  let i: i32 = 0; while (i < s_len) { if (__mem_load8(src_base() + tok_off(idx) + i) != __mem_load8(s_ptr + i)) { return 0; } i = i + 1; }
  return 1;
}

// Literals
fn lit_base() -> i32 { return state_base() + 16384; }
fn l_fn() -> i32 { return lit_base(); } // "fn"
fn l_let() -> i32 { return lit_base() + 4; } // "let"
fn l_ret() -> i32 { return lit_base() + 8; } // "return"
fn l_if() -> i32 { return lit_base() + 16; } // "if"
fn l_else() -> i32 { return lit_base() + 100; } // "else"
fn l_while() -> i32 { return lit_base() + 20; } // "while"
fn l_i32() -> i32 { return lit_base() + 28; } // "i32"
fn l_i64() -> i32 { return lit_base() + 32; } // "i64"
fn l_bool() -> i32 { return lit_base() + 36; } // "bool"
fn l_true() -> i32 { return lit_base() + 44; } // "true"
fn l_false() -> i32 { return lit_base() + 52; } // "false"
fn l_str_len() -> i32 { return lit_base() + 60; } // "str_len"
fn l_str_ptr() -> i32 { return lit_base() + 68; } // "str_ptr"

fn init_lits() -> i32 {
  let b: i32 = lit_base();
  __mem_store8(b, 102); __mem_store8(b+1, 110);
  __mem_store8(b+4, 108); __mem_store8(b+5, 101); __mem_store8(b+6, 116);
  __mem_store8(b+8, 114); __mem_store8(b+9, 101); __mem_store8(b+10, 116); __mem_store8(b+11, 117); __mem_store8(b+12, 114); __mem_store8(b+13, 110);
  __mem_store8(b+16, 105); __mem_store8(b+17, 102);
  __mem_store8(b+100, 101); __mem_store8(b+101, 108); __mem_store8(b+102, 115); __mem_store8(b+103, 101);
  __mem_store8(b+20, 119); __mem_store8(b+21, 104); __mem_store8(b+22, 105); __mem_store8(b+23, 108); __mem_store8(b+24, 101);
  __mem_store8(b+28, 105); __mem_store8(b+29, 51); __mem_store8(b+30, 50);
  __mem_store8(b+32, 105); __mem_store8(b+33, 54); __mem_store8(b+34, 52);
  __mem_store8(b+36, 98); __mem_store8(b+37, 111); __mem_store8(b+38, 111); __mem_store8(b+39, 108);
  __mem_store8(b+44, 116); __mem_store8(b+45, 114); __mem_store8(b+46, 117); __mem_store8(b+47, 101);
  __mem_store8(b+52, 102); __mem_store8(b+53, 97); __mem_store8(b+54, 108); __mem_store8(b+55, 115); __mem_store8(b+56, 101);
  __mem_store8(b+60, 115); __mem_store8(b+61, 116); __mem_store8(b+62, 114); __mem_store8(b+63, 95); __mem_store8(b+64, 108); __mem_store8(b+65, 101); __mem_store8(b+66, 110);
  __mem_store8(b+68, 115); __mem_store8(b+69, 116); __mem_store8(b+70, 114); __mem_store8(b+71, 95); __mem_store8(b+72, 112); __mem_store8(b+73, 116); __mem_store8(b+74, 114);
  return 0;
}

// --- Symbol Table ---
fn sym_add(tok_idx: i32, ty_tok_idx: i32) -> i32 {
  let count: i32 = __mem_load(sym_count_addr());
  let addr: i32 = sym_table_base() + count * 8;
  __mem_store(addr, tok_idx); __mem_store(addr + 4, ty_tok_idx);
  __mem_store(sym_count_addr(), count + 1); return 0;
}
fn sym_find_ty(tok_idx: i32) -> i32 {
  let count: i32 = __mem_load(sym_count_addr()); let i: i32 = count - 1;
  while (i >= 0) {
    let addr: i32 = sym_table_base() + i * 8;
    let t: i32 = __mem_load(addr);
    if (tok_len(t) == tok_len(tok_idx)) {
      if (tok_equals(t, src_base() + tok_off(tok_idx), tok_len(tok_idx)) == 1) { return __mem_load(addr + 4); }
    }
    i = i - 1;
  }
  return 0;
}

// --- Precedence Levels ---
fn ty_i32() -> i32 { return 1; }
fn ty_i64() -> i32 { return 2; }
fn ty_bool() -> i32 { return 3; }

fn get_ty_kind(ty_tok: i32) -> i32 {
  if (ty_tok == 0) { return ty_i32(); }
  if (tok_equals(ty_tok, l_i64(), 3) == 1) { return ty_i64(); }
  if (tok_equals(ty_tok, l_bool(), 4) == 1) { return ty_bool(); }
  return ty_i32();
}

fn out_ty_suffix(ty: i32) -> i32 {
  if (ty == ty_i64()) { out_str(" i64", 4); }
  return 0;
}

fn parse_expr() -> i32 { return parse_or(); }

fn parse_or() -> i32 {
  let ty: i32 = parse_and();
  while (peek_k() == k_sym() && tok_len(peek_tok()) == 2 && __mem_load8(src_base() + tok_off(peek_tok())) == 124) {
    next_tok(); out_str("          (binary or\n", 21);
    parse_and(); out_str("          )\n", 12); ty = ty_bool();
  }
  return ty;
}

fn parse_and() -> i32 {
  let ty: i32 = parse_cmp();
  while (peek_k() == k_sym() && tok_len(peek_tok()) == 2 && __mem_load8(src_base() + tok_off(peek_tok())) == 38) {
    next_tok(); out_str("          (binary and\n", 22);
    parse_cmp(); out_str("          )\n", 12); ty = ty_bool();
  }
  return ty;
}

fn parse_cmp() -> i32 {
  let l_ty: i32 = parse_add();
  let k: i32 = peek_k();
  if (k == k_sym()) {
    let t: i32 = peek_tok(); let c: i32 = __mem_load8(src_base() + tok_off(t)); let l: i32 = tok_len(t);
    if ((l == 1 && (c == 60 || c == 62)) || (l == 2 && (c == 60 || c == 62 || c == 61 || c == 33))) {
      next_tok();
      out_str("          (binary ", 18);
      if (l == 1) { if (c == 60) { out_str("lt", 2); } else { out_str("gt", 2); } }
      else { if (c == 60) { out_str("le", 2); } else { if (c == 62) { out_str("ge", 2); } else { if (c == 61) { out_str("eq", 2); } else { out_str("ne", 2); } } } }
      let r_ty: i32 = parse_add();
      let res_ty: i32 = l_ty; if (r_ty > l_ty) { res_ty = r_ty; }
      out_ty_suffix(res_ty); out_nl();
      out_str("          )\n", 12); return ty_bool();
    }
  }
  return l_ty;
}

fn parse_add() -> i32 {
  let l_ty: i32 = parse_mul();
  while (peek_k() == k_sym() && tok_len(peek_tok()) == 1 && (__mem_load8(src_base() + tok_off(peek_tok())) == 43 || __mem_load8(src_base() + tok_off(peek_tok())) == 45)) {
    let c: i32 = __mem_load8(src_base() + tok_off(next_tok()));
    out_str("          (binary ", 18); if (c == 43) { out_str("add", 3); } else { out_str("sub", 3); }
    let r_ty: i32 = parse_mul();
    let res_ty: i32 = l_ty; if (r_ty > l_ty) { res_ty = r_ty; }
    out_ty_suffix(res_ty); out_nl();
    out_str("          )\n", 12); l_ty = res_ty;
  }
  return l_ty;
}

fn parse_mul() -> i32 {
  let l_ty: i32 = parse_term();
  while (peek_k() == k_sym() && tok_len(peek_tok()) == 1 && (__mem_load8(src_base() + tok_off(peek_tok())) == 42 || __mem_load8(src_base() + tok_off(peek_tok())) == 47)) {
    let c: i32 = __mem_load8(src_base() + tok_off(next_tok()));
    out_str("          (binary ", 18); if (c == 42) { out_str("mul", 3); } else { out_str("div", 3); }
    let r_ty: i32 = parse_term();
    let res_ty: i32 = l_ty; if (r_ty > l_ty) { res_ty = r_ty; }
    out_ty_suffix(res_ty); out_nl();
    out_str("          )\n", 12); l_ty = res_ty;
  }
  return l_ty;
}

fn parse_term() -> i32 {
  let t: i32 = peek_tok();
  if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(t)) == 33) { // !
    next_tok(); out_str("          (binary eq\n", 21);
    let ty: i32 = parse_term();
    out_str("          (int 0)\n", 18);
    out_str("          )\n", 12); return ty_bool();
  }
  if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(t)) == 40) { // (
    next_tok(); let ty: i32 = parse_expr(); next_tok(); // )
    return ty;
  }
  next_tok();
  if (tok_kind(t) == k_num()) {
    let l: i32 = tok_len(t); let o: i32 = tok_off(t);
    if (l > 3 && __mem_load8(src_base() + o + l - 3) == 105 && __mem_load8(src_base() + o + l - 2) == 54 && __mem_load8(src_base() + o + l - 1) == 52) {
      out_str("          (int_i64 ", 19); out_str(src_base() + o, l - 3); out_str(")\n", 3); return ty_i64();
    }
    out_str("          (int ", 15); out_str(src_base() + o, l); out_str(")\n", 3); return ty_i32();
  }
  if (tok_kind(t) == k_str()) {
    out_str("          (string ", 18); out_str(src_base() + tok_off(t), tok_len(t)); out_str(")\n", 3); return ty_i32();
  }
  if (tok_kind(t) == k_ident()) {
    if (tok_equals(t, l_true(), 4) == 1) { out_str("          (bool 1)\n", 19); return ty_bool(); }
    if (tok_equals(t, l_false(), 5) == 1) { out_str("          (bool 0)\n", 19); return ty_bool(); }
    if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 40) { // call
      next_tok();
      if (tok_equals(t, l_str_len(), 7) == 1) {
        out_str("          (str_len\n", 19); parse_expr(); next_tok(); out_str("          )\n", 12); return ty_i32();
      }
      if (tok_equals(t, l_str_ptr(), 7) == 1) {
        out_str("          (str_ptr\n", 19); parse_expr(); next_tok(); out_str("          )\n", 12); return ty_i32();
      }
      out_str("          (call ", 16); out_str(src_base() + tok_off(t), tok_len(t)); out_nl();
      while (peek_k() != k_sym() || __mem_load8(src_base() + tok_off(peek_tok())) != 41) {
        parse_expr(); if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 44) { next_tok(); }
      }
      next_tok(); out_str("          )\n", 12); return ty_i32();
    }
    out_str("          (ident ", 17); out_str(src_base() + tok_off(t), tok_len(t)); out_str(")\n", 3);
    return get_ty_kind(sym_find_ty(t));
  }
  return ty_i32();
}

// --- Program Structure ---
fn parse_program() -> i32 {
  out_str("(coatl_ir v1\n  (structs)\n  (functions\n", 33);
  while (peek_k() != k_eof()) {
    if (tok_equals(peek_tok(), l_fn(), 2) == 1) { parse_fn(); }
    else { next_tok(); }
  }
  out_str("  )\n)\n", 6); return 0;
}

fn parse_fn() -> i32 {
  next_tok(); let name: i32 = next_tok(); __mem_store(sym_count_addr(), 0);
  out_str("    (fn ", 8); out_str(src_base() + tok_off(name), tok_len(name)); out_nl();
  next_tok(); out_str("      (params", 13);
  while (peek_k() != k_sym() || __mem_load8(src_base() + tok_off(peek_tok())) != 41) {
    let pn: i32 = next_tok(); next_tok(); let pt: i32 = next_tok(); sym_add(pn, pt);
    out_nl(); out_str("        (param ", 15); out_str(src_base() + tok_off(pn), tok_len(pn)); out_sp(); out_str(src_base() + tok_off(pt), tok_len(pt)); out_char(41);
    if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 44) { next_tok(); }
  }
  next_tok(); out_nl(); out_str("      )\n", 8); next_tok(); let rt: i32 = next_tok();
  out_str("      (ret ", 11); out_str(src_base() + tok_off(rt), tok_len(rt)); out_str(")\n", 3);
  next_tok(); out_str("      (block\n", 13);
  parse_block_stmts();
  next_tok(); out_str("      )\n    )\n", 11); return 0;
}

fn parse_block_stmts() -> i32 {
  while (peek_k() != k_sym() || __mem_load8(src_base() + tok_off(peek_tok())) != 125) {
    parse_stmt();
  }
  return 0;
}

fn parse_stmt() -> i32 {
  let t: i32 = peek_tok();
  if (tok_equals(t, l_let(), 3) == 1) {
    next_tok(); let n: i32 = next_tok(); next_tok(); let ty: i32 = next_tok(); next_tok();
    sym_add(n, ty);
    out_str("        (let ", 13); out_str(src_base() + tok_off(n), tok_len(n)); out_sp(); out_str(src_base() + tok_off(ty), tok_len(ty)); out_nl();
    parse_expr(); out_str("        )\n", 10); if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 59) { next_tok(); }
  } else { if (tok_equals(t, l_ret(), 6) == 1) {
    next_tok(); out_str("        (return\n", 16); parse_expr(); out_str("        )\n", 10); if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 59) { next_tok(); }
  } else { if (tok_equals(t, l_if(), 2) == 1) {
    next_tok(); next_tok(); out_str("        (if\n", 12); parse_expr(); next_tok();
    next_tok(); out_str("          (block\n", 17);
    parse_block_stmts();
    next_tok(); out_str("          )\n", 12);
    if (tok_equals(peek_tok(), l_else(), 4) == 1) {
      next_tok(); next_tok(); out_str("          (else\n", 16); out_str("            (block\n", 19);
      parse_block_stmts();
      next_tok(); out_str("            )\n", 14); out_str("          )\n", 12);
    }
    out_str("        )\n", 10);
  } else { if (tok_equals(t, l_while(), 5) == 1) {
    next_tok(); next_tok(); out_str("        (while\n", 15); parse_expr(); next_tok();
    next_tok(); out_str("          (block\n", 17);
    parse_block_stmts();
    next_tok(); out_str("          )\n        )\n", 12);
  } else {
    if (tok_kind(t) == k_ident() && peek_tok_kind_at(1) == k_sym() && __mem_load8(src_base() + tok_off(peek_tok_at(1))) == 61) {
      next_tok(); next_tok(); out_str("        (assign ", 16); out_str(src_base() + tok_off(t), tok_len(t)); out_nl();
      parse_expr(); out_str("        )\n", 10); if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 59) { next_tok(); }
    } else {
      out_str("        (expr\n", 14); parse_expr(); out_str("        )\n", 10);
      if (peek_k() == k_sym() && __mem_load8(src_base() + tok_off(peek_tok())) == 59) { next_tok(); }
    }
  } } } }
  return 0;
}

fn parse_args() -> i32 {
  let total: i32 = 0; let done: i32 = 0;
  while (done == 0) {
    if (total >= 4095) { done = 1; }
    else {
      __mem_store(iov_addr(), args_base() + total); __mem_store(iov_addr() + 4, 4095 - total); __mem_store(io_n_addr(), 0);
      if (__fd_read(0, iov_addr(), 1, io_n_addr()) != 0) { return 0 - 1; }
      let nread: i32 = __mem_load(io_n_addr()); if (nread <= 0) { done = 1; } else { total = total + nread; }
    }
  }
  __mem_store8(args_base() + total, 0); let p: i32 = args_base(); let end: i32 = args_base() + total;
  while (p < end && __mem_load8(p) <= 32) { p = p + 1; } if (p >= end) { return 0 - 11; }
  let in_ptr: i32 = p; while (p < end && __mem_load8(p) > 32) { p = p + 1; } if (p < end) { __mem_store8(p, 0); p = p + 1; }
  while (p < end && __mem_load8(p) <= 32) { p = p + 1; } if (p >= end) { return 0 - 12; }
  if (__mem_load8(p) != 45 || __mem_load8(p + 1) != 111) { return 0 - 13; } p = p + 2;
  while (p < end && __mem_load8(p) <= 32) { p = p + 1; } if (p >= end) { return 0 - 14; }
  let out_ptr: i32 = p; while (p < end && __mem_load8(p) > 32) { p = p + 1; } if (p < end) { __mem_store8(p, 0); }
  __mem_store(slot_input(), in_ptr); __mem_store(slot_output(), out_ptr); return 0;
}

fn read_file_into_buf(path_ptr: i32) -> i32 {
  let path_len: i32 = 0; while (__mem_load8(path_ptr + path_len) != 0) { path_len = path_len + 1; }
  __mem_store(fd_slot(), 0); if (__path_open(3, 0, path_ptr, path_len, 0, 1, 0, 0, fd_slot()) != 0) { return 0 - 20; }
  let fd: i32 = __mem_load(fd_slot()); let total: i32 = 0; let done: i32 = 0;
  while (done == 0) {
    if (total >= src_max()) { __fd_close(fd); return 0 - 21; }
    __mem_store(iov_addr(), src_base() + total); __mem_store(iov_addr() + 4, src_max() - total); __mem_store(io_n_addr(), 0);
    if (__fd_read(fd, iov_addr(), 1, io_n_addr()) != 0) { __fd_close(fd); return 0 - 22; }
    let nread: i32 = __mem_load(io_n_addr()); if (nread <= 0) { done = 1; } else { total = total + nread; }
  }
  __fd_close(fd); return total;
}

fn write_output(path_ptr: i32, out_sz: i32) -> i32 {
  let path_len: i32 = 0; while (__mem_load8(path_ptr + path_len) != 0) { path_len = path_len + 1; }
  __mem_store(fd_slot(), 0); if (__path_open(3, 0, path_ptr, path_len, 9, 64, 0, 0, fd_slot()) != 0) { return 0 - 30; }
  let fd: i32 = __mem_load(fd_slot()); let written: i32 = 0;
  while (written < out_sz) {
    let chunk: i32 = out_sz - written; if (chunk > 4096) { chunk = 4096; }
    __mem_store(iov_addr(), out_base() + written); __mem_store(iov_addr() + 4, chunk); __mem_store(io_n_addr(), 0);
    if (__fd_write(fd, iov_addr(), 1, io_n_addr()) != 0) { __fd_close(fd); return 0 - 31; }
    let nwrite: i32 = __mem_load(io_n_addr()); if (nwrite <= 0) { __fd_close(fd); return 0 - 32; }
    written = written + nwrite;
  }
  __fd_close(fd); return 0;
}

fn main() -> i32 {
  if (parse_args() != 0) { return 1; }
  let i_len: i32 = read_file_into_buf(__mem_load(slot_input())); if (i_len < 0) { return 2; }
  __mem_store(parse_end_addr(), i_len); init_lits(); tokenize();
  __mem_store(tok_idx_addr(), 0); __mem_store(out_pos_addr(), 0);
  parse_program();
  if (write_output(__mem_load(slot_output()), __mem_load(out_pos_addr())) != 0) { return 4; }
  return 0;
}