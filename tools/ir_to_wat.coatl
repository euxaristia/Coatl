fn state_base() -> i32 { return 1048576; }
fn args_base() -> i32 { return state_base() + 0; }
fn args_size() -> i32 { return 4096; }
fn fd_slot() -> i32 { return state_base() + 8192; }
fn iov_addr() -> i32 { return state_base() + 8200; }
fn io_n_addr() -> i32 { return state_base() + 8208; }
fn slot_input() -> i32 { return state_base() + 8216; }
fn slot_output() -> i32 { return state_base() + 8220; }
fn ir_buf_base() -> i32 { return 2097152; }
fn ir_buf_max() -> i32 { return 3145728 - ir_buf_base(); }
fn out_buf_base() -> i32 { return 3145728; }
fn out_buf_max() -> i32 { return 4194304 - out_buf_base(); }

fn args_end() -> i32 { return args_base() + args_size(); }

fn parse_args() -> i32 {
  let total: i32 = 0;
  let done: i32 = 0;
  let max_len: i32 = args_size() - 1;

  while (done == 0) {
    if (total >= max_len) { done = 1; }
    else {
      let remain: i32 = max_len - total;
      __mem_store(iov_addr(), args_base() + total);
      __mem_store(iov_addr() + 4, remain);
      __mem_store(io_n_addr(), 0);
      let rc: i32 = __fd_read(0, iov_addr(), 1, io_n_addr());
      if (rc != 0) { return 0 - 1; }
      let nread: i32 = __mem_load(io_n_addr());
      if (nread <= 0) { done = 1; }
      else { total = total + nread; }
    }
  }
  __mem_store8(args_base() + total, 0);

  let p: i32 = args_base();
  while (p < args_end() && __mem_load8(p) <= 32) { p = p + 1; }
  if (p >= args_end()) { return 0 - 11; }
  let in_ptr: i32 = p;
  while (p < args_end() && __mem_load8(p) > 32) { p = p + 1; }
  if (p < args_end()) { __mem_store8(p, 0); p = p + 1; }

  while (p < args_end() && __mem_load8(p) <= 32) { p = p + 1; }
  if (p >= args_end()) { return 0 - 12; }
  if (__mem_load8(p) != 45 || __mem_load8(p + 1) != 111) { return 0 - 13; }
  p = p + 2;
  while (p < args_end() && __mem_load8(p) <= 32) { p = p + 1; }
  if (p >= args_end()) { return 0 - 14; }
  let out_ptr: i32 = p;
  while (p < args_end() && __mem_load8(p) > 32) { p = p + 1; }
  if (p < args_end()) { __mem_store8(p, 0); }

  __mem_store(slot_input(), in_ptr);
  __mem_store(slot_output(), out_ptr);
  return 0;
}

fn read_file_into_buf(path_ptr: i32, path_len: i32) -> i32 {
  // WASI path_open requires relative paths - strip leading / if present
  let p: i32 = path_ptr; let plen: i32 = path_len;
  if (plen > 0 && __mem_load8(p) == 47) { p = p + 1; plen = plen - 1; }
  __mem_store(fd_slot(), 0);
  let rc_open: i32 = __path_open(3, 0, p, plen, 0, 1, 0, 0, fd_slot());
  if (rc_open != 0) { return 0 - 20; }
  let fd: i32 = __mem_load(fd_slot());
  let total: i32 = 0;
  let done: i32 = 0;
  let max_len: i32 = ir_buf_max();
  while (done == 0) {
    if (total >= max_len) {
      __fd_close(fd);
      return 0 - 21;
    }
    let remain: i32 = max_len - total;
    __mem_store(iov_addr(), ir_buf_base() + total);
    __mem_store(iov_addr() + 4, remain);
    __mem_store(io_n_addr(), 0);
    let rc: i32 = __fd_read(fd, iov_addr(), 1, io_n_addr());
    if (rc != 0) {
      __fd_close(fd);
      return 0 - 22;
    }
    let nread: i32 = __mem_load(io_n_addr());
    if (nread <= 0) { done = 1; }
    else { total = total + nread; }
  }
  let rc_close: i32 = __fd_close(fd);
  if (rc_close != 0) { return 0 - 23; }
  return total;
}

fn write_output(path_ptr: i32, path_len: i32, out_sz: i32) -> i32 {
  // WASI path_open requires relative paths - strip leading / if present
  let p: i32 = path_ptr; let plen: i32 = path_len;
  if (plen > 0 && __mem_load8(p) == 47) { p = p + 1; plen = plen - 1; }
  __mem_store(fd_slot(), 0);
  let rc_open: i32 = __path_open(3, 0, p, plen, 9, 64, 0, 0, fd_slot());
  if (rc_open != 0) { return 0 - 30; }
  let fd: i32 = __mem_load(fd_slot());
  let written: i32 = 0;
  while (written < out_sz) {
    let chunk: i32 = out_sz - written;
    if (chunk > 4096) { chunk = 4096; }
    __mem_store(iov_addr(), out_buf_base() + written);
    __mem_store(iov_addr() + 4, chunk);
    __mem_store(io_n_addr(), 0);
    let rc: i32 = __fd_write(fd, iov_addr(), 1, io_n_addr());
    if (rc != 0) {
      __fd_close(fd);
      return 0 - 31;
    }
    let nwrite: i32 = __mem_load(io_n_addr());
    if (nwrite <= 0) {
      __fd_close(fd);
      return 0 - 32;
    }
    written = written + nwrite;
  }
  let rc_close: i32 = __fd_close(fd);
  if (rc_close != 0) { return 0 - 33; }
  return 0;
}

// ---------------------------------------------------------------------------
// Output buffer helpers
// ---------------------------------------------------------------------------

fn out_pos_addr() -> i32 { return state_base() + 8400; }

fn out_len() -> i32 { return __mem_load(out_pos_addr()); }
fn out_reset() -> i32 { __mem_store(out_pos_addr(), 0); return 0; }

fn out_char(c: i32) -> i32 {
  let pos: i32 = out_len();
  if (pos >= out_buf_max()) { return 0 - 1; }
  __mem_store8(out_buf_base() + pos, c);
  __mem_store(out_pos_addr(), pos + 1);
  return 0;
}

fn out_str(ptr: i32, len: i32) -> i32 {
  let i: i32 = 0;
  while (i < len) {
    let rc: i32 = out_char(__mem_load8(ptr + i));
    if (rc != 0) { return rc; }
    i = i + 1;
  }
  return 0;
}

fn out_nl() -> i32 { return out_char(10); }

fn out_spaces(n: i32) -> i32 {
  let i: i32 = 0;
  while (i < n) {
    let rc: i32 = out_char(32);
    if (rc != 0) { return rc; }
    i = i + 1;
  }
  return 0;
}

fn out_int(val: i32) -> i32 {
  if (val < 0) {
    out_char(45);
    return out_int(0 - val);
  }
  if (val >= 10) {
    let rc: i32 = out_int(val / 10);
    if (rc != 0) { return rc; }
  }
  return out_char(48 + val - (val / 10) * 10);
}

fn out_atom(idx: i32) -> i32 {
  let off: i32 = node_atom_off(idx);
  let len: i32 = node_atom_len(idx);
  return out_str(ir_buf_base() + off, len);
}

// ---------------------------------------------------------------------------
// WAT snippet literals (stored at literals_base() + 512)
// ---------------------------------------------------------------------------

fn wat_lit_base() -> i32 { return literals_base() + 512; }
fn wat_lit_inited_addr() -> i32 { return state_base() + 8404; }

fn store_wat_str(off: i32, s_ptr: i32, s_len: i32) -> i32 {
  let i: i32 = 0;
  while (i < s_len) {
    __mem_store8(wat_lit_base() + off + i, __mem_load8(s_ptr + i));
    i = i + 1;
  }
  return 0;
}

// WAT literal offsets and lengths - each snippet at a fixed offset
// We store them byte-by-byte in init_wat_literals

fn wl_module_ptr() -> i32 { return wat_lit_base() + 0; }
fn wl_module_len() -> i32 { return 7; }
fn wl_paren_close_ptr() -> i32 { return wat_lit_base() + 7; }
fn wl_paren_close_len() -> i32 { return 1; }
fn wl_import_wasi_ptr() -> i32 { return wat_lit_base() + 8; }
fn wl_import_wasi_len() -> i32 { return 37; }
fn wl_fd_write_name_ptr() -> i32 { return wat_lit_base() + 48; }
fn wl_fd_write_name_len() -> i32 { return 10; }
fn wl_fd_read_name_ptr() -> i32 { return wat_lit_base() + 58; }
fn wl_fd_read_name_len() -> i32 { return 9; }
fn wl_fd_close_name_ptr() -> i32 { return wat_lit_base() + 67; }
fn wl_fd_close_name_len() -> i32 { return 10; }
fn wl_path_open_name_ptr() -> i32 { return wat_lit_base() + 77; }
fn wl_path_open_name_len() -> i32 { return 11; }
fn wl_func_dollar_ptr() -> i32 { return wat_lit_base() + 96; }
fn wl_func_dollar_len() -> i32 { return 7; }
fn wl_param_i32_ptr() -> i32 { return wat_lit_base() + 103; }
fn wl_param_i32_len() -> i32 { return 10; }
fn wl_result_i32_ptr() -> i32 { return wat_lit_base() + 113; }
fn wl_result_i32_len() -> i32 { return 12; }
fn wl_local_i32_ptr() -> i32 { return wat_lit_base() + 128; }
fn wl_local_i32_len() -> i32 { return 10; }
fn wl_local_get_ptr() -> i32 { return wat_lit_base() + 144; }
fn wl_local_get_len() -> i32 { return 10; }
fn wl_local_set_ptr() -> i32 { return wat_lit_base() + 160; }
fn wl_local_set_len() -> i32 { return 10; }
fn wl_i32_const_ptr() -> i32 { return wat_lit_base() + 176; }
fn wl_i32_const_len() -> i32 { return 10; }
fn wl_i32_add_ptr() -> i32 { return wat_lit_base() + 192; }
fn wl_i32_add_len() -> i32 { return 7; }
fn wl_i32_sub_ptr() -> i32 { return wat_lit_base() + 200; }
fn wl_i32_sub_len() -> i32 { return 7; }
fn wl_i32_mul_ptr() -> i32 { return wat_lit_base() + 208; }
fn wl_i32_mul_len() -> i32 { return 7; }
fn wl_i32_div_s_ptr() -> i32 { return wat_lit_base() + 216; }
fn wl_i32_div_s_len() -> i32 { return 9; }
fn wl_i32_eq_ptr() -> i32 { return wat_lit_base() + 228; }
fn wl_i32_eq_len() -> i32 { return 6; }
fn wl_i32_ne_ptr() -> i32 { return wat_lit_base() + 234; }
fn wl_i32_ne_len() -> i32 { return 6; }
fn wl_i32_lt_s_ptr() -> i32 { return wat_lit_base() + 240; }
fn wl_i32_lt_s_len() -> i32 { return 8; }
fn wl_i32_gt_s_ptr() -> i32 { return wat_lit_base() + 248; }
fn wl_i32_gt_s_len() -> i32 { return 8; }
fn wl_i32_le_s_ptr() -> i32 { return wat_lit_base() + 256; }
fn wl_i32_le_s_len() -> i32 { return 8; }
fn wl_i32_ge_s_ptr() -> i32 { return wat_lit_base() + 264; }
fn wl_i32_ge_s_len() -> i32 { return 8; }
fn wl_i32_and_ptr() -> i32 { return wat_lit_base() + 272; }
fn wl_i32_and_len() -> i32 { return 7; }
fn wl_i32_or_ptr() -> i32 { return wat_lit_base() + 280; }
fn wl_i32_or_len() -> i32 { return 6; }
fn wl_i32_eqz_ptr() -> i32 { return wat_lit_base() + 288; }
fn wl_i32_eqz_len() -> i32 { return 7; }
fn wl_i32_store_ptr() -> i32 { return wat_lit_base() + 296; }
fn wl_i32_store_len() -> i32 { return 9; }
fn wl_i32_store8_ptr() -> i32 { return wat_lit_base() + 308; }
fn wl_i32_store8_len() -> i32 { return 10; }
fn wl_i32_load_ptr() -> i32 { return wat_lit_base() + 320; }
fn wl_i32_load_len() -> i32 { return 8; }
fn wl_i32_load8_u_ptr() -> i32 { return wat_lit_base() + 328; }
fn wl_i32_load8_u_len() -> i32 { return 10; }
fn wl_call_dollar_ptr() -> i32 { return wat_lit_base() + 344; }
fn wl_call_dollar_len() -> i32 { return 6; }
fn wl_return_ptr() -> i32 { return wat_lit_base() + 352; }
fn wl_return_len() -> i32 { return 6; }
fn wl_drop_ptr() -> i32 { return wat_lit_base() + 360; }
fn wl_drop_len() -> i32 { return 4; }
fn wl_if_ptr() -> i32 { return wat_lit_base() + 368; }
fn wl_if_len() -> i32 { return 2; }
fn wl_else_ptr() -> i32 { return wat_lit_base() + 376; }
fn wl_else_len() -> i32 { return 4; }
fn wl_end_ptr() -> i32 { return wat_lit_base() + 384; }
fn wl_end_len() -> i32 { return 3; }
fn wl_block_ptr() -> i32 { return wat_lit_base() + 392; }
fn wl_block_len() -> i32 { return 5; }
fn wl_loop_ptr() -> i32 { return wat_lit_base() + 400; }
fn wl_loop_len() -> i32 { return 4; }
fn wl_br_if_1_ptr() -> i32 { return wat_lit_base() + 408; }
fn wl_br_if_1_len() -> i32 { return 6; }
fn wl_br_0_ptr() -> i32 { return wat_lit_base() + 416; }
fn wl_br_0_len() -> i32 { return 4; }
fn wl_memory_export_ptr() -> i32 { return wat_lit_base() + 424; }
fn wl_memory_export_len() -> i32 { return 30; }
fn wl_data_prefix_ptr() -> i32 { return wat_lit_base() + 464; }
fn wl_data_prefix_len() -> i32 { return 16; }
fn wl_export_start_ptr() -> i32 { return wat_lit_base() + 480; }
fn wl_export_start_len() -> i32 { return 34; }
fn wl_fd_write_import_ptr() -> i32 { return wat_lit_base() + 528; }
fn wl_fd_write_import_len() -> i32 { return 93; }
fn wl_fd_read_import_ptr() -> i32 { return wat_lit_base() + 624; }
fn wl_fd_read_import_len() -> i32 { return 91; }
fn wl_fd_close_import_ptr() -> i32 { return wat_lit_base() + 720; }
fn wl_fd_close_import_len() -> i32 { return 75; }
fn wl_path_open_import_ptr() -> i32 { return wat_lit_base() + 800; }
fn wl_path_open_import_len() -> i32 { return 104; }
fn wl_i64_extend_ptr() -> i32 { return wat_lit_base() + 912; }
fn wl_i64_extend_len() -> i32 { return 16; }
fn wl_param_i32_sp_ptr() -> i32 { return wat_lit_base() + 928; }
fn wl_param_i32_sp_len() -> i32 { return 11; }
fn wl_unary_ptr() -> i32 { return wat_lit_base() + 944; }
fn wl_unary_len() -> i32 { return 5; }
fn wl_true_ptr() -> i32 { return wat_lit_base() + 952; }
fn wl_true_len() -> i32 { return 4; }
fn wl_false_ptr() -> i32 { return wat_lit_base() + 960; }
fn wl_false_len() -> i32 { return 5; }

// i64 WAT literals at offset 1040+
fn wl_i64_const_ptr() -> i32 { return wat_lit_base() + 1040; }
fn wl_i64_const_len() -> i32 { return 10; }
fn wl_i64_add_ptr() -> i32 { return wat_lit_base() + 1056; }
fn wl_i64_add_len() -> i32 { return 7; }
fn wl_i64_sub_ptr() -> i32 { return wat_lit_base() + 1064; }
fn wl_i64_sub_len() -> i32 { return 7; }
fn wl_i64_mul_ptr() -> i32 { return wat_lit_base() + 1072; }
fn wl_i64_mul_len() -> i32 { return 7; }
fn wl_i64_div_s_ptr() -> i32 { return wat_lit_base() + 1080; }
fn wl_i64_div_s_len() -> i32 { return 9; }
fn wl_i64_eq_ptr() -> i32 { return wat_lit_base() + 1092; }
fn wl_i64_eq_len() -> i32 { return 6; }
fn wl_i64_ne_ptr() -> i32 { return wat_lit_base() + 1100; }
fn wl_i64_ne_len() -> i32 { return 6; }
fn wl_i64_lt_s_ptr() -> i32 { return wat_lit_base() + 1108; }
fn wl_i64_lt_s_len() -> i32 { return 8; }
fn wl_i64_gt_s_ptr() -> i32 { return wat_lit_base() + 1116; }
fn wl_i64_gt_s_len() -> i32 { return 8; }
fn wl_i64_le_s_ptr() -> i32 { return wat_lit_base() + 1124; }
fn wl_i64_le_s_len() -> i32 { return 8; }
fn wl_i64_ge_s_ptr() -> i32 { return wat_lit_base() + 1132; }
fn wl_i64_ge_s_len() -> i32 { return 8; }
// Type name strings for emit
fn wl_param_i64_ptr() -> i32 { return wat_lit_base() + 1140; }
fn wl_param_i64_len() -> i32 { return 10; }
fn wl_result_i64_ptr() -> i32 { return wat_lit_base() + 1152; }
fn wl_result_i64_len() -> i32 { return 12; }
fn wl_local_i64_ptr() -> i32 { return wat_lit_base() + 1168; }
fn wl_local_i64_len() -> i32 { return 10; }
// f32 WAT literals
fn wl_f32_const_ptr() -> i32 { return wat_lit_base() + 1184; }
fn wl_f32_const_len() -> i32 { return 10; }
fn wl_f32_add_ptr() -> i32 { return wat_lit_base() + 1200; }
fn wl_f32_add_len() -> i32 { return 7; }
fn wl_f32_sub_ptr() -> i32 { return wat_lit_base() + 1208; }
fn wl_f32_sub_len() -> i32 { return 7; }
fn wl_f32_mul_ptr() -> i32 { return wat_lit_base() + 1216; }
fn wl_f32_mul_len() -> i32 { return 7; }
fn wl_f32_div_ptr() -> i32 { return wat_lit_base() + 1224; }
fn wl_f32_div_len() -> i32 { return 7; }
fn wl_f32_eq_ptr() -> i32 { return wat_lit_base() + 1232; }
fn wl_f32_eq_len() -> i32 { return 6; }
fn wl_f32_ne_ptr() -> i32 { return wat_lit_base() + 1240; }
fn wl_f32_ne_len() -> i32 { return 6; }
fn wl_f32_lt_ptr() -> i32 { return wat_lit_base() + 1248; }
fn wl_f32_lt_len() -> i32 { return 6; }
fn wl_f32_gt_ptr() -> i32 { return wat_lit_base() + 1256; }
fn wl_f32_gt_len() -> i32 { return 6; }
fn wl_f32_le_ptr() -> i32 { return wat_lit_base() + 1264; }
fn wl_f32_le_len() -> i32 { return 6; }
fn wl_f32_ge_ptr() -> i32 { return wat_lit_base() + 1272; }
fn wl_f32_ge_len() -> i32 { return 6; }
fn wl_param_f32_ptr() -> i32 { return wat_lit_base() + 1280; }
fn wl_param_f32_len() -> i32 { return 10; }
fn wl_result_f32_ptr() -> i32 { return wat_lit_base() + 1292; }
fn wl_result_f32_len() -> i32 { return 12; }
fn wl_local_f32_ptr() -> i32 { return wat_lit_base() + 1308; }
fn wl_local_f32_len() -> i32 { return 10; }
// f64 WAT literals
fn wl_f64_const_ptr() -> i32 { return wat_lit_base() + 1328; }
fn wl_f64_const_len() -> i32 { return 10; }
fn wl_f64_add_ptr() -> i32 { return wat_lit_base() + 1344; }
fn wl_f64_add_len() -> i32 { return 7; }
fn wl_f64_sub_ptr() -> i32 { return wat_lit_base() + 1352; }
fn wl_f64_sub_len() -> i32 { return 7; }
fn wl_f64_mul_ptr() -> i32 { return wat_lit_base() + 1360; }
fn wl_f64_mul_len() -> i32 { return 7; }
fn wl_f64_div_ptr() -> i32 { return wat_lit_base() + 1368; }
fn wl_f64_div_len() -> i32 { return 7; }
fn wl_f64_eq_ptr() -> i32 { return wat_lit_base() + 1376; }
fn wl_f64_eq_len() -> i32 { return 6; }
fn wl_f64_ne_ptr() -> i32 { return wat_lit_base() + 1384; }
fn wl_f64_ne_len() -> i32 { return 6; }
fn wl_f64_lt_ptr() -> i32 { return wat_lit_base() + 1392; }
fn wl_f64_lt_len() -> i32 { return 6; }
fn wl_f64_gt_ptr() -> i32 { return wat_lit_base() + 1400; }
fn wl_f64_gt_len() -> i32 { return 6; }
fn wl_f64_le_ptr() -> i32 { return wat_lit_base() + 1408; }
fn wl_f64_le_len() -> i32 { return 6; }
fn wl_f64_ge_ptr() -> i32 { return wat_lit_base() + 1416; }
fn wl_f64_ge_len() -> i32 { return 6; }
fn wl_param_f64_ptr() -> i32 { return wat_lit_base() + 1424; }
fn wl_param_f64_len() -> i32 { return 10; }
fn wl_result_f64_ptr() -> i32 { return wat_lit_base() + 1436; }
fn wl_result_f64_len() -> i32 { return 12; }
fn wl_local_f64_ptr() -> i32 { return wat_lit_base() + 1452; }
fn wl_local_f64_len() -> i32 { return 10; }
fn wl_unreachable_ptr() -> i32 { return wat_lit_base() + 1472; }
fn wl_unreachable_len() -> i32 { return 11; }

fn init_wat_byte(off: i32, val: i32) -> i32 {
  __mem_store8(wat_lit_base() + off, val);
  return 0;
}

fn init_wat_literals() -> i32 {
  if (__mem_load(wat_lit_inited_addr()) != 0) { return 0; }

  // "(module" at offset 0
  init_wat_byte(0, 40);   // (
  init_wat_byte(1, 109);  // m
  init_wat_byte(2, 111);  // o
  init_wat_byte(3, 100);  // d
  init_wat_byte(4, 117);  // u
  init_wat_byte(5, 108);  // l
  init_wat_byte(6, 101);  // e

  // ")" at offset 7
  init_wat_byte(7, 41);

  // "(import \"wasi_snapshot_preview1\" " at offset 8 (37 bytes)
  // We won't use this directly - use the full import lines instead

  // "(func $" at offset 96
  init_wat_byte(96, 40);   // (
  init_wat_byte(97, 102);  // f
  init_wat_byte(98, 117);  // u
  init_wat_byte(99, 110);  // n
  init_wat_byte(100, 99);  // c
  init_wat_byte(101, 32);  // ' '
  init_wat_byte(102, 36);  // $

  // "(param i32)" at offset 103 (10 bytes)
  init_wat_byte(103, 40);  // (
  init_wat_byte(104, 112); // p
  init_wat_byte(105, 97);  // a
  init_wat_byte(106, 114); // r
  init_wat_byte(107, 97);  // a
  init_wat_byte(108, 109); // m
  init_wat_byte(109, 32);  // ' '
  init_wat_byte(110, 105); // i
  init_wat_byte(111, 51);  // 3
  init_wat_byte(112, 50);  // 2

  // " (result i32)" at offset 113 (12 bytes) - note leading space missing, we emit it
  init_wat_byte(113, 32);  // ' '
  init_wat_byte(114, 40);  // (
  init_wat_byte(115, 114); // r
  init_wat_byte(116, 101); // e
  init_wat_byte(117, 115); // s
  init_wat_byte(118, 117); // u
  init_wat_byte(119, 108); // l
  init_wat_byte(120, 116); // t
  init_wat_byte(121, 32);  // ' '
  init_wat_byte(122, 105); // i
  init_wat_byte(123, 51);  // 3
  init_wat_byte(124, 50);  // 2

  // "(local i32)" at offset 128 (10 bytes)
  init_wat_byte(128, 40);  // (
  init_wat_byte(129, 108); // l
  init_wat_byte(130, 111); // o
  init_wat_byte(131, 99);  // c
  init_wat_byte(132, 97);  // a
  init_wat_byte(133, 108); // l
  init_wat_byte(134, 32);  // ' '
  init_wat_byte(135, 105); // i
  init_wat_byte(136, 51);  // 3
  init_wat_byte(137, 50);  // 2

  // "local.get " at offset 144 (10 bytes)
  init_wat_byte(144, 108); // l
  init_wat_byte(145, 111); // o
  init_wat_byte(146, 99);  // c
  init_wat_byte(147, 97);  // a
  init_wat_byte(148, 108); // l
  init_wat_byte(149, 46);  // .
  init_wat_byte(150, 103); // g
  init_wat_byte(151, 101); // e
  init_wat_byte(152, 116); // t
  init_wat_byte(153, 32);  // ' '

  // "local.set " at offset 160 (10 bytes)
  init_wat_byte(160, 108); // l
  init_wat_byte(161, 111); // o
  init_wat_byte(162, 99);  // c
  init_wat_byte(163, 97);  // a
  init_wat_byte(164, 108); // l
  init_wat_byte(165, 46);  // .
  init_wat_byte(166, 115); // s
  init_wat_byte(167, 101); // e
  init_wat_byte(168, 116); // t
  init_wat_byte(169, 32);  // ' '

  // "i32.const " at offset 176 (10 bytes)
  init_wat_byte(176, 105); // i
  init_wat_byte(177, 51);  // 3
  init_wat_byte(178, 50);  // 2
  init_wat_byte(179, 46);  // .
  init_wat_byte(180, 99);  // c
  init_wat_byte(181, 111); // o
  init_wat_byte(182, 110); // n
  init_wat_byte(183, 115); // s
  init_wat_byte(184, 116); // t
  init_wat_byte(185, 32);  // ' '

  // "i32.add" at offset 192 (7 bytes)
  init_wat_byte(192, 105); init_wat_byte(193, 51); init_wat_byte(194, 50);
  init_wat_byte(195, 46); init_wat_byte(196, 97); init_wat_byte(197, 100);
  init_wat_byte(198, 100);

  // "i32.sub" at offset 200 (7 bytes)
  init_wat_byte(200, 105); init_wat_byte(201, 51); init_wat_byte(202, 50);
  init_wat_byte(203, 46); init_wat_byte(204, 115); init_wat_byte(205, 117);
  init_wat_byte(206, 98);

  // "i32.mul" at offset 208 (7 bytes)
  init_wat_byte(208, 105); init_wat_byte(209, 51); init_wat_byte(210, 50);
  init_wat_byte(211, 46); init_wat_byte(212, 109); init_wat_byte(213, 117);
  init_wat_byte(214, 108);

  // "i32.div_s" at offset 216 (9 bytes)
  init_wat_byte(216, 105); init_wat_byte(217, 51); init_wat_byte(218, 50);
  init_wat_byte(219, 46); init_wat_byte(220, 100); init_wat_byte(221, 105);
  init_wat_byte(222, 118); init_wat_byte(223, 95); init_wat_byte(224, 115);

  // "i32.eq" at offset 228 (6 bytes)
  init_wat_byte(228, 105); init_wat_byte(229, 51); init_wat_byte(230, 50);
  init_wat_byte(231, 46); init_wat_byte(232, 101); init_wat_byte(233, 113);

  // "i32.ne" at offset 234 (6 bytes)
  init_wat_byte(234, 105); init_wat_byte(235, 51); init_wat_byte(236, 50);
  init_wat_byte(237, 46); init_wat_byte(238, 110); init_wat_byte(239, 101);

  // "i32.lt_s" at offset 240 (8 bytes)
  init_wat_byte(240, 105); init_wat_byte(241, 51); init_wat_byte(242, 50);
  init_wat_byte(243, 46); init_wat_byte(244, 108); init_wat_byte(245, 116);
  init_wat_byte(246, 95); init_wat_byte(247, 115);

  // "i32.gt_s" at offset 248 (8 bytes)
  init_wat_byte(248, 105); init_wat_byte(249, 51); init_wat_byte(250, 50);
  init_wat_byte(251, 46); init_wat_byte(252, 103); init_wat_byte(253, 116);
  init_wat_byte(254, 95); init_wat_byte(255, 115);

  // "i32.le_s" at offset 256 (8 bytes)
  init_wat_byte(256, 105); init_wat_byte(257, 51); init_wat_byte(258, 50);
  init_wat_byte(259, 46); init_wat_byte(260, 108); init_wat_byte(261, 101);
  init_wat_byte(262, 95); init_wat_byte(263, 115);

  // "i32.ge_s" at offset 264 (8 bytes)
  init_wat_byte(264, 105); init_wat_byte(265, 51); init_wat_byte(266, 50);
  init_wat_byte(267, 46); init_wat_byte(268, 103); init_wat_byte(269, 101);
  init_wat_byte(270, 95); init_wat_byte(271, 115);

  // "i32.and" at offset 272 (7 bytes)
  init_wat_byte(272, 105); init_wat_byte(273, 51); init_wat_byte(274, 50);
  init_wat_byte(275, 46); init_wat_byte(276, 97); init_wat_byte(277, 110);
  init_wat_byte(278, 100);

  // "i32.or" at offset 280 (6 bytes)
  init_wat_byte(280, 105); init_wat_byte(281, 51); init_wat_byte(282, 50);
  init_wat_byte(283, 46); init_wat_byte(284, 111); init_wat_byte(285, 114);

  // "i32.eqz" at offset 288 (7 bytes)
  init_wat_byte(288, 105); init_wat_byte(289, 51); init_wat_byte(290, 50);
  init_wat_byte(291, 46); init_wat_byte(292, 101); init_wat_byte(293, 113);
  init_wat_byte(294, 122);

  // "i32.store" at offset 296 (9 bytes)
  init_wat_byte(296, 105); init_wat_byte(297, 51); init_wat_byte(298, 50);
  init_wat_byte(299, 46); init_wat_byte(300, 115); init_wat_byte(301, 116);
  init_wat_byte(302, 111); init_wat_byte(303, 114); init_wat_byte(304, 101);

  // "i32.store8" at offset 308 (10 bytes)
  init_wat_byte(308, 105); init_wat_byte(309, 51); init_wat_byte(310, 50);
  init_wat_byte(311, 46); init_wat_byte(312, 115); init_wat_byte(313, 116);
  init_wat_byte(314, 111); init_wat_byte(315, 114); init_wat_byte(316, 101);
  init_wat_byte(317, 56);

  // "i32.load" at offset 320 (8 bytes)
  init_wat_byte(320, 105); init_wat_byte(321, 51); init_wat_byte(322, 50);
  init_wat_byte(323, 46); init_wat_byte(324, 108); init_wat_byte(325, 111);
  init_wat_byte(326, 97); init_wat_byte(327, 100);

  // "i32.load8_u" at offset 328 (10 bytes - actually 11)
  init_wat_byte(328, 105); init_wat_byte(329, 51); init_wat_byte(330, 50);
  init_wat_byte(331, 46); init_wat_byte(332, 108); init_wat_byte(333, 111);
  init_wat_byte(334, 97); init_wat_byte(335, 100); init_wat_byte(336, 56);
  init_wat_byte(337, 95); init_wat_byte(338, 117);

  // "call $" at offset 344 (6 bytes)
  init_wat_byte(344, 99); init_wat_byte(345, 97); init_wat_byte(346, 108);
  init_wat_byte(347, 108); init_wat_byte(348, 32); init_wat_byte(349, 36);

  // "return" at offset 352 (6 bytes)
  init_wat_byte(352, 114); init_wat_byte(353, 101); init_wat_byte(354, 116);
  init_wat_byte(355, 117); init_wat_byte(356, 114); init_wat_byte(357, 110);

  // "drop" at offset 360 (4 bytes)
  init_wat_byte(360, 100); init_wat_byte(361, 114); init_wat_byte(362, 111);
  init_wat_byte(363, 112);

  // "if" at offset 368 (2 bytes)
  init_wat_byte(368, 105); init_wat_byte(369, 102);

  // "else" at offset 376 (4 bytes)
  init_wat_byte(376, 101); init_wat_byte(377, 108); init_wat_byte(378, 115);
  init_wat_byte(379, 101);

  // "end" at offset 384 (3 bytes)
  init_wat_byte(384, 101); init_wat_byte(385, 110); init_wat_byte(386, 100);

  // "block" at offset 392 (5 bytes)
  init_wat_byte(392, 98); init_wat_byte(393, 108); init_wat_byte(394, 111);
  init_wat_byte(395, 99); init_wat_byte(396, 107);

  // "loop" at offset 400 (4 bytes)
  init_wat_byte(400, 108); init_wat_byte(401, 111); init_wat_byte(402, 111);
  init_wat_byte(403, 112);

  // "br_if 1" at offset 408 (6 bytes) -- actually 7
  init_wat_byte(408, 98); init_wat_byte(409, 114); init_wat_byte(410, 95);
  init_wat_byte(411, 105); init_wat_byte(412, 102); init_wat_byte(413, 32);
  init_wat_byte(414, 49);

  // "br 0" at offset 416 (4 bytes)
  init_wat_byte(416, 98); init_wat_byte(417, 114); init_wat_byte(418, 32);
  init_wat_byte(419, 48);

  // "(memory (export \"memory\") 2)" at offset 424 (30 bytes)
  // (memory (export "memory") 2)
  init_wat_byte(424, 40); init_wat_byte(425, 109); init_wat_byte(426, 101);
  init_wat_byte(427, 109); init_wat_byte(428, 111); init_wat_byte(429, 114);
  init_wat_byte(430, 121); init_wat_byte(431, 32); init_wat_byte(432, 40);
  init_wat_byte(433, 101); init_wat_byte(434, 120); init_wat_byte(435, 112);
  init_wat_byte(436, 111); init_wat_byte(437, 114); init_wat_byte(438, 116);
  init_wat_byte(439, 32); init_wat_byte(440, 34); init_wat_byte(441, 109);
  init_wat_byte(442, 101); init_wat_byte(443, 109); init_wat_byte(444, 111);
  init_wat_byte(445, 114); init_wat_byte(446, 121); init_wat_byte(447, 34);
  init_wat_byte(448, 41); init_wat_byte(449, 32); init_wat_byte(450, 50);
  init_wat_byte(451, 41);

  // "(data (i32.const " at offset 464 (16 bytes) -- actually 17
  init_wat_byte(464, 40); init_wat_byte(465, 100); init_wat_byte(466, 97);
  init_wat_byte(467, 116); init_wat_byte(468, 97); init_wat_byte(469, 32);
  init_wat_byte(470, 40); init_wat_byte(471, 105); init_wat_byte(472, 51);
  init_wat_byte(473, 50); init_wat_byte(474, 46); init_wat_byte(475, 99);
  init_wat_byte(476, 111); init_wat_byte(477, 110); init_wat_byte(478, 115);
  init_wat_byte(479, 116); init_wat_byte(480, 32);

  // (export "_start" (func $_start)) at offset 480 -> moved to 496
  // Actually let me re-layout: data_prefix is 17 bytes at 464

  // Export line: '(export "_start" (func $_start))' at offset 496 (34 bytes)
  // (export "_start" (func $_start))
  init_wat_byte(496, 40);  // (
  init_wat_byte(497, 101);  // e
  init_wat_byte(498, 120);  // x
  init_wat_byte(499, 112);  // p
  init_wat_byte(500, 111);  // o
  init_wat_byte(501, 114);  // r
  init_wat_byte(502, 116);  // t
  init_wat_byte(503, 32);   // ' '
  init_wat_byte(504, 34);   // "
  init_wat_byte(505, 95);   // _
  init_wat_byte(506, 115);  // s
  init_wat_byte(507, 116);  // t
  init_wat_byte(508, 97);   // a
  init_wat_byte(509, 114);  // r
  init_wat_byte(510, 116);  // t
  init_wat_byte(511, 34);   // "
  init_wat_byte(512, 32);   // ' '
  init_wat_byte(513, 40);   // (
  init_wat_byte(514, 102);  // f
  init_wat_byte(515, 117);  // u
  init_wat_byte(516, 110);  // n
  init_wat_byte(517, 99);   // c
  init_wat_byte(518, 32);   // ' '
  init_wat_byte(519, 36);   // $
  init_wat_byte(520, 95);   // _
  init_wat_byte(521, 115);  // s
  init_wat_byte(522, 116);  // t
  init_wat_byte(523, 97);   // a
  init_wat_byte(524, 114);  // r
  init_wat_byte(525, 116);  // t
  init_wat_byte(526, 41);   // )
  init_wat_byte(527, 41);   // )

  // Full WASI import lines at offset 528+
  // fd_write import: (import "wasi_snapshot_preview1" "fd_write"\n    (func $fd_write (param i32 i32 i32 i32) (result i32)))
  // We'll store each full import line and emit them directly

  // fd_write import line 1: '(import "wasi_snapshot_preview1" "fd_write"'
  // 43 chars
  init_wat_byte(528, 40);   // (
  init_wat_byte(529, 105);  // i
  init_wat_byte(530, 109);  // m
  init_wat_byte(531, 112);  // p
  init_wat_byte(532, 111);  // o
  init_wat_byte(533, 114);  // r
  init_wat_byte(534, 116);  // t
  init_wat_byte(535, 32);   // ' '
  init_wat_byte(536, 34);   // "
  init_wat_byte(537, 119);  // w
  init_wat_byte(538, 97);   // a
  init_wat_byte(539, 115);  // s
  init_wat_byte(540, 105);  // i
  init_wat_byte(541, 95);   // _
  init_wat_byte(542, 115);  // s
  init_wat_byte(543, 110);  // n
  init_wat_byte(544, 97);   // a
  init_wat_byte(545, 112);  // p
  init_wat_byte(546, 115);  // s
  init_wat_byte(547, 104);  // h
  init_wat_byte(548, 111);  // o
  init_wat_byte(549, 116);  // t
  init_wat_byte(550, 95);   // _
  init_wat_byte(551, 112);  // p
  init_wat_byte(552, 114);  // r
  init_wat_byte(553, 101);  // e
  init_wat_byte(554, 118);  // v
  init_wat_byte(555, 105);  // i
  init_wat_byte(556, 101);  // e
  init_wat_byte(557, 119);  // w
  init_wat_byte(558, 49);   // 1
  init_wat_byte(559, 34);   // "
  init_wat_byte(560, 32);   // ' '
  init_wat_byte(561, 34);   // "
  init_wat_byte(562, 102);  // f
  init_wat_byte(563, 100);  // d
  init_wat_byte(564, 95);   // _
  init_wat_byte(565, 119);  // w
  init_wat_byte(566, 114);  // r
  init_wat_byte(567, 105);  // i
  init_wat_byte(568, 116);  // t
  init_wat_byte(569, 101);  // e
  init_wat_byte(570, 34);   // "

  // fd_read import line 1: '(import "wasi_snapshot_preview1" "fd_read"'
  // Reuse bytes 528..559 for the shared prefix, then just the name differs
  // For simplicity, store complete line 2 fragments separately
  // Let me use a different approach - emit imports programmatically

  // "i64.extend_i32_u" at offset 912 (16 bytes) -- actually 15
  init_wat_byte(912, 105); // i
  init_wat_byte(913, 54);  // 6
  init_wat_byte(914, 52);  // 4
  init_wat_byte(915, 46);  // .
  init_wat_byte(916, 101); // e
  init_wat_byte(917, 120); // x
  init_wat_byte(918, 116); // t
  init_wat_byte(919, 101); // e
  init_wat_byte(920, 110); // n
  init_wat_byte(921, 100); // d
  init_wat_byte(922, 95); // _
  init_wat_byte(923, 105); // i
  init_wat_byte(924, 51);  // 3
  init_wat_byte(925, 50);  // 2
  init_wat_byte(926, 95); // _
  init_wat_byte(927, 117); // u

  // " (param i32)" at offset 928 (11 bytes) - with leading space
  init_wat_byte(928, 32);  // ' '
  init_wat_byte(929, 40);  // (
  init_wat_byte(930, 112); // p
  init_wat_byte(931, 97);  // a
  init_wat_byte(932, 114); // r
  init_wat_byte(933, 97);  // a
  init_wat_byte(934, 109); // m
  init_wat_byte(935, 32);  // ' '
  init_wat_byte(936, 105); // i
  init_wat_byte(937, 51);  // 3
  init_wat_byte(938, 50);  // 2

  // "unary" at offset 944 (5 bytes)
  init_wat_byte(944, 117); // u
  init_wat_byte(945, 110); // n
  init_wat_byte(946, 97);  // a
  init_wat_byte(947, 114); // r
  init_wat_byte(948, 121); // y

  // "true" at offset 952 (4 bytes)
  init_wat_byte(952, 116); // t
  init_wat_byte(953, 114); // r
  init_wat_byte(954, 117); // u
  init_wat_byte(955, 101); // e

  // "false" at offset 960 (5 bytes)
  init_wat_byte(960, 102); // f
  init_wat_byte(961, 97);  // a
  init_wat_byte(962, 108); // l
  init_wat_byte(963, 115); // s
  init_wat_byte(964, 101); // e

  // "i32 i32 i32 i32" at offset 976 (15 bytes)
  init_wat_byte(976, 105); init_wat_byte(977, 51); init_wat_byte(978, 50);  // i32
  init_wat_byte(979, 32);  // ' '
  init_wat_byte(980, 105); init_wat_byte(981, 51); init_wat_byte(982, 50);  // i32
  init_wat_byte(983, 32);
  init_wat_byte(984, 105); init_wat_byte(985, 51); init_wat_byte(986, 50);  // i32
  init_wat_byte(987, 32);
  init_wat_byte(988, 105); init_wat_byte(989, 51); init_wat_byte(990, 50);  // i32

  // "i32" at offset 992 (3 bytes)
  init_wat_byte(992, 105); init_wat_byte(993, 51); init_wat_byte(994, 50);

  // "i32 i32 i32 i32 i32 i64 i64 i32 i32" at offset 1000 (37 bytes)
  init_wat_byte(1000, 105); init_wat_byte(1001, 51); init_wat_byte(1002, 50); // i32
  init_wat_byte(1003, 32);
  init_wat_byte(1004, 105); init_wat_byte(1005, 51); init_wat_byte(1006, 50); // i32
  init_wat_byte(1007, 32);
  init_wat_byte(1008, 105); init_wat_byte(1009, 51); init_wat_byte(1010, 50); // i32
  init_wat_byte(1011, 32);
  init_wat_byte(1012, 105); init_wat_byte(1013, 51); init_wat_byte(1014, 50); // i32
  init_wat_byte(1015, 32);
  init_wat_byte(1016, 105); init_wat_byte(1017, 51); init_wat_byte(1018, 50); // i32
  init_wat_byte(1019, 32);
  init_wat_byte(1020, 105); init_wat_byte(1021, 54); init_wat_byte(1022, 52); // i64
  init_wat_byte(1023, 32);
  init_wat_byte(1024, 105); init_wat_byte(1025, 54); init_wat_byte(1026, 52); // i64
  init_wat_byte(1027, 32);
  init_wat_byte(1028, 105); init_wat_byte(1029, 51); init_wat_byte(1030, 50); // i32
  init_wat_byte(1031, 32);
  init_wat_byte(1032, 105); init_wat_byte(1033, 51); init_wat_byte(1034, 50); // i32
  // = 35 chars (i32=3, space=1, Ã—4 + i32=3 + space + i64=3 + space + i64=3 + space + i32=3 + space + i32=3 = 3+1+3+1+3+1+3+1+3+1+3+1+3+1+3+1+3 = 35)
  // Actually: "i32 i32 i32 i32 i32 i64 i64 i32 i32" = 37 chars
  // Let me recount: i(1)3(2)2(3) (4)i(5)3(6)2(7) (8)i(9)3(10)2(11) (12)i(13)3(14)2(15) (16)i(17)3(18)2(19) (20)i(21)6(22)4(23) (24)i(25)6(26)4(27) (28)i(29)3(30)2(31) (32)i(33)3(34)2(35)
  // That's 35 characters, not 37. Let me fix the len.

  // "i64.const " at offset 1040 (10 bytes)
  init_wat_byte(1040, 105); init_wat_byte(1041, 54); init_wat_byte(1042, 52);
  init_wat_byte(1043, 46); init_wat_byte(1044, 99); init_wat_byte(1045, 111);
  init_wat_byte(1046, 110); init_wat_byte(1047, 115); init_wat_byte(1048, 116);
  init_wat_byte(1049, 32);

  // "i64.add" at offset 1056
  init_wat_byte(1056, 105); init_wat_byte(1057, 54); init_wat_byte(1058, 52);
  init_wat_byte(1059, 46); init_wat_byte(1060, 97); init_wat_byte(1061, 100);
  init_wat_byte(1062, 100);

  // "i64.sub" at offset 1064
  init_wat_byte(1064, 105); init_wat_byte(1065, 54); init_wat_byte(1066, 52);
  init_wat_byte(1067, 46); init_wat_byte(1068, 115); init_wat_byte(1069, 117);
  init_wat_byte(1070, 98);

  // "i64.mul" at offset 1072
  init_wat_byte(1072, 105); init_wat_byte(1073, 54); init_wat_byte(1074, 52);
  init_wat_byte(1075, 46); init_wat_byte(1076, 109); init_wat_byte(1077, 117);
  init_wat_byte(1078, 108);

  // "i64.div_s" at offset 1080
  init_wat_byte(1080, 105); init_wat_byte(1081, 54); init_wat_byte(1082, 52);
  init_wat_byte(1083, 46); init_wat_byte(1084, 100); init_wat_byte(1085, 105);
  init_wat_byte(1086, 118); init_wat_byte(1087, 95); init_wat_byte(1088, 115);

  // "i64.eq" at offset 1092
  init_wat_byte(1092, 105); init_wat_byte(1093, 54); init_wat_byte(1094, 52);
  init_wat_byte(1095, 46); init_wat_byte(1096, 101); init_wat_byte(1097, 113);

  // "i64.ne" at offset 1100
  init_wat_byte(1100, 105); init_wat_byte(1101, 54); init_wat_byte(1102, 52);
  init_wat_byte(1103, 46); init_wat_byte(1104, 110); init_wat_byte(1105, 101);

  // "i64.lt_s" at offset 1108
  init_wat_byte(1108, 105); init_wat_byte(1109, 54); init_wat_byte(1110, 52);
  init_wat_byte(1111, 46); init_wat_byte(1112, 108); init_wat_byte(1113, 116);
  init_wat_byte(1114, 95); init_wat_byte(1115, 115);

  // "i64.gt_s" at offset 1116
  init_wat_byte(1116, 105); init_wat_byte(1117, 54); init_wat_byte(1118, 52);
  init_wat_byte(1119, 46); init_wat_byte(1120, 103); init_wat_byte(1121, 116);
  init_wat_byte(1122, 95); init_wat_byte(1123, 115);

  // "i64.le_s" at offset 1124
  init_wat_byte(1124, 105); init_wat_byte(1125, 54); init_wat_byte(1126, 52);
  init_wat_byte(1127, 46); init_wat_byte(1128, 108); init_wat_byte(1129, 101);
  init_wat_byte(1130, 95); init_wat_byte(1131, 115);

  // "i64.ge_s" at offset 1132
  init_wat_byte(1132, 105); init_wat_byte(1133, 54); init_wat_byte(1134, 52);
  init_wat_byte(1135, 46); init_wat_byte(1136, 103); init_wat_byte(1137, 101);
  init_wat_byte(1138, 95); init_wat_byte(1139, 115);

  // "(param i64)" at offset 1140 (10 bytes)
  init_wat_byte(1140, 40); init_wat_byte(1141, 112); init_wat_byte(1142, 97);
  init_wat_byte(1143, 114); init_wat_byte(1144, 97); init_wat_byte(1145, 109);
  init_wat_byte(1146, 32); init_wat_byte(1147, 105); init_wat_byte(1148, 54);
  init_wat_byte(1149, 52);

  // " (result i64)" at offset 1152 (12 bytes)
  init_wat_byte(1152, 32); init_wat_byte(1153, 40); init_wat_byte(1154, 114);
  init_wat_byte(1155, 101); init_wat_byte(1156, 115); init_wat_byte(1157, 117);
  init_wat_byte(1158, 108); init_wat_byte(1159, 116); init_wat_byte(1160, 32);
  init_wat_byte(1161, 105); init_wat_byte(1162, 54); init_wat_byte(1163, 52);

  // "(local i64)" at offset 1168 (10 bytes)
  init_wat_byte(1168, 40); init_wat_byte(1169, 108); init_wat_byte(1170, 111);
  init_wat_byte(1171, 99); init_wat_byte(1172, 97); init_wat_byte(1173, 108);
  init_wat_byte(1174, 32); init_wat_byte(1175, 105); init_wat_byte(1176, 54);
  init_wat_byte(1177, 52);

  // "f32.const " at offset 1184 (10 bytes)
  init_wat_byte(1184, 102); init_wat_byte(1185, 51); init_wat_byte(1186, 50);
  init_wat_byte(1187, 46); init_wat_byte(1188, 99); init_wat_byte(1189, 111);
  init_wat_byte(1190, 110); init_wat_byte(1191, 115); init_wat_byte(1192, 116);
  init_wat_byte(1193, 32);

  // "f32.add" at offset 1200
  init_wat_byte(1200, 102); init_wat_byte(1201, 51); init_wat_byte(1202, 50);
  init_wat_byte(1203, 46); init_wat_byte(1204, 97); init_wat_byte(1205, 100);
  init_wat_byte(1206, 100);
  // "f32.sub" at offset 1208
  init_wat_byte(1208, 102); init_wat_byte(1209, 51); init_wat_byte(1210, 50);
  init_wat_byte(1211, 46); init_wat_byte(1212, 115); init_wat_byte(1213, 117);
  init_wat_byte(1214, 98);
  // "f32.mul" at offset 1216
  init_wat_byte(1216, 102); init_wat_byte(1217, 51); init_wat_byte(1218, 50);
  init_wat_byte(1219, 46); init_wat_byte(1220, 109); init_wat_byte(1221, 117);
  init_wat_byte(1222, 108);
  // "f32.div" at offset 1224
  init_wat_byte(1224, 102); init_wat_byte(1225, 51); init_wat_byte(1226, 50);
  init_wat_byte(1227, 46); init_wat_byte(1228, 100); init_wat_byte(1229, 105);
  init_wat_byte(1230, 118);
  // "f32.eq" at offset 1232
  init_wat_byte(1232, 102); init_wat_byte(1233, 51); init_wat_byte(1234, 50);
  init_wat_byte(1235, 46); init_wat_byte(1236, 101); init_wat_byte(1237, 113);
  // "f32.ne" at offset 1240
  init_wat_byte(1240, 102); init_wat_byte(1241, 51); init_wat_byte(1242, 50);
  init_wat_byte(1243, 46); init_wat_byte(1244, 110); init_wat_byte(1245, 101);
  // "f32.lt" at offset 1248
  init_wat_byte(1248, 102); init_wat_byte(1249, 51); init_wat_byte(1250, 50);
  init_wat_byte(1251, 46); init_wat_byte(1252, 108); init_wat_byte(1253, 116);
  // "f32.gt" at offset 1256
  init_wat_byte(1256, 102); init_wat_byte(1257, 51); init_wat_byte(1258, 50);
  init_wat_byte(1259, 46); init_wat_byte(1260, 103); init_wat_byte(1261, 116);
  // "f32.le" at offset 1264
  init_wat_byte(1264, 102); init_wat_byte(1265, 51); init_wat_byte(1266, 50);
  init_wat_byte(1267, 46); init_wat_byte(1268, 108); init_wat_byte(1269, 101);
  // "f32.ge" at offset 1272
  init_wat_byte(1272, 102); init_wat_byte(1273, 51); init_wat_byte(1274, 50);
  init_wat_byte(1275, 46); init_wat_byte(1276, 103); init_wat_byte(1277, 101);

  // "(param f32)" at offset 1280
  init_wat_byte(1280, 40); init_wat_byte(1281, 112); init_wat_byte(1282, 97);
  init_wat_byte(1283, 114); init_wat_byte(1284, 97); init_wat_byte(1285, 109);
  init_wat_byte(1286, 32); init_wat_byte(1287, 102); init_wat_byte(1288, 51);
  init_wat_byte(1289, 50);
  // " (result f32)" at offset 1292
  init_wat_byte(1292, 32); init_wat_byte(1293, 40); init_wat_byte(1294, 114);
  init_wat_byte(1295, 101); init_wat_byte(1296, 115); init_wat_byte(1297, 117);
  init_wat_byte(1298, 108); init_wat_byte(1299, 116); init_wat_byte(1300, 32);
  init_wat_byte(1301, 102); init_wat_byte(1302, 51); init_wat_byte(1303, 50);
  // "(local f32)" at offset 1308
  init_wat_byte(1308, 40); init_wat_byte(1309, 108); init_wat_byte(1310, 111);
  init_wat_byte(1311, 99); init_wat_byte(1312, 97); init_wat_byte(1313, 108);
  init_wat_byte(1314, 32); init_wat_byte(1315, 102); init_wat_byte(1316, 51);
  init_wat_byte(1317, 50);

  // "f64.const " at offset 1328 (10 bytes)
  init_wat_byte(1328, 102); init_wat_byte(1329, 54); init_wat_byte(1330, 52);
  init_wat_byte(1331, 46); init_wat_byte(1332, 99); init_wat_byte(1333, 111);
  init_wat_byte(1334, 110); init_wat_byte(1335, 115); init_wat_byte(1336, 116);
  init_wat_byte(1337, 32);
  // "f64.add" at offset 1344
  init_wat_byte(1344, 102); init_wat_byte(1345, 54); init_wat_byte(1346, 52);
  init_wat_byte(1347, 46); init_wat_byte(1348, 97); init_wat_byte(1349, 100);
  init_wat_byte(1350, 100);
  // "f64.sub" at offset 1352
  init_wat_byte(1352, 102); init_wat_byte(1353, 54); init_wat_byte(1354, 52);
  init_wat_byte(1355, 46); init_wat_byte(1356, 115); init_wat_byte(1357, 117);
  init_wat_byte(1358, 98);
  // "f64.mul" at offset 1360
  init_wat_byte(1360, 102); init_wat_byte(1361, 54); init_wat_byte(1362, 52);
  init_wat_byte(1363, 46); init_wat_byte(1364, 109); init_wat_byte(1365, 117);
  init_wat_byte(1366, 108);
  // "f64.div" at offset 1368
  init_wat_byte(1368, 102); init_wat_byte(1369, 54); init_wat_byte(1370, 52);
  init_wat_byte(1371, 46); init_wat_byte(1372, 100); init_wat_byte(1373, 105);
  init_wat_byte(1374, 118);
  // "f64.eq" at offset 1376
  init_wat_byte(1376, 102); init_wat_byte(1377, 54); init_wat_byte(1378, 52);
  init_wat_byte(1379, 46); init_wat_byte(1380, 101); init_wat_byte(1381, 113);
  // "f64.ne" at offset 1384
  init_wat_byte(1384, 102); init_wat_byte(1385, 54); init_wat_byte(1386, 52);
  init_wat_byte(1387, 46); init_wat_byte(1388, 110); init_wat_byte(1389, 101);
  // "f64.lt" at offset 1392
  init_wat_byte(1392, 102); init_wat_byte(1393, 54); init_wat_byte(1394, 52);
  init_wat_byte(1395, 46); init_wat_byte(1396, 108); init_wat_byte(1397, 116);
  // "f64.gt" at offset 1400
  init_wat_byte(1400, 102); init_wat_byte(1401, 54); init_wat_byte(1402, 52);
  init_wat_byte(1403, 46); init_wat_byte(1404, 103); init_wat_byte(1405, 116);
  // "f64.le" at offset 1408
  init_wat_byte(1408, 102); init_wat_byte(1409, 54); init_wat_byte(1410, 52);
  init_wat_byte(1411, 46); init_wat_byte(1412, 108); init_wat_byte(1413, 101);
  // "f64.ge" at offset 1416
  init_wat_byte(1416, 102); init_wat_byte(1417, 54); init_wat_byte(1418, 52);
  init_wat_byte(1419, 46); init_wat_byte(1420, 103); init_wat_byte(1421, 101);

  // "(param f64)" at offset 1424
  init_wat_byte(1424, 40); init_wat_byte(1425, 112); init_wat_byte(1426, 97);
  init_wat_byte(1427, 114); init_wat_byte(1428, 97); init_wat_byte(1429, 109);
  init_wat_byte(1430, 32); init_wat_byte(1431, 102); init_wat_byte(1432, 54);
  init_wat_byte(1433, 52);
  // " (result f64)" at offset 1436
  init_wat_byte(1436, 32); init_wat_byte(1437, 40); init_wat_byte(1438, 114);
  init_wat_byte(1439, 101); init_wat_byte(1440, 115); init_wat_byte(1441, 117);
  init_wat_byte(1442, 108); init_wat_byte(1443, 116); init_wat_byte(1444, 32);
  init_wat_byte(1445, 102); init_wat_byte(1446, 54); init_wat_byte(1447, 52);
  // "(local f64)" at offset 1452
  init_wat_byte(1452, 40); init_wat_byte(1453, 108); init_wat_byte(1454, 111);
  init_wat_byte(1455, 99); init_wat_byte(1456, 97); init_wat_byte(1457, 108);
  init_wat_byte(1458, 32); init_wat_byte(1459, 102); init_wat_byte(1460, 54);
  init_wat_byte(1461, 52);
  // "unreachable" at offset 1472
  init_wat_byte(1472, 117); init_wat_byte(1473, 110); init_wat_byte(1474, 114);
  init_wat_byte(1475, 101); init_wat_byte(1476, 97); init_wat_byte(1477, 99);
  init_wat_byte(1478, 104); init_wat_byte(1479, 97); init_wat_byte(1480, 98);
  init_wat_byte(1481, 108); init_wat_byte(1482, 101);

  __mem_store(wat_lit_inited_addr(), 1);
  return 0;
}

// Fix up literal lengths that were miscounted
fn wl_i32_load8_u_real_len() -> i32 { return 11; }
fn wl_br_if_1_real_len() -> i32 { return 7; }
fn wl_data_prefix_real_len() -> i32 { return 17; }
fn wl_export_start_real_ptr() -> i32 { return wat_lit_base() + 496; }
fn wl_export_start_real_len() -> i32 { return 32; }
fn wl_memory_export_real_len() -> i32 { return 28; }

// ---------------------------------------------------------------------------
// State: feature flags, string table, locals table, fn names
// ---------------------------------------------------------------------------

fn is_v1_addr() -> i32 { return state_base() + 8412; }

fn feat_fd_write_addr() -> i32 { return state_base() + 8416; }
fn feat_fd_read_addr() -> i32 { return state_base() + 8420; }
fn feat_fd_close_addr() -> i32 { return state_base() + 8424; }
fn feat_path_open_addr() -> i32 { return state_base() + 8428; }
fn feat_tty_mode_addr() -> i32 { return state_base() + 8432; }

fn reset_features() -> i32 {
  __mem_store(feat_fd_write_addr(), 0);
  __mem_store(feat_fd_read_addr(), 0);
  __mem_store(feat_fd_close_addr(), 0);
  __mem_store(feat_path_open_addr(), 0);
  __mem_store(feat_tty_mode_addr(), 0);
  return 0;
}

// String table: array of (atom_off, atom_len, data_addr)
// Up to 256 strings
fn str_table_base() -> i32 { return 9437184; }  // 9MB
fn str_table_entry_size() -> i32 { return 12; }
fn str_count_addr() -> i32 { return state_base() + 8440; }
fn str_next_data_addr_addr() -> i32 { return state_base() + 8444; }

fn str_entry_addr(i: i32) -> i32 { return str_table_base() + i * str_table_entry_size(); }

fn reset_str_table() -> i32 {
  __mem_store(str_count_addr(), 0);
  __mem_store(str_next_data_addr_addr(), 1024);
  return 0;
}

fn str_table_find(atom_off: i32, atom_len: i32) -> i32 {
  let count: i32 = __mem_load(str_count_addr());
  let i: i32 = 0;
  while (i < count) {
    let entry: i32 = str_entry_addr(i);
    let eo: i32 = __mem_load(entry);
    let el: i32 = __mem_load(entry + 4);
    if (el == atom_len) {
      let match: i32 = 1;
      let j: i32 = 0;
      while (j < el && match == 1) {
        if (__mem_load8(ir_buf_base() + eo + j) != __mem_load8(ir_buf_base() + atom_off + j)) {
          match = 0;
        }
        j = j + 1;
      }
      if (match == 1) { return i; }
    }
    i = i + 1;
  }
  return 0 - 1;
}

fn str_table_add(atom_off: i32, atom_len: i32) -> i32 {
  let existing: i32 = str_table_find(atom_off, atom_len);
  if (existing >= 0) { return existing; }
  let count: i32 = __mem_load(str_count_addr());
  if (count >= 256) { return 0 - 1; }
  let data_addr: i32 = __mem_load(str_next_data_addr_addr());
  let entry: i32 = str_entry_addr(count);
  __mem_store(entry, atom_off);
  __mem_store(entry + 4, atom_len);
  __mem_store(entry + 8, data_addr);

  // Compute decoded length: walk the string token (with quotes)
  // The atom includes quotes: "..."
  let decoded_len: i32 = decode_str_len(atom_off, atom_len);
  let next_addr: i32 = data_addr + decoded_len;
  // Align to 4
  let rem: i32 = next_addr - (next_addr / 4) * 4;
  if (rem != 0) { next_addr = next_addr + 4 - rem; }
  __mem_store(str_next_data_addr_addr(), next_addr);
  __mem_store(str_count_addr(), count + 1);
  return count;
}

fn decode_str_len(atom_off: i32, atom_len: i32) -> i32 {
  // The atom is like "hello\nworld" including quotes
  let len: i32 = 0;
  let i: i32 = 1;
  let end: i32 = atom_len - 1;
  while (i < end) {
    let c: i32 = __mem_load8(ir_buf_base() + atom_off + i);
    if (c == 92) {
      // backslash escape - counts as one byte
      i = i + 2;
    } else {
      i = i + 1;
    }
    len = len + 1;
  }
  return len;
}

fn str_data_addr(idx: i32) -> i32 {
  return __mem_load(str_entry_addr(idx) + 8);
}

// Locals table: per-function, up to 128 locals
// Each entry is (atom_off, atom_len, wasm_type) - 12 bytes
fn locals_table_base() -> i32 { return 9441280; }  // str_table_base + 4096
fn locals_entry_size() -> i32 { return 16; }
fn locals_count_addr() -> i32 { return state_base() + 8448; }
fn locals_param_count_addr() -> i32 { return state_base() + 8452; }

fn locals_entry_addr(i: i32) -> i32 { return locals_table_base() + i * locals_entry_size(); }

// Wasm type codes
fn wasm_type_i32() -> i32 { return 1; }
fn wasm_type_i64() -> i32 { return 2; }
fn wasm_type_f32() -> i32 { return 3; }
fn wasm_type_f64() -> i32 { return 4; }
fn wasm_type_struct() -> i32 { return 5; }

fn reset_locals() -> i32 {
  __mem_store(locals_count_addr(), 0);
  __mem_store(locals_param_count_addr(), 0);
  return 0;
}

fn add_local(atom_off: i32, atom_len: i32) -> i32 {
  return add_local_with_type(atom_off, atom_len, wasm_type_i32());
}

fn add_local_with_type(atom_off: i32, atom_len: i32, wasm_type: i32) -> i32 {
  return add_local_with_type_and_sidx(atom_off, atom_len, wasm_type, 0 - 1);
}

fn add_local_with_type_and_sidx(atom_off: i32, atom_len: i32, wasm_type: i32, sidx: i32) -> i32 {
  let count: i32 = __mem_load(locals_count_addr());
  // Check for duplicates
  let i: i32 = 0;
  while (i < count) {
    let entry: i32 = locals_entry_addr(i);
    let eo: i32 = __mem_load(entry);
    let el: i32 = __mem_load(entry + 4);
    if (el == atom_len) {
      let match: i32 = 1;
      let j: i32 = 0;
      while (j < el && match == 1) {
        if (__mem_load8(ir_buf_base() + eo + j) != __mem_load8(ir_buf_base() + atom_off + j)) {
          match = 0;
        }
        j = j + 1;
      }
      if (match == 1) { return i; }
    }
    i = i + 1;
  }
  if (count >= 256) { return 0 - 1; }
  let entry: i32 = locals_entry_addr(count);
  __mem_store(entry, atom_off);
  __mem_store(entry + 4, atom_len);
  __mem_store(entry + 8, wasm_type);
  __mem_store(entry + 12, sidx);
  __mem_store(locals_count_addr(), count + 1);
  return count;
}

fn local_wasm_type(idx: i32) -> i32 {
  let wt: i32 = __mem_load(locals_entry_addr(idx) + 8);
  if (wt == wasm_type_struct()) { return wasm_type_i32(); }
  return wt;
}

fn local_sidx(idx: i32) -> i32 {
  return __mem_load(locals_entry_addr(idx) + 12);
}

fn find_sidx_for_var(var_name_node: i32) -> i32 {
  let idx: i32 = local_index(var_name_node);
  if (idx < 0) { return 0 - 1; }
  return local_sidx(idx);
}

fn ir_type_to_wasm(type_node: i32) -> i32 {
  // Map IR type atom to wasm type code
  if (atom_equals(type_node, literal_i32_ptr(), literal_i32_len()) == 1) { return wasm_type_i32(); }
  if (atom_equals(type_node, literal_bool_ptr(), literal_bool_len()) == 1) { return wasm_type_i32(); }
  if (atom_equals(type_node, literal_i64_ptr(), literal_i64_len()) == 1) { return wasm_type_i64(); }
  if (atom_equals(type_node, literal_f32_ptr(), literal_f32_len()) == 1) { return wasm_type_f32(); }
  if (atom_equals(type_node, literal_f64_ptr(), literal_f64_len()) == 1) { return wasm_type_f64(); }
  if (atom_equals(type_node, literal_str_type_ptr(), literal_str_type_len()) == 1) { return wasm_type_i32(); }
  
  if (find_struct_by_name(type_node) >= 0) { return wasm_type_struct(); }
  return wasm_type_i32(); // default
}

fn local_index(name_node: i32) -> i32 {
  let ao: i32 = node_atom_off(name_node);
  let al: i32 = node_atom_len(name_node);
  let count: i32 = __mem_load(locals_count_addr());
  let i: i32 = 0;
  while (i < count) {
    let entry: i32 = locals_entry_addr(i);
    let eo: i32 = __mem_load(entry);
    let el: i32 = __mem_load(entry + 4);
    if (el == al) {
      let match: i32 = 1;
      let j: i32 = 0;
      while (j < el && match == 1) {
        if (__mem_load8(ir_buf_base() + eo + j) != __mem_load8(ir_buf_base() + ao + j)) {
          match = 0;
        }
        j = j + 1;
      }
      if (match == 1) { return i; }
    }
    i = i + 1;
  }
  return 0 - 1;
}

// Function names table: up to 256 functions
fn fn_names_base() -> i32 { return 9445376; }  // locals_table_base + 4096
fn fn_names_entry_size() -> i32 { return 8; }
fn fn_names_count_addr() -> i32 { return state_base() + 8456; }

fn fn_names_entry_addr(i: i32) -> i32 { return fn_names_base() + i * fn_names_entry_size(); }

fn reset_fn_names() -> i32 {
  __mem_store(fn_names_count_addr(), 0);
  return 0;
}

fn add_fn_name(atom_off: i32, atom_len: i32) -> i32 {
  let count: i32 = __mem_load(fn_names_count_addr());
  if (count >= 1024) { return 0 - 1; }
  let entry: i32 = fn_names_entry_addr(count);
  __mem_store(entry, atom_off);
  __mem_store(entry + 4, atom_len);
  __mem_store(fn_names_count_addr(), count + 1);
  return count;
}

fn is_known_fn(name_node: i32) -> i32 {
  let ao: i32 = node_atom_off(name_node);
  let al: i32 = node_atom_len(name_node);
  let count: i32 = __mem_load(fn_names_count_addr());
  let i: i32 = 0;
  while (i < count) {
    let entry: i32 = fn_names_entry_addr(i);
    let eo: i32 = __mem_load(entry);
    let el: i32 = __mem_load(entry + 4);
    if (el == al) {
      let match: i32 = 1;
      let j: i32 = 0;
      while (j < el && match == 1) {
        if (__mem_load8(ir_buf_base() + eo + j) != __mem_load8(ir_buf_base() + ao + j)) {
          match = 0;
        }
        j = j + 1;
      }
      if (match == 1) { return 1; }
    }
    i = i + 1;
  }
  return 0;
}

// ---------------------------------------------------------------------------
// Tree helpers
// ---------------------------------------------------------------------------

fn list_child_at(node: i32, idx: i32) -> i32 {
  let c: i32 = node_child_head(node);
  let i: i32 = 0;
  while (i < idx && c != 0) {
    c = node_next(c);
    i = i + 1;
  }
  return c;
}

fn list_child_count(node: i32) -> i32 {
  let c: i32 = node_child_head(node);
  let n: i32 = 0;
  while (c != 0) {
    n = n + 1;
    c = node_next(c);
  }
  return n;
}

fn child_tag_equals(node: i32, ptr: i32, len: i32) -> i32 {
  let first: i32 = list_child_at(node, 0);
  if (first == 0) { return 0; }
  return atom_equals(first, ptr, len);
}

// ---------------------------------------------------------------------------
// Feature collection
// ---------------------------------------------------------------------------

fn collect_features_expr(node: i32) -> i32 {
  if (node_kind(node) != 1) { return 0; }
  let tag: i32 = list_child_at(node, 0);
  if (tag == 0) { return 0; }

  if (atom_equals(tag, literal_call_ptr(), literal_call_len()) == 1) {
    let callee: i32 = list_child_at(node, 1);
    if (callee != 0) {
      if (atom_equals(callee, literal_fd_write_ptr(), literal_fd_write_len()) == 1) {
        __mem_store(feat_fd_write_addr(), 1);
      }
      if (atom_equals(callee, literal_fd_read_ptr(), literal_fd_read_len()) == 1) {
        __mem_store(feat_fd_read_addr(), 1);
      }
      if (atom_equals(callee, literal_fd_close_ptr(), literal_fd_close_len()) == 1) {
        __mem_store(feat_fd_close_addr(), 1);
      }
      if (atom_equals(callee, literal_path_open_ptr(), literal_path_open_len()) == 1) {
        __mem_store(feat_path_open_addr(), 1);
      }
      if (atom_equals(callee, literal_tty_get_mode_ptr(), literal_tty_get_mode_len()) == 1) {
        __mem_store(feat_tty_mode_addr(), 1);
      }
      if (atom_equals(callee, literal_tty_set_raw_ptr(), literal_tty_set_raw_len()) == 1) {
        __mem_store(feat_tty_mode_addr(), 1);
      }
      if (atom_equals(callee, literal_tty_restore_ptr(), literal_tty_restore_len()) == 1) {
        __mem_store(feat_tty_mode_addr(), 1);
      }
    }
    // Recurse into args
    let arg: i32 = list_child_at(node, 2);
    while (arg != 0) {
      collect_features_expr(arg);
      arg = node_next(arg);
    }
  } else {
    if (atom_equals(tag, literal_binary_ptr(), literal_binary_len()) == 1) {
      // v0: (binary op lhs rhs) - 4 children
      // v1: (binary op type lhs rhs) - 5 children  OR (binary op lhs rhs) - 4 children
      let nchildren: i32 = list_child_count(node);
      if (nchildren >= 5) {
        collect_features_expr(list_child_at(node, 3));
        collect_features_expr(list_child_at(node, 4));
      } else {
        collect_features_expr(list_child_at(node, 2));
        collect_features_expr(list_child_at(node, 3));
      }
    }
    if (atom_equals(tag, wl_unary_ptr(), wl_unary_len()) == 1) {
      collect_features_expr(list_child_at(node, 2));
    }
  }
  return 0;
}

fn collect_features_block(node: i32) -> i32 {
  let stmt: i32 = node_next(list_child_at(node, 0));
  while (stmt != 0) {
    let s_tag: i32 = list_child_at(stmt, 0);
    if (s_tag != 0) {
      if (atom_equals(s_tag, literal_let_ptr(), literal_let_len()) == 1) {
        collect_features_expr(list_child_at(stmt, 3));
      }
      if (atom_equals(s_tag, literal_assign_ptr(), literal_assign_len()) == 1) {
        collect_features_expr(list_child_at(stmt, 2));
      }
      if (atom_equals(s_tag, literal_return_ptr(), literal_return_len()) == 1) {
        collect_features_expr(list_child_at(stmt, 1));
      }
      if (atom_equals(s_tag, literal_expr_ptr(), literal_expr_len()) == 1) {
        collect_features_expr(list_child_at(stmt, 1));
      }
      if (atom_equals(s_tag, literal_if_ptr(), literal_if_len()) == 1) {
        collect_features_expr(list_child_at(stmt, 1));
        collect_features_block(list_child_at(stmt, 2));
        let else_node: i32 = list_child_at(stmt, 3);
        if (else_node != 0) {
          if (child_tag_equals(else_node, literal_else_ptr(), literal_else_len()) == 1) {
            collect_features_block(list_child_at(else_node, 1));
          }
        }
      }
      if (atom_equals(s_tag, literal_while_ptr(), literal_while_len()) == 1) {
        collect_features_expr(list_child_at(stmt, 1));
        collect_features_block(list_child_at(stmt, 2));
      }
    }
    stmt = node_next(stmt);
  }
  return 0;
}

// ---------------------------------------------------------------------------
// String literal collection
// ---------------------------------------------------------------------------

fn collect_strings_expr(node: i32) -> i32 {
  if (node_kind(node) != 1) { return 0; }
  let tag: i32 = list_child_at(node, 0);
  if (tag == 0) { return 0; }

  if (atom_equals(tag, literal_string_ptr(), literal_string_len()) == 1) {
    let str_tok: i32 = list_child_at(node, 1);
    if (str_tok != 0) {
      str_table_add(node_atom_off(str_tok), node_atom_len(str_tok));
    }
    return 0;
  }
  if (atom_equals(tag, literal_string_typed_ptr(), literal_string_typed_len()) == 1) {
    let str_tok: i32 = list_child_at(node, 1);
    if (str_tok != 0) {
      str_table_add(node_atom_off(str_tok), node_atom_len(str_tok));
    }
    return 0;
  }
  if (atom_equals(tag, literal_binary_ptr(), literal_binary_len()) == 1) {
    let nchildren: i32 = list_child_count(node);
    if (nchildren >= 5) {
      collect_strings_expr(list_child_at(node, 3));
      collect_strings_expr(list_child_at(node, 4));
    } else {
      collect_strings_expr(list_child_at(node, 2));
      collect_strings_expr(list_child_at(node, 3));
    }
    return 0;
  }
  if (atom_equals(tag, wl_unary_ptr(), wl_unary_len()) == 1) {
    collect_strings_expr(list_child_at(node, 2));
    return 0;
  }
  if (atom_equals(tag, literal_call_ptr(), literal_call_len()) == 1) {
    let arg: i32 = list_child_at(node, 2);
    while (arg != 0) {
      collect_strings_expr(arg);
      arg = node_next(arg);
    }
    return 0;
  }
  // str_len and str_ptr have one child expr at position 1
  if (atom_equals(tag, literal_str_len_fn_ptr(), literal_str_len_fn_len()) == 1) {
    collect_strings_expr(list_child_at(node, 1));
    return 0;
  }
  if (atom_equals(tag, literal_str_ptr_fn_ptr(), literal_str_ptr_fn_len()) == 1) {
    collect_strings_expr(list_child_at(node, 1));
    return 0;
  }
  return 0;
}

fn collect_strings_block(node: i32) -> i32 {
  let stmt: i32 = node_next(list_child_at(node, 0));
  while (stmt != 0) {
    let s_tag: i32 = list_child_at(stmt, 0);
    if (s_tag != 0) {
      if (atom_equals(s_tag, literal_let_ptr(), literal_let_len()) == 1) {
        collect_strings_expr(list_child_at(stmt, 3));
      }
      if (atom_equals(s_tag, literal_assign_ptr(), literal_assign_len()) == 1) {
        collect_strings_expr(list_child_at(stmt, 2));
      }
      if (atom_equals(s_tag, literal_return_ptr(), literal_return_len()) == 1) {
        collect_strings_expr(list_child_at(stmt, 1));
      }
      if (atom_equals(s_tag, literal_expr_ptr(), literal_expr_len()) == 1) {
        collect_strings_expr(list_child_at(stmt, 1));
      }
      if (atom_equals(s_tag, literal_if_ptr(), literal_if_len()) == 1) {
        collect_strings_expr(list_child_at(stmt, 1));
        collect_strings_block(list_child_at(stmt, 2));
        let else_node: i32 = list_child_at(stmt, 3);
        if (else_node != 0) {
          if (child_tag_equals(else_node, literal_else_ptr(), literal_else_len()) == 1) {
            collect_strings_block(list_child_at(else_node, 1));
          }
        }
      }
      if (atom_equals(s_tag, literal_while_ptr(), literal_while_len()) == 1) {
        collect_strings_expr(list_child_at(stmt, 1));
        collect_strings_block(list_child_at(stmt, 2));
      }
    }
    stmt = node_next(stmt);
  }
  return 0;
}

// ---------------------------------------------------------------------------
// Local variable collection
// ---------------------------------------------------------------------------

fn collect_locals_block(node: i32) -> i32 {
  let stmt: i32 = node_next(list_child_at(node, 0));
  while (stmt != 0) {
    let s_tag: i32 = list_child_at(stmt, 0);
    if (s_tag != 0) {
      if (atom_equals(s_tag, literal_let_ptr(), literal_let_len()) == 1) {
        let name: i32 = list_child_at(stmt, 1);
        let wt: i32 = wasm_type_i32();
        let sidx: i32 = 0 - 1;
        if (__mem_load(is_v1_addr()) == 1) {
          let type_node: i32 = list_child_at(stmt, 2);
          if (type_node != 0) {
            wt = ir_type_to_wasm(type_node);
            if (wt == wasm_type_struct()) { sidx = find_struct_by_name(type_node); }
          }
        }
        add_local_with_type_and_sidx(node_atom_off(name), node_atom_len(name), wt, sidx);
      }
      if (atom_equals(s_tag, literal_if_ptr(), literal_if_len()) == 1) {
        collect_locals_block(list_child_at(stmt, 2));
        let else_node: i32 = list_child_at(stmt, 3);
        if (else_node != 0) {
          if (child_tag_equals(else_node, literal_else_ptr(), literal_else_len()) == 1) {
            collect_locals_block(list_child_at(else_node, 1));
          }
        }
      }
      if (atom_equals(s_tag, literal_while_ptr(), literal_while_len()) == 1) {
        collect_locals_block(list_child_at(stmt, 2));
      }
    }
    stmt = node_next(stmt);
  }
  return 0;
}

// ---------------------------------------------------------------------------
// WAT output helpers
// ---------------------------------------------------------------------------

fn emit_wat_line(indent: i32, ptr: i32, len: i32) -> i32 {
  out_spaces(indent);
  out_str(ptr, len);
  return out_nl();
}

fn emit_wat_opcode(ptr: i32, len: i32) -> i32 {
  out_spaces(4);
  out_str(ptr, len);
  return out_nl();
}

// ---------------------------------------------------------------------------
// Expression emitter
// ---------------------------------------------------------------------------

fn parse_int_from_atom(off: i32, len: i32) -> i32 {
  let val: i32 = 0;
  let i: i32 = 0;
  while (i < len) {
    let c: i32 = __mem_load8(ir_buf_base() + off + i);
    val = val * 10 + c - 48;
    i = i + 1;
  }
  return val;
}

fn emit_typed_binop(op: i32, wt: i32) -> i32 {
  if (wt == wasm_type_i64()) {
    if (atom_equals(op, literal_add_ptr(), literal_add_len()) == 1) { emit_wat_opcode(wl_i64_add_ptr(), wl_i64_add_len()); return 0; }
    if (atom_equals(op, literal_sub_ptr(), literal_sub_len()) == 1) { emit_wat_opcode(wl_i64_sub_ptr(), wl_i64_sub_len()); return 0; }
    if (atom_equals(op, literal_mul_ptr(), literal_mul_len()) == 1) { emit_wat_opcode(wl_i64_mul_ptr(), wl_i64_mul_len()); return 0; }
    if (atom_equals(op, literal_div_ptr(), literal_div_len()) == 1) { emit_wat_opcode(wl_i64_div_s_ptr(), wl_i64_div_s_len()); return 0; }
    if (atom_equals(op, literal_eq_ptr(), literal_eq_len()) == 1) { emit_wat_opcode(wl_i64_eq_ptr(), wl_i64_eq_len()); return 0; }
    if (atom_equals(op, literal_ne_ptr(), literal_ne_len()) == 1) { emit_wat_opcode(wl_i64_ne_ptr(), wl_i64_ne_len()); return 0; }
    if (atom_equals(op, literal_lt_ptr(), literal_lt_len()) == 1) { emit_wat_opcode(wl_i64_lt_s_ptr(), wl_i64_lt_s_len()); return 0; }
    if (atom_equals(op, literal_gt_ptr(), literal_gt_len()) == 1) { emit_wat_opcode(wl_i64_gt_s_ptr(), wl_i64_gt_s_len()); return 0; }
    if (atom_equals(op, literal_le_ptr(), literal_le_len()) == 1) { emit_wat_opcode(wl_i64_le_s_ptr(), wl_i64_le_s_len()); return 0; }
    if (atom_equals(op, literal_ge_ptr(), literal_ge_len()) == 1) { emit_wat_opcode(wl_i64_ge_s_ptr(), wl_i64_ge_s_len()); return 0; }
    return 0 - 121;
  }
  if (wt == wasm_type_f32()) {
    if (atom_equals(op, literal_add_ptr(), literal_add_len()) == 1) { emit_wat_opcode(wl_f32_add_ptr(), wl_f32_add_len()); return 0; }
    if (atom_equals(op, literal_sub_ptr(), literal_sub_len()) == 1) { emit_wat_opcode(wl_f32_sub_ptr(), wl_f32_sub_len()); return 0; }
    if (atom_equals(op, literal_mul_ptr(), literal_mul_len()) == 1) { emit_wat_opcode(wl_f32_mul_ptr(), wl_f32_mul_len()); return 0; }
    if (atom_equals(op, literal_div_ptr(), literal_div_len()) == 1) { emit_wat_opcode(wl_f32_div_ptr(), wl_f32_div_len()); return 0; }
    if (atom_equals(op, literal_eq_ptr(), literal_eq_len()) == 1) { emit_wat_opcode(wl_f32_eq_ptr(), wl_f32_eq_len()); return 0; }
    if (atom_equals(op, literal_ne_ptr(), literal_ne_len()) == 1) { emit_wat_opcode(wl_f32_ne_ptr(), wl_f32_ne_len()); return 0; }
    if (atom_equals(op, literal_lt_ptr(), literal_lt_len()) == 1) { emit_wat_opcode(wl_f32_lt_ptr(), wl_f32_lt_len()); return 0; }
    if (atom_equals(op, literal_gt_ptr(), literal_gt_len()) == 1) { emit_wat_opcode(wl_f32_gt_ptr(), wl_f32_gt_len()); return 0; }
    if (atom_equals(op, literal_le_ptr(), literal_le_len()) == 1) { emit_wat_opcode(wl_f32_le_ptr(), wl_f32_le_len()); return 0; }
    if (atom_equals(op, literal_ge_ptr(), literal_ge_len()) == 1) { emit_wat_opcode(wl_f32_ge_ptr(), wl_f32_ge_len()); return 0; }
    return 0 - 122;
  }
  if (wt == wasm_type_f64()) {
    if (atom_equals(op, literal_add_ptr(), literal_add_len()) == 1) { emit_wat_opcode(wl_f64_add_ptr(), wl_f64_add_len()); return 0; }
    if (atom_equals(op, literal_sub_ptr(), literal_sub_len()) == 1) { emit_wat_opcode(wl_f64_sub_ptr(), wl_f64_sub_len()); return 0; }
    if (atom_equals(op, literal_mul_ptr(), literal_mul_len()) == 1) { emit_wat_opcode(wl_f64_mul_ptr(), wl_f64_mul_len()); return 0; }
    if (atom_equals(op, literal_div_ptr(), literal_div_len()) == 1) { emit_wat_opcode(wl_f64_div_ptr(), wl_f64_div_len()); return 0; }
    if (atom_equals(op, literal_eq_ptr(), literal_eq_len()) == 1) { emit_wat_opcode(wl_f64_eq_ptr(), wl_f64_eq_len()); return 0; }
    if (atom_equals(op, literal_ne_ptr(), literal_ne_len()) == 1) { emit_wat_opcode(wl_f64_ne_ptr(), wl_f64_ne_len()); return 0; }
    if (atom_equals(op, literal_lt_ptr(), literal_lt_len()) == 1) { emit_wat_opcode(wl_f64_lt_ptr(), wl_f64_lt_len()); return 0; }
    if (atom_equals(op, literal_gt_ptr(), literal_gt_len()) == 1) { emit_wat_opcode(wl_f64_gt_ptr(), wl_f64_gt_len()); return 0; }
    if (atom_equals(op, literal_le_ptr(), literal_le_len()) == 1) { emit_wat_opcode(wl_f64_le_ptr(), wl_f64_le_len()); return 0; }
    if (atom_equals(op, literal_ge_ptr(), literal_ge_len()) == 1) { emit_wat_opcode(wl_f64_ge_ptr(), wl_f64_ge_len()); return 0; }
    return 0 - 123;
  }
  // Default: i32
  if (atom_equals(op, literal_add_ptr(), literal_add_len()) == 1) { emit_wat_opcode(wl_i32_add_ptr(), wl_i32_add_len()); return 0; }
  if (atom_equals(op, literal_sub_ptr(), literal_sub_len()) == 1) { emit_wat_opcode(wl_i32_sub_ptr(), wl_i32_sub_len()); return 0; }
  if (atom_equals(op, literal_mul_ptr(), literal_mul_len()) == 1) { emit_wat_opcode(wl_i32_mul_ptr(), wl_i32_mul_len()); return 0; }
  if (atom_equals(op, literal_div_ptr(), literal_div_len()) == 1) { emit_wat_opcode(wl_i32_div_s_ptr(), wl_i32_div_s_len()); return 0; }
  if (atom_equals(op, literal_eq_ptr(), literal_eq_len()) == 1) { emit_wat_opcode(wl_i32_eq_ptr(), wl_i32_eq_len()); return 0; }
  if (atom_equals(op, literal_ne_ptr(), literal_ne_len()) == 1) { emit_wat_opcode(wl_i32_ne_ptr(), wl_i32_ne_len()); return 0; }
  if (atom_equals(op, literal_lt_ptr(), literal_lt_len()) == 1) { emit_wat_opcode(wl_i32_lt_s_ptr(), wl_i32_lt_s_len()); return 0; }
  if (atom_equals(op, literal_gt_ptr(), literal_gt_len()) == 1) { emit_wat_opcode(wl_i32_gt_s_ptr(), wl_i32_gt_s_len()); return 0; }
  if (atom_equals(op, literal_le_ptr(), literal_le_len()) == 1) { emit_wat_opcode(wl_i32_le_s_ptr(), wl_i32_le_s_len()); return 0; }
  if (atom_equals(op, literal_ge_ptr(), literal_ge_len()) == 1) { emit_wat_opcode(wl_i32_ge_s_ptr(), wl_i32_ge_s_len()); return 0; }
  if (atom_equals(op, literal_and_ptr(), literal_and_len()) == 1) { emit_wat_opcode(wl_i32_and_ptr(), wl_i32_and_len()); return 0; }
  if (atom_equals(op, literal_or_ptr(), literal_or_len()) == 1) { emit_wat_opcode(wl_i32_or_ptr(), wl_i32_or_len()); return 0; }
  return 0 - 120;
}

fn emit_expr(node: i32) -> i32 {
  if (node == 0) { return 0 - 100; }
  if (node_kind(node) != 1) { return 0 - 101; }
  let tag: i32 = list_child_at(node, 0);
  if (tag == 0) { return 0 - 102; }

  // (int N)
  if (atom_equals(tag, literal_int_ptr(), literal_int_len()) == 1) {
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_atom(list_child_at(node, 1));
    out_nl();
    return 0;
  }

  // (bool N)
  if (atom_equals(tag, literal_bool_ptr(), literal_bool_len()) == 1) {
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_atom(list_child_at(node, 1));
    out_nl();
    return 0;
  }

  // (int_i64 N)
  if (atom_equals(tag, literal_int_i64_ptr(), literal_int_i64_len()) == 1) {
    out_spaces(4);
    out_str(wl_i64_const_ptr(), wl_i64_const_len());
    out_atom(list_child_at(node, 1));
    out_nl();
    return 0;
  }

  // (float_f32 N)
  if (atom_equals(tag, literal_float_f32_ptr(), literal_float_f32_len()) == 1) {
    out_spaces(4);
    out_str(wl_f32_const_ptr(), wl_f32_const_len());
    out_atom(list_child_at(node, 1));
    out_nl();
    return 0;
  }

  // (float_f64 N)
  if (atom_equals(tag, literal_float_f64_ptr(), literal_float_f64_len()) == 1) {
    out_spaces(4);
    out_str(wl_f64_const_ptr(), wl_f64_const_len());
    out_atom(list_child_at(node, 1));
    out_nl();
    return 0;
  }

  // (array_alloc T N)
  if (atom_equals(tag, literal_array_alloc_ptr(), literal_array_alloc_len()) == 1) {
    // child 1 = elem type atom, child 2 = size atom
    let elem_type: i32 = list_child_at(node, 1);
    let size_node: i32 = list_child_at(node, 2);
    let elem_wt: i32 = ir_type_to_wasm(elem_type);
    let elem_sz: i32 = 4;
    if (elem_wt == wasm_type_i64()) { elem_sz = 8; }
    if (elem_wt == wasm_type_f64()) { elem_sz = 8; }
    // Read heap pointer
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_int(__mem_load(heap_ptr_addr()));
    out_nl();
    // Compute total bytes = N * elem_sz
    // Parse N from atom
    let n_off: i32 = node_atom_off(size_node);
    let n_len: i32 = node_atom_len(size_node);
    let n_val: i32 = parse_int_from_atom(n_off, n_len);
    let total: i32 = n_val * elem_sz;
    // Advance heap pointer
    __mem_store(heap_ptr_addr(), __mem_load(heap_ptr_addr()) + total);
    return 0;
  }

  // (array_get T base index)
  if (atom_equals(tag, literal_array_get_ptr(), literal_array_get_len()) == 1) {
    let elem_type: i32 = list_child_at(node, 1);
    let base_expr: i32 = list_child_at(node, 2);
    let index_expr: i32 = list_child_at(node, 3);
    let elem_wt: i32 = ir_type_to_wasm(elem_type);
    let elem_sz: i32 = 4;
    if (elem_wt == wasm_type_i64()) { elem_sz = 8; }
    if (elem_wt == wasm_type_f64()) { elem_sz = 8; }
    // Compute address: base + index * elem_sz
    emit_expr(base_expr);
    emit_expr(index_expr);
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_int(elem_sz);
    out_nl();
    emit_wat_opcode(wl_i32_mul_ptr(), wl_i32_mul_len());
    emit_wat_opcode(wl_i32_add_ptr(), wl_i32_add_len());
    // Load value
    if (elem_wt == wasm_type_i64()) {
      // i64.load
      out_spaces(4);
      out_str(wl_i64_const_ptr(), 3); // "i64"
      out_char(46); out_char(108); out_char(111); out_char(97); out_char(100); // ".load"
      out_nl();
    } else {
      if (elem_wt == wasm_type_f32()) {
        out_spaces(4);
        out_str(wl_f32_const_ptr(), 3); // "f32"
        out_char(46); out_char(108); out_char(111); out_char(97); out_char(100);
        out_nl();
      } else {
        if (elem_wt == wasm_type_f64()) {
          out_spaces(4);
          out_str(wl_f64_const_ptr(), 3); // "f64"
          out_char(46); out_char(108); out_char(111); out_char(97); out_char(100);
          out_nl();
        } else {
          emit_wat_opcode(wl_i32_load_ptr(), wl_i32_load_len());
        }
      }
    }
    return 0;
  }

  // (array_set T base index val)
  if (atom_equals(tag, literal_array_set_ptr(), literal_array_set_len()) == 1) {
    let elem_type: i32 = list_child_at(node, 1);
    let base_expr: i32 = list_child_at(node, 2);
    let index_expr: i32 = list_child_at(node, 3);
    let val_expr: i32 = list_child_at(node, 4);
    let elem_wt: i32 = ir_type_to_wasm(elem_type);
    let elem_sz: i32 = 4;
    if (elem_wt == wasm_type_i64()) { elem_sz = 8; }
    if (elem_wt == wasm_type_f64()) { elem_sz = 8; }
    // Compute address: base + index * elem_sz
    emit_expr(base_expr);
    emit_expr(index_expr);
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_int(elem_sz);
    out_nl();
    emit_wat_opcode(wl_i32_mul_ptr(), wl_i32_mul_len());
    emit_wat_opcode(wl_i32_add_ptr(), wl_i32_add_len());
    // Push value
    emit_expr(val_expr);
    // Store value
    if (elem_wt == wasm_type_i64()) {
      out_spaces(4);
      out_str(wl_i64_const_ptr(), 3);
      out_char(46); out_char(115); out_char(116); out_char(111); out_char(114); out_char(101); // ".store"
      out_nl();
    } else {
      if (elem_wt == wasm_type_f32()) {
        out_spaces(4);
        out_str(wl_f32_const_ptr(), 3);
        out_char(46); out_char(115); out_char(116); out_char(111); out_char(114); out_char(101);
        out_nl();
      } else {
        if (elem_wt == wasm_type_f64()) {
          out_spaces(4);
          out_str(wl_f64_const_ptr(), 3);
          out_char(46); out_char(115); out_char(116); out_char(111); out_char(114); out_char(101);
          out_nl();
        } else {
          emit_wat_opcode(wl_i32_store_ptr(), wl_i32_store_len());
        }
      }
    }
    // Return 0
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_char(48);
    out_nl();
    return 0;
  }

  // (ident name)
  if (atom_equals(tag, literal_ident_ptr(), literal_ident_len()) == 1) {
    let idx: i32 = local_index(list_child_at(node, 1));
    if (idx < 0) { return 0 - 110; }
    out_spaces(4);
    out_str(wl_local_get_ptr(), wl_local_get_len());
    out_int(idx);
    out_nl();
    return 0;
  }

  // (string "...")
  if (atom_equals(tag, literal_string_ptr(), literal_string_len()) == 1) {
    let str_tok: i32 = list_child_at(node, 1);
    let si: i32 = str_table_find(node_atom_off(str_tok), node_atom_len(str_tok));
    if (si < 0) { return 0 - 111; }
    let addr: i32 = str_data_addr(si);
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_int(addr);
    out_nl();
    return 0;
  }

  // (string_typed "...") - returns data segment pointer for the string
  if (atom_equals(tag, literal_string_typed_ptr(), literal_string_typed_len()) == 1) {
    let str_tok: i32 = list_child_at(node, 1);
    let si: i32 = str_table_find(node_atom_off(str_tok), node_atom_len(str_tok));
    if (si < 0) { return 0 - 111; }
    let data_addr: i32 = str_data_addr(si);
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_int(data_addr);
    out_nl();
    return 0;
  }

  // (str_len expr) - load length from str header (offset 4)
  if (atom_equals(tag, literal_str_len_fn_ptr(), literal_str_len_fn_len()) == 1) {
    emit_expr(list_child_at(node, 1));
    // Emit: i32.load offset=4
    out_spaces(4);
    out_str(wl_i32_load_ptr(), wl_i32_load_len()); // "i32.load"
    out_char(32); // ' '
    // "offset=4"
    out_char(111); out_char(102); out_char(102); out_char(115); // "offs"
    out_char(101); out_char(116); out_char(61); out_char(52);   // "et=4"
    out_nl();
    return 0;
  }

  // (str_ptr expr) - load pointer from str header (offset 0)
  if (atom_equals(tag, literal_str_ptr_fn_ptr(), literal_str_ptr_fn_len()) == 1) {
    emit_expr(list_child_at(node, 1));
    emit_wat_opcode(wl_i32_load_ptr(), wl_i32_load_len());
    return 0;
  }

  // (binary op [type] lhs rhs)
  // v0: (binary op lhs rhs) - children: tag, op, lhs, rhs
  // v1: (binary op type lhs rhs) - children: tag, op, type, lhs, rhs  (when type present)
  // v1: (binary op lhs rhs) - children: tag, op, lhs, rhs  (default i32)
  if (atom_equals(tag, literal_binary_ptr(), literal_binary_len()) == 1) {
    let op: i32 = list_child_at(node, 1);
    let wt: i32 = wasm_type_i32();
    let lhs: i32 = 0;
    let rhs: i32 = 0;
    // In v1, check if child 2 is a type atom (i32/i64/f32/f64/bool)
    if (__mem_load(is_v1_addr()) == 1) {
      let child2: i32 = list_child_at(node, 2);
      let is_type: i32 = 0;
      if (child2 != 0 && node_kind(child2) == 0) {
        // It's an atom - check if it matches a known type
        if (atom_equals(child2, literal_i32_ptr(), literal_i32_len()) == 1) { is_type = 1; wt = wasm_type_i32(); }
        if (atom_equals(child2, literal_i64_ptr(), literal_i64_len()) == 1) { is_type = 1; wt = wasm_type_i64(); }
        if (atom_equals(child2, literal_f32_ptr(), literal_f32_len()) == 1) { is_type = 1; wt = wasm_type_f32(); }
        if (atom_equals(child2, literal_f64_ptr(), literal_f64_len()) == 1) { is_type = 1; wt = wasm_type_f64(); }
        if (atom_equals(child2, literal_bool_ptr(), literal_bool_len()) == 1) { is_type = 1; wt = wasm_type_i32(); }
      }
      if (is_type == 1) {
        lhs = list_child_at(node, 3);
        rhs = list_child_at(node, 4);
      } else {
        lhs = list_child_at(node, 2);
        rhs = list_child_at(node, 3);
      }
    } else {
      lhs = list_child_at(node, 2);
      rhs = list_child_at(node, 3);
    }
    let rc1: i32 = emit_expr(lhs);
    if (rc1 != 0) { return rc1; }
    let rc2: i32 = emit_expr(rhs);
    if (rc2 != 0) { return rc2; }
    return emit_typed_binop(op, wt);
  }

  // (unary op expr) - only "not" supported
  if (atom_equals(tag, wl_unary_ptr(), wl_unary_len()) == 1) {
    let rc: i32 = emit_expr(list_child_at(node, 2));
    if (rc != 0) { return rc; }
    emit_wat_opcode(wl_i32_eqz_ptr(), wl_i32_eqz_len());
    return 0;
  }

  // (call callee args...)
  if (atom_equals(tag, literal_call_ptr(), literal_call_len()) == 1) {
    let callee: i32 = list_child_at(node, 1);

    // __mem_store(addr, val)
    if (atom_equals(callee, literal_mem_store_ptr(), literal_mem_store_len()) == 1) {
      emit_expr(list_child_at(node, 2));
      emit_expr(list_child_at(node, 3));
      emit_wat_opcode(wl_i32_store_ptr(), wl_i32_store_len());
      out_spaces(4);
      out_str(wl_i32_const_ptr(), wl_i32_const_len());
      out_char(48);
      out_nl();
      return 0;
    }

    // __mem_store8(addr, val)
    if (atom_equals(callee, literal_mem_store8_ptr(), literal_mem_store8_len()) == 1) {
      emit_expr(list_child_at(node, 2));
      emit_expr(list_child_at(node, 3));
      emit_wat_opcode(wl_i32_store8_ptr(), wl_i32_store8_len());
      out_spaces(4);
      out_str(wl_i32_const_ptr(), wl_i32_const_len());
      out_char(48);
      out_nl();
      return 0;
    }

    // __mem_load(addr)
    if (atom_equals(callee, literal_mem_load_ptr(), literal_mem_load_len()) == 1) {
      emit_expr(list_child_at(node, 2));
      emit_wat_opcode(wl_i32_load_ptr(), wl_i32_load_len());
      return 0;
    }

    // __mem_load8(addr)
    if (atom_equals(callee, literal_mem_load8_ptr(), literal_mem_load8_len()) == 1) {
      emit_expr(list_child_at(node, 2));
      emit_wat_opcode(wl_i32_load8_u_ptr(), wl_i32_load8_u_real_len());
      return 0;
    }

    // __fd_write(fd, iovs, iovs_len, nwritten)
    if (atom_equals(callee, literal_fd_write_ptr(), literal_fd_write_len()) == 1) {
      let arg: i32 = list_child_at(node, 2);
      while (arg != 0) {
        emit_expr(arg);
        arg = node_next(arg);
      }
      out_spaces(4);
      out_str(wl_call_dollar_ptr(), wl_call_dollar_len());
      // "fd_write"
      out_str(literal_fd_write_ptr() + 2, literal_fd_write_len() - 2);
      out_nl();
      return 0;
    }

    // __fd_read(fd, iovs, iovs_len, nread)
    if (atom_equals(callee, literal_fd_read_ptr(), literal_fd_read_len()) == 1) {
      let arg: i32 = list_child_at(node, 2);
      while (arg != 0) {
        emit_expr(arg);
        arg = node_next(arg);
      }
      out_spaces(4);
      out_str(wl_call_dollar_ptr(), wl_call_dollar_len());
      out_str(literal_fd_read_ptr() + 2, literal_fd_read_len() - 2);
      out_nl();
      return 0;
    }

    // __fd_close(fd)
    if (atom_equals(callee, literal_fd_close_ptr(), literal_fd_close_len()) == 1) {
      emit_expr(list_child_at(node, 2));
      out_spaces(4);
      out_str(wl_call_dollar_ptr(), wl_call_dollar_len());
      out_str(literal_fd_close_ptr() + 2, literal_fd_close_len() - 2);
      out_nl();
      return 0;
    }

    // __path_open(dirfd, dirflags, path, path_len, oflags, rights, rights_inh, fdflags, fd_out)
    if (atom_equals(callee, literal_path_open_ptr(), literal_path_open_len()) == 1) {
      // First 5 args as i32
      let arg: i32 = list_child_at(node, 2);
      let arg_idx: i32 = 0;
      while (arg != 0 && arg_idx < 9) {
        emit_expr(arg);
        if (arg_idx == 5 || arg_idx == 6) {
          // rights_base and rights_inheriting need i64.extend_i32_u
          emit_wat_opcode(wl_i64_extend_ptr(), wl_i64_extend_len());
        }
        arg = node_next(arg);
        arg_idx = arg_idx + 1;
      }
      out_spaces(4);
      out_str(wl_call_dollar_ptr(), wl_call_dollar_len());
      out_str(literal_path_open_ptr() + 2, literal_path_open_len() - 2);
      out_nl();
      return 0;
    }

    // __tty_get_mode(fd, buf) - stub: drop args, return 58
    if (atom_equals(callee, literal_tty_get_mode_ptr(), literal_tty_get_mode_len()) == 1) {
      let arg: i32 = list_child_at(node, 2);
      while (arg != 0) {
        emit_expr(arg);
        emit_wat_opcode(wl_drop_ptr(), wl_drop_len());
        arg = node_next(arg);
      }
      out_spaces(4);
      out_str(wl_i32_const_ptr(), wl_i32_const_len());
      out_char(53); out_char(56); // 58
      out_nl();
      return 0;
    }

    // __tty_set_raw(a, b, c, d) - stub: drop args, return 58
    if (atom_equals(callee, literal_tty_set_raw_ptr(), literal_tty_set_raw_len()) == 1) {
      let arg: i32 = list_child_at(node, 2);
      while (arg != 0) {
        emit_expr(arg);
        emit_wat_opcode(wl_drop_ptr(), wl_drop_len());
        arg = node_next(arg);
      }
      out_spaces(4);
      out_str(wl_i32_const_ptr(), wl_i32_const_len());
      out_char(53); out_char(56); // 58
      out_nl();
      return 0;
    }

    // __tty_restore(fd, buf) - stub: drop args, return 58
    if (atom_equals(callee, literal_tty_restore_ptr(), literal_tty_restore_len()) == 1) {
      let arg: i32 = list_child_at(node, 2);
      while (arg != 0) {
        emit_expr(arg);
        emit_wat_opcode(wl_drop_ptr(), wl_drop_len());
        arg = node_next(arg);
      }
      out_spaces(4);
      out_str(wl_i32_const_ptr(), wl_i32_const_len());
      out_char(53); out_char(56); // 58
      out_nl();
      return 0;
    }

    // User-defined function call
    if (is_known_fn(callee) == 1) {
      let arg: i32 = list_child_at(node, 2);
      while (arg != 0) {
        emit_expr(arg);
        arg = node_next(arg);
      }
      out_spaces(4);
      out_str(wl_call_dollar_ptr(), wl_call_dollar_len());
      out_atom(callee);
      out_nl();
      return 0;
    }

    return 0 - 130;
  }

  return 0 - 140;
}

// ---------------------------------------------------------------------------
// Statement emitter
// ---------------------------------------------------------------------------

fn emit_stmt(node: i32) -> i32 {
  let tag: i32 = list_child_at(node, 0);
  if (tag == 0) { return 0 - 200; }

  // (let name type expr)
  if (atom_equals(tag, literal_let_ptr(), literal_let_len()) == 1) {
    let rc: i32 = emit_expr(list_child_at(node, 3));
    if (rc != 0) { return rc; }
    let idx: i32 = local_index(list_child_at(node, 1));
    if (idx < 0) { return 0 - 210; }
    out_spaces(4);
    out_str(wl_local_set_ptr(), wl_local_set_len());
    out_int(idx);
    out_nl();
    return 0;
  }

  // (assign name expr)
  if (atom_equals(tag, literal_assign_ptr(), literal_assign_len()) == 1) {
    let rc: i32 = emit_expr(list_child_at(node, 2));
    if (rc != 0) { return rc; }
    let idx: i32 = local_index(list_child_at(node, 1));
    if (idx < 0) { return 0 - 211; }
    out_spaces(4);
    out_str(wl_local_set_ptr(), wl_local_set_len());
    out_int(idx);
    out_nl();
    return 0;
  }

  // (return expr)
  if (atom_equals(tag, literal_return_ptr(), literal_return_len()) == 1) {
    let rc: i32 = emit_expr(list_child_at(node, 1));
    if (rc != 0) { return rc; }
    emit_wat_opcode(wl_return_ptr(), wl_return_len());
    return 0;
  }

  // (expr e)
  if (atom_equals(tag, literal_expr_ptr(), literal_expr_len()) == 1) {
    let rc: i32 = emit_expr(list_child_at(node, 1));
    if (rc != 0) { return rc; }
    emit_wat_opcode(wl_drop_ptr(), wl_drop_len());
    return 0;
  }

  // (if cond block [else_block])
  if (atom_equals(tag, literal_if_ptr(), literal_if_len()) == 1) {
    let rc: i32 = emit_expr(list_child_at(node, 1));
    if (rc != 0) { return rc; }
    emit_wat_opcode(wl_if_ptr(), wl_if_len());
    let rc2: i32 = emit_block(list_child_at(node, 2));
    if (rc2 != 0) { return rc2; }
    let else_node: i32 = list_child_at(node, 3);
    if (else_node != 0) {
      if (child_tag_equals(else_node, literal_else_ptr(), literal_else_len()) == 1) {
        emit_wat_opcode(wl_else_ptr(), wl_else_len());
        let rc3: i32 = emit_block(list_child_at(else_node, 1));
        if (rc3 != 0) { return rc3; }
      }
    }
    emit_wat_opcode(wl_end_ptr(), wl_end_len());
    return 0;
  }

  // (while cond block)
  if (atom_equals(tag, literal_while_ptr(), literal_while_len()) == 1) {
    emit_wat_opcode(wl_block_ptr(), wl_block_len());
    emit_wat_opcode(wl_loop_ptr(), wl_loop_len());
    let rc: i32 = emit_expr(list_child_at(node, 1));
    if (rc != 0) { return rc; }
    emit_wat_opcode(wl_i32_eqz_ptr(), wl_i32_eqz_len());
    emit_wat_opcode(wl_br_if_1_ptr(), wl_br_if_1_real_len());
    let rc2: i32 = emit_block(list_child_at(node, 2));
    if (rc2 != 0) { return rc2; }
    emit_wat_opcode(wl_br_0_ptr(), wl_br_0_len());
    emit_wat_opcode(wl_end_ptr(), wl_end_len());
    emit_wat_opcode(wl_end_ptr(), wl_end_len());
    return 0;
  }

  // (struct_lit Name args...)
  if (atom_equals(tag, literal_struct_lit_ptr(), literal_struct_lit_len()) == 1) {
    let sname: i32 = list_child_at(node, 1);
    let sidx: i32 = find_struct_by_name(sname);
    if (sidx < 0) { return 0 - 140; }
    let addr: i32 = __mem_load(heap_ptr_addr());
    let arg: i32 = node_next(list_child_at(node, 1));
    let offset: i32 = 0;
    while (arg != 0) {
      out_spaces(4);
      out_str(wl_i32_const_ptr(), wl_i32_const_len());
      out_int(addr + offset);
      out_nl();
      emit_expr(arg);
      emit_wat_opcode(wl_i32_store_ptr(), wl_i32_store_len());
      offset = offset + 4;
      arg = node_next(arg);
    }
    __mem_store(heap_ptr_addr(), addr + offset);
    out_spaces(4);
    out_str(wl_i32_const_ptr(), wl_i32_const_len());
    out_int(addr);
    out_nl();
    return 0;
  }

  // (field var name)
  if (atom_equals(tag, literal_field_ptr(), literal_field_len()) == 1) {
    let var_name: i32 = list_child_at(node, 1);
    let field_name: i32 = list_child_at(node, 2);
    let vidx: i32 = local_index(var_name);
    if (vidx < 0) { return 0 - 141; }
    let sidx: i32 = local_sidx(vidx);
    if (sidx < 0) { return 0 - 142; }
    let fidx: i32 = find_field_idx(sidx, field_name);
    if (fidx < 0) { return 0 - 143; }
    out_spaces(4);
    out_str(wl_local_get_ptr(), wl_local_get_len());
    out_int(vidx);
    out_nl();
    out_spaces(4);
    out_str(wl_i32_load_ptr(), wl_i32_load_len());
    out_char(32); out_char(111); out_char(102); out_char(102); out_char(115);
    out_char(101); out_char(116); out_char(61); out_int(fidx * 4);
    out_nl();
    return 0;
  }

  // (field_assign var field expr)
  if (atom_equals(tag, literal_field_assign_ptr(), literal_field_assign_len()) == 1) {
    let var_name: i32 = list_child_at(node, 1);
    let field_name: i32 = list_child_at(node, 2);
    let expr: i32 = list_child_at(node, 3);
    let vidx: i32 = local_index(var_name);
    if (vidx < 0) { return 0 - 240; }
    let sidx: i32 = local_sidx(vidx);
    if (sidx < 0) { return 0 - 241; }
    let fidx: i32 = find_field_idx(sidx, field_name);
    if (fidx < 0) { return 0 - 242; }
    out_spaces(4);
    out_str(wl_local_get_ptr(), wl_local_get_len());
    out_int(vidx);
    out_nl();
    let rc: i32 = emit_expr(expr);
    if (rc != 0) { return rc; }
    out_spaces(4);
    out_str(wl_i32_store_ptr(), wl_i32_store_len());
    out_char(32); out_char(111); out_char(102); out_char(102); out_char(115);
    out_char(101); out_char(116); out_char(61); out_int(fidx * 4);
    out_nl();
    return 0;
  }

  return 0 - 250;
}

fn emit_block(node: i32) -> i32 {
  if (node == 0) { return 0 - 300; }
  let stmt: i32 = node_next(list_child_at(node, 0));
  while (stmt != 0) {
    let rc: i32 = emit_stmt(stmt);
    if (rc != 0) { return rc; }
    stmt = node_next(stmt);
  }
  return 0;
}

// ---------------------------------------------------------------------------
// Data segment emission
// ---------------------------------------------------------------------------

fn hex_digit(v: i32) -> i32 {
  if (v < 10) { return 48 + v; }
  return 97 + v - 10;
}

fn emit_data_segment(str_idx: i32) -> i32 {
  let entry: i32 = str_entry_addr(str_idx);
  let atom_off: i32 = __mem_load(entry);
  let atom_len: i32 = __mem_load(entry + 4);
  let data_addr: i32 = __mem_load(entry + 8);

  out_spaces(2);
  out_str(wl_data_prefix_real_ptr(), wl_data_prefix_real_len());
  out_int(data_addr);
  out_char(41); // )
  out_char(32); // ' '
  out_char(34); // "

  // Decode and emit escaped string content
  let i: i32 = 1;
  let end: i32 = atom_len - 1;
  while (i < end) {
    let c: i32 = __mem_load8(ir_buf_base() + atom_off + i);
    if (c == 92) {
      // Backslash escape
      i = i + 1;
      if (i < end) {
        let esc: i32 = __mem_load8(ir_buf_base() + atom_off + i);
        if (esc == 110) {
          // \n -> \0a
          out_char(92); out_char(48); out_char(97);
        } else {
          if (esc == 116) {
            // \t -> \09
            out_char(92); out_char(48); out_char(57);
          } else {
            if (esc == 92) {
              // \\ -> \5c
              out_char(92); out_char(53); out_char(99);
            } else {
              if (esc == 34) {
                // \" -> \22
                out_char(92); out_char(50); out_char(50);
              } else {
                // Unknown escape - emit as hex
                out_char(92);
                out_char(hex_digit(esc / 16));
                out_char(hex_digit(esc - (esc / 16) * 16));
              }
            }
          }
        }
      }
    } else {
      if (c >= 32 && c <= 126 && c != 34 && c != 92) {
        out_char(c);
      } else {
        out_char(92);
        out_char(hex_digit(c / 16));
        out_char(hex_digit(c - (c / 16) * 16));
      }
    }
    i = i + 1;
  }

  out_char(34); // "
  out_char(41); // )
  out_nl();
  return 0;
}

fn wl_data_prefix_real_ptr() -> i32 { return wat_lit_base() + 464; }
fn wl_data_prefix_real_len() -> i32 { return 17; }

// ---------------------------------------------------------------------------
// WASI import emission
// ---------------------------------------------------------------------------

fn emit_wasi_import_line1(func_name_ptr: i32, func_name_len: i32) -> i32 {
  // Emit: '  (import "wasi_snapshot_preview1" "NAME"'
  out_spaces(2);
  // Reuse the stored import prefix bytes 528..559 for the common part
  out_str(wat_lit_base() + 528, 32); // '(import "wasi_snapshot_preview1"'
  out_char(32);  // ' '
  out_char(34);  // '"'
  out_str(func_name_ptr, func_name_len);
  out_char(34);  // '"'
  out_nl();
  return 0;
}

fn emit_import_func_line(name_ptr: i32, name_len: i32, param_types_ptr: i32, param_types_len: i32) -> i32 {
  out_spaces(4);
  out_str(wl_func_dollar_ptr(), wl_func_dollar_len());
  out_str(name_ptr, name_len);
  out_char(32);  // ' '
  out_char(40);  // (
  out_char(112); out_char(97); out_char(114); out_char(97); out_char(109); // param
  out_char(32);  // ' '
  out_str(param_types_ptr, param_types_len);
  out_char(41);  // )
  out_str(wl_result_i32_ptr(), wl_result_i32_len());
  out_char(41);  // ) close result
  out_char(41);  // ) close func
  out_char(41);  // ) close import
  out_nl();
  return 0;
}

// "i32 i32 i32 i32" stored at wat_lit_base()+976 (15 bytes)
fn wl_4xi32_ptr() -> i32 { return wat_lit_base() + 976; }
fn wl_4xi32_len() -> i32 { return 15; }
// "i32" stored at wat_lit_base()+992 (3 bytes)
fn wl_1xi32_ptr() -> i32 { return wat_lit_base() + 992; }
fn wl_1xi32_len() -> i32 { return 3; }
// "i32 i32 i32 i32 i32 i64 i64 i32 i32" at wat_lit_base()+1000 (37 bytes)
fn wl_path_open_params_ptr() -> i32 { return wat_lit_base() + 1000; }
fn wl_path_open_params_len() -> i32 { return 35; }

fn emit_fd_write_import() -> i32 {
  emit_wasi_import_line1(literal_fd_write_ptr() + 2, literal_fd_write_len() - 2);
  emit_import_func_line(literal_fd_write_ptr() + 2, literal_fd_write_len() - 2, wl_4xi32_ptr(), wl_4xi32_len());
  return 0;
}

fn emit_fd_read_import() -> i32 {
  emit_wasi_import_line1(literal_fd_read_ptr() + 2, literal_fd_read_len() - 2);
  emit_import_func_line(literal_fd_read_ptr() + 2, literal_fd_read_len() - 2, wl_4xi32_ptr(), wl_4xi32_len());
  return 0;
}

fn emit_fd_close_import() -> i32 {
  emit_wasi_import_line1(literal_fd_close_ptr() + 2, literal_fd_close_len() - 2);
  emit_import_func_line(literal_fd_close_ptr() + 2, literal_fd_close_len() - 2, wl_1xi32_ptr(), wl_1xi32_len());
  return 0;
}

fn emit_path_open_import() -> i32 {
  emit_wasi_import_line1(literal_path_open_ptr() + 2, literal_path_open_len() - 2);
  emit_import_func_line(literal_path_open_ptr() + 2, literal_path_open_len() - 2, wl_path_open_params_ptr(), wl_path_open_params_len());
  return 0;
}

// ---------------------------------------------------------------------------
// Function emission
// ---------------------------------------------------------------------------

fn emit_param_by_type(wt: i32) -> i32 {
  out_char(32);
  if (wt == wasm_type_i64()) {
    out_str(wl_param_i64_ptr(), wl_param_i64_len());
  } else {
    if (wt == wasm_type_f32()) {
      out_str(wl_param_f32_ptr(), wl_param_f32_len());
    } else {
      if (wt == wasm_type_f64()) {
        out_str(wl_param_f64_ptr(), wl_param_f64_len());
      } else {
        out_str(wl_param_i32_ptr(), wl_param_i32_len());
      }
    }
  }
  out_char(41);
  return 0;
}

fn emit_result_by_type(wt: i32) -> i32 {
  if (wt == wasm_type_i64()) {
    out_str(wl_result_i64_ptr(), wl_result_i64_len());
  } else {
    if (wt == wasm_type_f32()) {
      out_str(wl_result_f32_ptr(), wl_result_f32_len());
    } else {
      if (wt == wasm_type_f64()) {
        out_str(wl_result_f64_ptr(), wl_result_f64_len());
      } else {
        out_str(wl_result_i32_ptr(), wl_result_i32_len());
      }
    }
  }
  out_char(41);
  return 0;
}

fn emit_local_by_type(wt: i32) -> i32 {
  out_spaces(4);
  if (wt == wasm_type_i64()) {
    out_str(wl_local_i64_ptr(), wl_local_i64_len());
  } else {
    if (wt == wasm_type_f32()) {
      out_str(wl_local_f32_ptr(), wl_local_f32_len());
    } else {
      if (wt == wasm_type_f64()) {
        out_str(wl_local_f64_ptr(), wl_local_f64_len());
      } else {
        out_str(wl_local_i32_ptr(), wl_local_i32_len());
      }
    }
  }
  out_char(41);
  out_nl();
  return 0;
}

fn emit_zero_by_type(wt: i32) -> i32 {
  out_spaces(4);
  if (wt == wasm_type_i64()) {
    out_str(wl_i64_const_ptr(), wl_i64_const_len());
  } else {
    if (wt == wasm_type_f32()) {
      out_str(wl_f32_const_ptr(), wl_f32_const_len());
    } else {
      if (wt == wasm_type_f64()) {
        out_str(wl_f64_const_ptr(), wl_f64_const_len());
      } else {
        out_str(wl_i32_const_ptr(), wl_i32_const_len());
      }
    }
  }
  out_char(48);
  out_nl();
  return 0;
}

fn fn_ret_wasm_type_addr() -> i32 { return state_base() + 8460; }
// Heap pointer for array bump allocation
fn heap_ptr_addr() -> i32 { return state_base() + 8464; }
fn heap_base() -> i32 { return 65536; } // Start heap at 64KB

fn emit_function(fn_node: i32) -> i32 {
  let name_node: i32 = list_child_at(fn_node, 1);
  let params_node: i32 = list_child_at(fn_node, 2);
  let ret_node: i32 = list_child_at(fn_node, 3);
  let block_node: i32 = list_child_at(fn_node, 4);

  // Determine return wasm type
  let ret_wt: i32 = wasm_type_i32();
  if (__mem_load(is_v1_addr()) == 1) {
    let ret_type_node: i32 = list_child_at(ret_node, 1);
    if (ret_type_node != 0) {
      ret_wt = ir_type_to_wasm(ret_type_node);
    }
  }
  __mem_store(fn_ret_wasm_type_addr(), ret_wt);

  // Reset locals and collect params
  reset_locals();
  let param: i32 = node_next(list_child_at(params_node, 0));
  let param_count: i32 = 0;
  while (param != 0) {
    let pname: i32 = list_child_at(param, 1);
    let pwt: i32 = wasm_type_i32();
    let psidx: i32 = 0 - 1;
    if (__mem_load(is_v1_addr()) == 1) {
      let ptype_node: i32 = list_child_at(param, 2);
      if (ptype_node != 0) {
        pwt = ir_type_to_wasm(ptype_node);
        if (pwt == wasm_type_struct()) { psidx = find_struct_by_name(ptype_node); }
      }
    }
    add_local_with_type_and_sidx(node_atom_off(pname), node_atom_len(pname), pwt, psidx);
    param_count = param_count + 1;
    param = node_next(param);
  }
  __mem_store(locals_param_count_addr(), param_count);

  // Collect let-locals
  collect_locals_block(block_node);
  let total_locals: i32 = __mem_load(locals_count_addr());
  let let_locals: i32 = total_locals - param_count;

  // Emit function header
  out_spaces(2);
  out_str(wl_func_dollar_ptr(), wl_func_dollar_len());
  out_atom(name_node);

  // Emit params
  let pi: i32 = 0;
  while (pi < param_count) {
    emit_param_by_type(local_wasm_type(pi));
    pi = pi + 1;
  }

  // Emit result
  emit_result_by_type(ret_wt);
  out_nl();

  // Emit local declarations
  let li: i32 = 0;
  while (li < let_locals) {
    emit_local_by_type(local_wasm_type(param_count + li));
    li = li + 1;
  }

  // Emit body
  let rc: i32 = emit_block(block_node);
  if (rc != 0) { return rc; }

  // Emit trailing return
  emit_zero_by_type(ret_wt);
  emit_wat_opcode(wl_return_ptr(), wl_return_len());

  // Close function
  out_spaces(2);
  out_char(41);  // )
  out_nl();
  return 0;
}

// ---------------------------------------------------------------------------
// Main lowering function
// ---------------------------------------------------------------------------

fn lower_ir_to_wat(ir_len: i32) -> i32 {
  init_literals();
  init_wat_literals();
  out_reset();
  reset_features();
  reset_str_table();
  reset_fn_names();
  reset_struct_table();
  __mem_store(heap_ptr_addr(), heap_base());

  // Parse the IR
  __mem_store(node_count_addr(), 0);
  set_parse_pos(0);
  set_parse_end(ir_len);
  let root: i32 = parse_expr();
  if (root == 0) { return 0 - 500; }

  // Validate root: (coatl_ir v0 (structs) (functions ...))
  if (node_kind(root) != 1) { return 0 - 501; }
  let tag: i32 = list_child_at(root, 0);
  if (atom_equals(tag, literal_coatl_ir_ptr(), literal_coatl_ir_len()) != 1) { return 0 - 502; }
  let ver: i32 = list_child_at(root, 1);
  let ver_ok: i32 = 0;
  if (atom_equals(ver, literal_v0_ptr(), literal_v0_len()) == 1) {
    ver_ok = 1;
    __mem_store(is_v1_addr(), 0);
  }
  if (atom_equals(ver, literal_v1_ptr(), literal_v1_len()) == 1) {
    ver_ok = 1;
    __mem_store(is_v1_addr(), 1);
  }
  if (ver_ok != 1) { return 0 - 503; }

  let structs: i32 = list_child_at(root, 2);
  if (child_tag_equals(structs, literal_structs_ptr(), literal_structs_len()) != 1) { return 0 - 504; }
  parse_structs(structs);
  let functions: i32 = list_child_at(root, 3);
  if (child_tag_equals(functions, literal_functions_ptr(), literal_functions_len()) != 1) { return 0 - 505; }

  // First pass: collect function names, features, string literals
  let fn_node: i32 = node_next(list_child_at(functions, 0));
  while (fn_node != 0) {
    let fn_name: i32 = list_child_at(fn_node, 1);
    add_fn_name(node_atom_off(fn_name), node_atom_len(fn_name));
    let fn_block: i32 = list_child_at(fn_node, 4);
    collect_features_block(fn_block);
    collect_strings_block(fn_block);
    fn_node = node_next(fn_node);
  }

  // Emit module header
  out_str(wl_module_ptr(), wl_module_len());
  out_nl();

  // Emit WASI imports
  if (__mem_load(feat_fd_write_addr()) != 0) {
    emit_fd_write_import();
  }
  if (__mem_load(feat_fd_read_addr()) != 0) {
    emit_fd_read_import();
  }
  if (__mem_load(feat_fd_close_addr()) != 0) {
    emit_fd_close_import();
  }
  if (__mem_load(feat_path_open_addr()) != 0) {
    emit_path_open_import();
  }

  // Emit memory
  out_spaces(2);
  out_str(wl_memory_export_ptr(), wl_memory_export_real_len());
  out_nl();

  // Emit data segments
  let si: i32 = 0;
  let str_count: i32 = __mem_load(str_count_addr());
  while (si < str_count) {
    emit_data_segment(si);
    si = si + 1;
  }

  // Emit functions
  fn_node = node_next(list_child_at(functions, 0));
  while (fn_node != 0) {
    let rc: i32 = emit_function(fn_node);
    if (rc != 0) { return rc; }
    fn_node = node_next(fn_node);
  }

  return lower_ir_emit_start();
}

fn lower_ir_emit_start() -> i32 {
  // Emit main export: (export "main" (func $main))
  out_spaces(2);
  out_char(40);  // (
  out_char(101); out_char(120); out_char(112); out_char(111);
  out_char(114); out_char(116); // export
  out_char(32);  // ' '
  out_char(34);  // "
  out_str(literal_main_ptr(), literal_main_len());
  out_char(34);  // "
  out_char(32);  // ' '
  out_char(40);  // (
  out_char(102); out_char(117); out_char(110); out_char(99); // func
  out_char(32);  // ' '
  out_char(36);  // $
  out_str(literal_main_ptr(), literal_main_len());
  out_char(41);  // )
  out_char(41);  // )
  out_nl();

  // Emit _start function
  out_spaces(2);
  out_str(wl_func_dollar_ptr(), wl_func_dollar_len());
  out_char(95);  out_char(115); out_char(116);
  out_char(97);  out_char(114); out_char(116);  // _start
  out_nl();

  out_spaces(4);
  out_str(wl_call_dollar_ptr(), wl_call_dollar_len());
  out_str(literal_main_ptr(), literal_main_len());
  out_nl();

  out_spaces(4);
  out_str(wl_drop_ptr(), wl_drop_len());
  out_nl();

  out_spaces(2);
  out_char(41);  // )
  out_nl();

  // Emit export
  out_spaces(2);
  out_str(wl_export_start_real_ptr(), wl_export_start_real_len());
  out_nl();

  // Close module
  out_char(41);  // )
  out_nl();

  return out_len();
}

fn main() -> i32 {
  let rc_parse: i32 = parse_args();
  if (rc_parse != 0) { return rc_parse; }

  let in_ptr: i32 = __mem_load(slot_input());
  let out_ptr: i32 = __mem_load(slot_output());
  let in_len: i32 = cstr_len(in_ptr);
  let out_len: i32 = cstr_len(out_ptr);

  let ir_size: i32 = read_file_into_buf(in_ptr, in_len);
  if (ir_size < 0) { return 0 - 40; }

  let out_sz: i32 = lower_ir_to_wat(ir_size);
  if (out_sz < 0) { return out_sz; }

  let rc_write: i32 = write_output(out_ptr, out_len, out_sz);
  if (rc_write != 0) { return 0 - 60; }
  return 0;
}

fn cstr_len(ptr: i32) -> i32 {
  let i: i32 = 0;
  while (__mem_load8(ptr + i) != 0) { i = i + 1; }
  return i;
}

fn cstr_eq(a: i32, b: i32) -> i32 {
  let i: i32 = 0;
  while (1 == 1) {
    let ca: i32 = __mem_load8(a + i);
    let cb: i32 = __mem_load8(b + i);
    if (ca != cb) { return 0; }
    if (ca == 0) { return 1; }
    i = i + 1;
  }
  return 1;
}

// ---------------------------------------------------------------------------
// Parser/Node storage
// ---------------------------------------------------------------------------

fn node_state_base() -> i32 { return state_base() + 8320; }
fn node_count_addr() -> i32 { return node_state_base() + 0; }
fn node_base() -> i32 { return 5242880; }
fn node_slot_size() -> i32 { return 32; }
fn node_addr(idx: i32) -> i32 { return node_base() + idx * node_slot_size(); }

fn node_alloc() -> i32 {
  let count: i32 = __mem_load(node_count_addr());
  let next: i32 = count + 1;
  if (next >= 131072) { return 0; }
  __mem_store(node_count_addr(), next);
  return next;
}

fn node_kind_addr(idx: i32) -> i32 { return node_addr(idx); }
fn node_child_head_addr(idx: i32) -> i32 { return node_addr(idx) + 4; }
fn node_child_tail_addr(idx: i32) -> i32 { return node_addr(idx) + 8; }
fn node_atom_off_addr(idx: i32) -> i32 { return node_addr(idx) + 12; }
fn node_atom_len_addr(idx: i32) -> i32 { return node_addr(idx) + 16; }
fn node_next_addr(idx: i32) -> i32 { return node_addr(idx) + 20; }

fn set_node_kind(idx: i32, kind: i32) -> i32 {
  __mem_store(node_kind_addr(idx), kind);
  return 0;
}

fn set_node_atom(idx: i32, off: i32, len: i32) -> i32 {
  __mem_store(node_atom_off_addr(idx), off);
  __mem_store(node_atom_len_addr(idx), len);
  return 0;
}

fn append_child(parent: i32, child: i32) -> i32 {
  let head: i32 = __mem_load(node_child_head_addr(parent));
  if (head == 0) {
    __mem_store(node_child_head_addr(parent), child);
    __mem_store(node_child_tail_addr(parent), child);
  } else {
    let tail: i32 = __mem_load(node_child_tail_addr(parent));
    __mem_store(node_next_addr(tail), child);
    __mem_store(node_child_tail_addr(parent), child);
  }
  return 0;
}

fn set_node_next(idx: i32, next: i32) -> i32 {
  __mem_store(node_next_addr(idx), next);
  return 0;
}

fn parse_state_base_addr() -> i32 { return state_base() + 8368; }
fn parse_pos_addr() -> i32 { return parse_state_base_addr() + 0; }
fn parse_end_addr() -> i32 { return parse_state_base_addr() + 4; }
fn ir_size_addr() -> i32 { return parse_state_base_addr() + 8; }

fn set_parse_pos(v: i32) -> i32 {
  __mem_store(parse_pos_addr(), v);
  return 0;
}

fn get_parse_pos() -> i32 { return __mem_load(parse_pos_addr()); }
fn get_parse_end() -> i32 { return __mem_load(parse_end_addr()); }
fn set_parse_end(v: i32) -> i32 { __mem_store(parse_end_addr(), v); return 0; }

fn ir_buf_char(pos: i32) -> i32 {
  return __mem_load8(ir_buf_base() + pos);
}

fn skip_whitespace() -> i32 {
  let pos: i32 = get_parse_pos();
  let end: i32 = get_parse_end();
  while (pos < end && ir_buf_char(pos) <= 32 && ir_buf_char(pos) != 0) {
    pos = pos + 1;
  }
  set_parse_pos(pos);
  return pos;
}

fn peek_char() -> i32 {
  let pos: i32 = get_parse_pos();
  let end: i32 = get_parse_end();
  if (pos >= end) { return 0; }
  return ir_buf_char(pos);
}

fn consume_char() -> i32 {
  let pos: i32 = get_parse_pos();
  let end: i32 = get_parse_end();
  if (pos >= end) { return 0; }
  let ch: i32 = ir_buf_char(pos);
  set_parse_pos(pos + 1);
  return ch;
}

fn parse_atom() -> i32 {
  skip_whitespace();
  let start: i32 = get_parse_pos();
  let ch: i32 = peek_char();
  if (ch == 0) { return 0; }
  if (ch == 34) {
    consume_char(); // "
    let end: i32 = get_parse_end();
    let done: i32 = 0;
    while (done == 0 && get_parse_pos() < end) {
      let cur: i32 = consume_char();
      if (cur == 92) { // backslash
        consume_char();
      } else {
        if (cur == 34) { done = 1; }
      }
    }
  } else {
    let done: i32 = 0;
    while (done == 0) {
      let c: i32 = peek_char();
      if (c == 0 || c <= 32 || c == 40 || c == 41) { done = 1; }
      else { consume_char(); }
    }
  }
  let end_pos: i32 = get_parse_pos();
  let len: i32 = end_pos - start;
  if (len <= 0) { return 0; }
  let idx: i32 = node_alloc();
  if (idx == 0) { return 0; }
  set_node_kind(idx, 0);
  set_node_atom(idx, start, len);
  return idx;
}

fn parse_list() -> i32 {
  consume_char(); // '('
  let idx: i32 = node_alloc();
  if (idx == 0) { return 0; }
  set_node_kind(idx, 1);
  set_node_atom(idx, 0, 0);

  let list_done: i32 = 0;
  while (list_done == 0) {
    skip_whitespace();
    let c: i32 = peek_char();
    if (c == 0) { return 0; }
    if (c == 41) {
      consume_char();
      list_done = 1;
    } else {
      let child: i32 = parse_expr();
      if (child == 0) { return 0; }
      append_child(idx, child);
    }
  }
  return idx;
}

fn parse_expr() -> i32 {
  skip_whitespace();
  let c: i32 = peek_char();
  if (c == 40) { return parse_list(); }
  if (c == 41 || c == 0) { return 0; }
  return parse_atom();
}

fn node_kind(idx: i32) -> i32 {
  return __mem_load(node_kind_addr(idx));
}

fn node_child_head(idx: i32) -> i32 {
  return __mem_load(node_child_head_addr(idx));
}

fn node_next(idx: i32) -> i32 {
  return __mem_load(node_next_addr(idx));
}

fn node_atom_off(idx: i32) -> i32 {
  return __mem_load(node_atom_off_addr(idx));
}

fn node_atom_len(idx: i32) -> i32 {
  return __mem_load(node_atom_len_addr(idx));
}

fn atom_equals(idx: i32, text_ptr: i32, text_len: i32) -> i32 {
  let off: i32 = node_atom_off(idx);
  let len: i32 = node_atom_len(idx);
  if (len != text_len) { return 0; }
  let i: i32 = 0;
  while (i < len) {
    if (__mem_load8(ir_buf_base() + off + i) != __mem_load8(text_ptr + i)) { return 0; }
    i = i + 1;
  }
  return 1;
}

fn literals_base() -> i32 { return 9453568; }  // fn_names_base + 8192
fn literals_inited_addr() -> i32 { return state_base() + 8384; }

fn literal_coatl_ir_ptr() -> i32 { return literals_base(); }
fn literal_coatl_ir_len() -> i32 { return 8; }
fn literal_v0_ptr() -> i32 { return literal_coatl_ir_ptr() + literal_coatl_ir_len(); }
fn literal_v0_len() -> i32 { return 2; }
fn literal_structs_ptr() -> i32 { return literal_v0_ptr() + literal_v0_len(); }
fn literal_structs_len() -> i32 { return 7; }
fn literal_functions_ptr() -> i32 { return literal_structs_ptr() + literal_structs_len(); }
fn literal_functions_len() -> i32 { return 9; }
fn literal_fn_ptr() -> i32 { return literal_functions_ptr() + literal_functions_len(); }
fn literal_fn_len() -> i32 { return 2; }
fn literal_params_ptr() -> i32 { return literal_fn_ptr() + literal_fn_len(); }
fn literal_params_len() -> i32 { return 6; }
fn literal_param_ptr() -> i32 { return literal_params_ptr() + literal_params_len(); }
fn literal_param_len() -> i32 { return 5; }
fn literal_i32_ptr() -> i32 { return literal_param_ptr() + literal_param_len(); }
fn literal_i32_len() -> i32 { return 3; }
fn literal_ret_ptr() -> i32 { return literal_i32_ptr() + literal_i32_len(); }
fn literal_ret_len() -> i32 { return 3; }
fn literal_block_ptr() -> i32 { return literal_ret_ptr() + literal_ret_len(); }
fn literal_block_len() -> i32 { return 5; }
fn literal_let_ptr() -> i32 { return literal_block_ptr() + literal_block_len(); }
fn literal_let_len() -> i32 { return 3; }
fn literal_assign_ptr() -> i32 { return literal_let_ptr() + literal_let_len(); }
fn literal_assign_len() -> i32 { return 6; }
fn literal_return_ptr() -> i32 { return literal_assign_ptr() + literal_assign_len(); }
fn literal_return_len() -> i32 { return 6; }
fn literal_expr_ptr() -> i32 { return literal_return_ptr() + literal_return_len(); }
fn literal_expr_len() -> i32 { return 4; }
fn literal_if_ptr() -> i32 { return literal_expr_ptr() + literal_expr_len(); }
fn literal_if_len() -> i32 { return 2; }
fn literal_else_ptr() -> i32 { return literal_if_ptr() + literal_if_len(); }
fn literal_else_len() -> i32 { return 4; }
fn literal_while_ptr() -> i32 { return literal_else_ptr() + literal_else_len(); }
fn literal_while_len() -> i32 { return 5; }
fn literal_int_ptr() -> i32 { return literal_while_ptr() + literal_while_len(); }
fn literal_int_len() -> i32 { return 3; }
fn literal_bool_ptr() -> i32 { return literal_int_ptr() + literal_int_len(); }
fn literal_bool_len() -> i32 { return 4; }
fn literal_string_ptr() -> i32 { return literal_bool_ptr() + literal_bool_len(); }
fn literal_string_len() -> i32 { return 6; }
fn literal_binary_ptr() -> i32 { return literal_string_ptr() + literal_string_len(); }
fn literal_binary_len() -> i32 { return 6; }
fn literal_call_ptr() -> i32 { return literal_binary_ptr() + literal_binary_len(); }
fn literal_call_len() -> i32 { return 4; }
fn literal_ident_ptr() -> i32 { return literal_call_ptr() + literal_call_len(); }
fn literal_ident_len() -> i32 { return 5; }
fn literal_add_ptr() -> i32 { return literal_ident_ptr() + literal_ident_len(); }
fn literal_add_len() -> i32 { return 3; }
fn literal_sub_ptr() -> i32 { return literal_add_ptr() + literal_add_len(); }
fn literal_sub_len() -> i32 { return 3; }
fn literal_mul_ptr() -> i32 { return literal_sub_ptr() + literal_sub_len(); }
fn literal_mul_len() -> i32 { return 3; }
fn literal_div_ptr() -> i32 { return literal_mul_ptr() + literal_mul_len(); }
fn literal_div_len() -> i32 { return 3; }
fn literal_eq_ptr() -> i32 { return literal_div_ptr() + literal_div_len(); }
fn literal_eq_len() -> i32 { return 2; }
fn literal_ne_ptr() -> i32 { return literal_eq_ptr() + literal_eq_len(); }
fn literal_ne_len() -> i32 { return 2; }
fn literal_lt_ptr() -> i32 { return literal_ne_ptr() + literal_ne_len(); }
fn literal_lt_len() -> i32 { return 2; }
fn literal_gt_ptr() -> i32 { return literal_lt_ptr() + literal_lt_len(); }
fn literal_gt_len() -> i32 { return 2; }
fn literal_le_ptr() -> i32 { return literal_gt_ptr() + literal_gt_len(); }
fn literal_le_len() -> i32 { return 2; }
fn literal_ge_ptr() -> i32 { return literal_le_ptr() + literal_le_len(); }
fn literal_ge_len() -> i32 { return 2; }
fn literal_and_ptr() -> i32 { return literal_ge_ptr() + literal_ge_len(); }
fn literal_and_len() -> i32 { return 3; }
fn literal_or_ptr() -> i32 { return literal_and_ptr() + literal_and_len(); }
fn literal_or_len() -> i32 { return 2; }
fn literal_not_ptr() -> i32 { return literal_or_ptr() + literal_or_len(); }
fn literal_not_len() -> i32 { return 3; }
fn literal_mem_store_ptr() -> i32 { return literal_not_ptr() + literal_not_len(); }
fn literal_mem_store_len() -> i32 { return 11; }
fn literal_mem_store8_ptr() -> i32 { return literal_mem_store_ptr() + literal_mem_store_len(); }
fn literal_mem_store8_len() -> i32 { return 12; }
fn literal_mem_load_ptr() -> i32 { return literal_mem_store8_ptr() + literal_mem_store8_len(); }
fn literal_mem_load_len() -> i32 { return 10; }
fn literal_mem_load8_ptr() -> i32 { return literal_mem_load_ptr() + literal_mem_load_len(); }
fn literal_mem_load8_len() -> i32 { return 11; }
fn literal_fd_write_ptr() -> i32 { return literal_mem_load8_ptr() + literal_mem_load8_len(); }
fn literal_fd_write_len() -> i32 { return 10; }
fn literal_fd_read_ptr() -> i32 { return literal_fd_write_ptr() + literal_fd_write_len(); }
fn literal_fd_read_len() -> i32 { return 9; }
fn literal_fd_close_ptr() -> i32 { return literal_fd_read_ptr() + literal_fd_read_len(); }
fn literal_fd_close_len() -> i32 { return 10; }
fn literal_path_open_ptr() -> i32 { return literal_fd_close_ptr() + literal_fd_close_len(); }
fn literal_path_open_len() -> i32 { return 11; }
fn literal_tty_get_mode_ptr() -> i32 { return literal_path_open_ptr() + literal_path_open_len(); }
fn literal_tty_get_mode_len() -> i32 { return 14; }
fn literal_tty_set_raw_ptr() -> i32 { return literal_tty_get_mode_ptr() + literal_tty_get_mode_len(); }
fn literal_tty_set_raw_len() -> i32 { return 13; }
fn literal_tty_restore_ptr() -> i32 { return literal_tty_set_raw_ptr() + literal_tty_set_raw_len(); }
fn literal_tty_restore_len() -> i32 { return 13; }
fn literal_main_ptr() -> i32 { return literal_tty_restore_ptr() + literal_tty_restore_len(); }
fn literal_main_len() -> i32 { return 4; }
fn literal_v1_ptr() -> i32 { return literal_main_ptr() + literal_main_len(); }
fn literal_v1_len() -> i32 { return 2; }
fn literal_i64_ptr() -> i32 { return literal_v1_ptr() + literal_v1_len(); }
fn literal_i64_len() -> i32 { return 3; }
fn literal_f32_ptr() -> i32 { return literal_i64_ptr() + literal_i64_len(); }
fn literal_f32_len() -> i32 { return 3; }
fn literal_f64_ptr() -> i32 { return literal_f32_ptr() + literal_f32_len(); }
fn literal_f64_len() -> i32 { return 3; }
fn literal_str_type_ptr() -> i32 { return literal_f64_ptr() + literal_f64_len(); }
fn literal_str_type_len() -> i32 { return 3; }
fn literal_int_i64_ptr() -> i32 { return literal_str_type_ptr() + literal_str_type_len(); }
fn literal_int_i64_len() -> i32 { return 7; }
fn literal_float_f32_ptr() -> i32 { return literal_int_i64_ptr() + literal_int_i64_len(); }
fn literal_float_f32_len() -> i32 { return 9; }
fn literal_float_f64_ptr() -> i32 { return literal_float_f32_ptr() + literal_float_f32_len(); }
fn literal_float_f64_len() -> i32 { return 9; }
fn literal_array_alloc_ptr() -> i32 { return literal_float_f64_ptr() + literal_float_f64_len(); }
fn literal_array_alloc_len() -> i32 { return 11; }
fn literal_array_get_ptr() -> i32 { return literal_array_alloc_ptr() + literal_array_alloc_len(); }
fn literal_array_get_len() -> i32 { return 9; }
fn literal_array_set_ptr() -> i32 { return literal_array_get_ptr() + literal_array_get_len(); }
fn literal_array_set_len() -> i32 { return 9; }
fn literal_string_typed_ptr() -> i32 { return literal_array_set_ptr() + literal_array_set_len(); }
fn literal_string_typed_len() -> i32 { return 12; }
fn literal_str_len_fn_ptr() -> i32 { return literal_string_typed_ptr() + literal_string_typed_len(); }
fn literal_str_len_fn_len() -> i32 { return 7; }
fn literal_str_ptr_fn_ptr() -> i32 { return literal_str_len_fn_ptr() + literal_str_len_fn_len(); }
fn literal_str_ptr_fn_len() -> i32 { return 7; }
fn literal_struct_lit_ptr() -> i32 { return literal_str_ptr_fn_ptr() + literal_str_ptr_fn_len(); }
fn literal_struct_lit_len() -> i32 { return 10; }
fn literal_field_ptr() -> i32 { return literal_struct_lit_ptr() + literal_struct_lit_len(); }
fn literal_field_len() -> i32 { return 5; }
fn literal_field_assign_ptr() -> i32 { return literal_field_ptr() + literal_field_len(); }
fn literal_field_assign_len() -> i32 { return 12; }

fn struct_count_addr() -> i32 { return state_base() + 8468; }
// struct table: each entry = 24 bytes (name_off:4, name_len:4, field0_off:4, field0_len:4, field1_off:4, field1_len:4)
fn struct_table_base() -> i32 { return state_base() + 12000; }
fn struct_entry_size() -> i32 { return 24; }

fn reset_struct_table() -> i32 { __mem_store(struct_count_addr(), 0); return 0; }

fn add_struct(name_node: i32, f0_node: i32, f1_node: i32) -> i32 {
  let count: i32 = __mem_load(struct_count_addr());
  let addr: i32 = struct_table_base() + count * struct_entry_size();
  __mem_store(addr, node_atom_off(name_node));
  __mem_store(addr + 4, node_atom_len(name_node));
  __mem_store(addr + 8, node_atom_off(f0_node));
  __mem_store(addr + 12, node_atom_len(f0_node));
  let f1_off: i32 = 0;
  let f1_len: i32 = 0;
  if (f1_node != 0) { f1_off = node_atom_off(f1_node); f1_len = node_atom_len(f1_node); }
  __mem_store(addr + 16, f1_off);
  __mem_store(addr + 20, f1_len);
  __mem_store(struct_count_addr(), count + 1);
  return 0;
}

fn find_struct_by_name(name_node: i32) -> i32 {
  return 0;
}

fn find_field_idx(sidx: i32, field_node: i32) -> i32 {
  let addr: i32 = struct_table_base() + sidx * struct_entry_size();
  let f0_off: i32 = __mem_load(addr + 8);
  let f0_len: i32 = __mem_load(addr + 12);
  let fo: i32 = node_atom_off(field_node);
  let fl: i32 = node_atom_len(field_node);
  if (f0_len == fl) {
    let match: i32 = 1;
    let j: i32 = 0;
    while (j < fl && match == 1) {
      if (__mem_load8(ir_buf_base() + f0_off + j) != __mem_load8(ir_buf_base() + fo + j)) {
        match = 0;
      }
      j = j + 1;
    }
    if (match == 1) { return 0; }
  }
  let f1_off: i32 = __mem_load(addr + 16);
  let f1_len: i32 = __mem_load(addr + 20);
  if (f1_len == fl) {
    let match: i32 = 1;
    let j: i32 = 0;
    while (j < fl && match == 1) {
      if (__mem_load8(ir_buf_base() + f1_off + j) != __mem_load8(ir_buf_base() + fo + j)) {
        match = 0;
      }
      j = j + 1;
    }
    if (match == 1) { return 1; }
  }
  return 0 - 1;
}

fn parse_structs(structs_node: i32) -> i32 {
  let s: i32 = node_next(list_child_at(structs_node, 0));
  while (s != 0) {
    let sname: i32 = list_child_at(s, 1);
    let f0: i32 = list_child_at(s, 2);
    let f0name: i32 = list_child_at(f0, 1);
    let f1: i32 = list_child_at(s, 3);
    let f1name: i32 = 0;
    if (f1 != 0) { f1name = list_child_at(f1, 1); }
    add_struct(sname, f0name, f1name);
    s = node_next(s);
  }
  return 0;
}

fn init_literals() -> i32 {
  if (__mem_load(literals_inited_addr()) != 0) { return 0; }
  __mem_store8(literals_base() + 0, 99);  // 'c'
  __mem_store8(literals_base() + 1, 111);  // 'o'
  __mem_store8(literals_base() + 2, 97);  // 'a'
  __mem_store8(literals_base() + 3, 116);  // 't'
  __mem_store8(literals_base() + 4, 108);  // 'l'
  __mem_store8(literals_base() + 5, 95);  // '_'
  __mem_store8(literals_base() + 6, 105);  // 'i'
  __mem_store8(literals_base() + 7, 114);  // 'r'
  __mem_store8(literals_base() + 8, 118);  // 'v'
  __mem_store8(literals_base() + 9, 48);  // '0'
  __mem_store8(literals_base() + 10, 115);  // 's'
  __mem_store8(literals_base() + 11, 116);  // 't'
  __mem_store8(literals_base() + 12, 114);  // 'r'
  __mem_store8(literals_base() + 13, 117);  // 'u'
  __mem_store8(literals_base() + 14, 99);  // 'c'
  __mem_store8(literals_base() + 15, 116);  // 't'
  __mem_store8(literals_base() + 16, 115);  // 's'
  __mem_store8(literals_base() + 17, 102);  // 'f'
  __mem_store8(literals_base() + 18, 117);  // 'u'
  __mem_store8(literals_base() + 19, 110);  // 'n'
  __mem_store8(literals_base() + 20, 99);  // 'c'
  __mem_store8(literals_base() + 21, 116);  // 't'
  __mem_store8(literals_base() + 22, 105);  // 'i'
  __mem_store8(literals_base() + 23, 111);  // 'o'
  __mem_store8(literals_base() + 24, 110);  // 'n'
  __mem_store8(literals_base() + 25, 115);  // 's'
  __mem_store8(literals_base() + 26, 102);  // 'f'
  __mem_store8(literals_base() + 27, 110);  // 'n'
  __mem_store8(literals_base() + 28, 112);  // 'p'
  __mem_store8(literals_base() + 29, 97);  // 'a'
  __mem_store8(literals_base() + 30, 114);  // 'r'
  __mem_store8(literals_base() + 31, 97);  // 'a'
  __mem_store8(literals_base() + 32, 109);  // 'm'
  __mem_store8(literals_base() + 33, 115);  // 's'
  __mem_store8(literals_base() + 34, 112);  // 'p'
  __mem_store8(literals_base() + 35, 97);  // 'a'
  __mem_store8(literals_base() + 36, 114);  // 'r'
  __mem_store8(literals_base() + 37, 97);  // 'a'
  __mem_store8(literals_base() + 38, 109);  // 'm'
  __mem_store8(literals_base() + 39, 105);  // 'i'
  __mem_store8(literals_base() + 40, 51);  // '3'
  __mem_store8(literals_base() + 41, 50);  // '2'
  __mem_store8(literals_base() + 42, 114);  // 'r'
  __mem_store8(literals_base() + 43, 101);  // 'e'
  __mem_store8(literals_base() + 44, 116);  // 't'
  __mem_store8(literals_base() + 45, 98);  // 'b'
  __mem_store8(literals_base() + 46, 108);  // 'l'
  __mem_store8(literals_base() + 47, 111);  // 'o'
  __mem_store8(literals_base() + 48, 99);  // 'c'
  __mem_store8(literals_base() + 49, 107);  // 'k'
  __mem_store8(literals_base() + 50, 108);  // 'l'
  __mem_store8(literals_base() + 51, 101);  // 'e'
  __mem_store8(literals_base() + 52, 116);  // 't'
  __mem_store8(literals_base() + 53, 97);  // 'a'
  __mem_store8(literals_base() + 54, 115);  // 's'
  __mem_store8(literals_base() + 55, 115);  // 's'
  __mem_store8(literals_base() + 56, 105);  // 'i'
  __mem_store8(literals_base() + 57, 103);  // 'g'
  __mem_store8(literals_base() + 58, 110);  // 'n'
  __mem_store8(literals_base() + 59, 114);  // 'r'
  __mem_store8(literals_base() + 60, 101);  // 'e'
  __mem_store8(literals_base() + 61, 116);  // 't'
  __mem_store8(literals_base() + 62, 117);  // 'u'
  __mem_store8(literals_base() + 63, 114);  // 'r'
  __mem_store8(literals_base() + 64, 110);  // 'n'
  __mem_store8(literals_base() + 65, 101);  // 'e'
  __mem_store8(literals_base() + 66, 120);  // 'x'
  __mem_store8(literals_base() + 67, 112);  // 'p'
  __mem_store8(literals_base() + 68, 114);  // 'r'
  __mem_store8(literals_base() + 69, 105);  // 'i'
  __mem_store8(literals_base() + 70, 102);  // 'f'
  __mem_store8(literals_base() + 71, 101);  // 'e'
  __mem_store8(literals_base() + 72, 108);  // 'l'
  __mem_store8(literals_base() + 73, 115);  // 's'
  __mem_store8(literals_base() + 74, 101);  // 'e'
  __mem_store8(literals_base() + 75, 119);  // 'w'
  __mem_store8(literals_base() + 76, 104);  // 'h'
  __mem_store8(literals_base() + 77, 105);  // 'i'
  __mem_store8(literals_base() + 78, 108);  // 'l'
  __mem_store8(literals_base() + 79, 101);  // 'e'
  __mem_store8(literals_base() + 80, 105);  // 'i'
  __mem_store8(literals_base() + 81, 110);  // 'n'
  __mem_store8(literals_base() + 82, 116);  // 't'
  __mem_store8(literals_base() + 83, 98);  // 'b'
  __mem_store8(literals_base() + 84, 111);  // 'o'
  __mem_store8(literals_base() + 85, 111);  // 'o'
  __mem_store8(literals_base() + 86, 108);  // 'l'
  __mem_store8(literals_base() + 87, 115);  // 's'
  __mem_store8(literals_base() + 88, 116);  // 't'
  __mem_store8(literals_base() + 89, 114);  // 'r'
  __mem_store8(literals_base() + 90, 105);  // 'i'
  __mem_store8(literals_base() + 91, 110);  // 'n'
  __mem_store8(literals_base() + 92, 103);  // 'g'
  __mem_store8(literals_base() + 93, 98);  // 'b'
  __mem_store8(literals_base() + 94, 105);  // 'i'
  __mem_store8(literals_base() + 95, 110);  // 'n'
  __mem_store8(literals_base() + 96, 97);  // 'a'
  __mem_store8(literals_base() + 97, 114);  // 'r'
  __mem_store8(literals_base() + 98, 121);  // 'y'
  __mem_store8(literals_base() + 99, 99);  // 'c'
  __mem_store8(literals_base() + 100, 97);  // 'a'
  __mem_store8(literals_base() + 101, 108);  // 'l'
  __mem_store8(literals_base() + 102, 108);  // 'l'
  __mem_store8(literals_base() + 103, 105);  // 'i'
  __mem_store8(literals_base() + 104, 100);  // 'd'
  __mem_store8(literals_base() + 105, 101);  // 'e'
  __mem_store8(literals_base() + 106, 110);  // 'n'
  __mem_store8(literals_base() + 107, 116);  // 't'
  __mem_store8(literals_base() + 108, 97);  // 'a'
  __mem_store8(literals_base() + 109, 100);  // 'd'
  __mem_store8(literals_base() + 110, 100);  // 'd'
  __mem_store8(literals_base() + 111, 115);  // 's'
  __mem_store8(literals_base() + 112, 117);  // 'u'
  __mem_store8(literals_base() + 113, 98);  // 'b'
  __mem_store8(literals_base() + 114, 109);  // 'm'
  __mem_store8(literals_base() + 115, 117);  // 'u'
  __mem_store8(literals_base() + 116, 108);  // 'l'
  __mem_store8(literals_base() + 117, 100);  // 'd'
  __mem_store8(literals_base() + 118, 105);  // 'i'
  __mem_store8(literals_base() + 119, 118);  // 'v'
  __mem_store8(literals_base() + 120, 101);  // 'e'
  __mem_store8(literals_base() + 121, 113);  // 'q'
  __mem_store8(literals_base() + 122, 110);  // 'n'
  __mem_store8(literals_base() + 123, 101);  // 'e'
  __mem_store8(literals_base() + 124, 108);  // 'l'
  __mem_store8(literals_base() + 125, 116);  // 't'
  __mem_store8(literals_base() + 126, 103);  // 'g'
  __mem_store8(literals_base() + 127, 116);  // 't'
  __mem_store8(literals_base() + 128, 108);  // 'l'
  __mem_store8(literals_base() + 129, 101);  // 'e'
  __mem_store8(literals_base() + 130, 103);  // 'g'
  __mem_store8(literals_base() + 131, 101);  // 'e'
  __mem_store8(literals_base() + 132, 97);  // 'a'
  __mem_store8(literals_base() + 133, 110);  // 'n'
  __mem_store8(literals_base() + 134, 100);  // 'd'
  __mem_store8(literals_base() + 135, 111);  // 'o'
  __mem_store8(literals_base() + 136, 114);  // 'r'
  __mem_store8(literals_base() + 137, 110);  // 'n'
  __mem_store8(literals_base() + 138, 111);  // 'o'
  __mem_store8(literals_base() + 139, 116);  // 't'
  __mem_store8(literals_base() + 140, 95);  // '_'
  __mem_store8(literals_base() + 141, 95);  // '_'
  __mem_store8(literals_base() + 142, 109);  // 'm'
  __mem_store8(literals_base() + 143, 101);  // 'e'
  __mem_store8(literals_base() + 144, 109);  // 'm'
  __mem_store8(literals_base() + 145, 95);  // '_'
  __mem_store8(literals_base() + 146, 115);  // 's'
  __mem_store8(literals_base() + 147, 116);  // 't'
  __mem_store8(literals_base() + 148, 111);  // 'o'
  __mem_store8(literals_base() + 149, 114);  // 'r'
  __mem_store8(literals_base() + 150, 101);  // 'e'
  __mem_store8(literals_base() + 151, 95);  // '_'
  __mem_store8(literals_base() + 152, 95);  // '_'
  __mem_store8(literals_base() + 153, 109);  // 'm'
  __mem_store8(literals_base() + 154, 101);  // 'e'
  __mem_store8(literals_base() + 155, 109);  // 'm'
  __mem_store8(literals_base() + 156, 95);  // '_'
  __mem_store8(literals_base() + 157, 115);  // 's'
  __mem_store8(literals_base() + 158, 116);  // 't'
  __mem_store8(literals_base() + 159, 111);  // 'o'
  __mem_store8(literals_base() + 160, 114);  // 'r'
  __mem_store8(literals_base() + 161, 101);  // 'e'
  __mem_store8(literals_base() + 162, 56);  // '8'
  __mem_store8(literals_base() + 163, 95);  // '_'
  __mem_store8(literals_base() + 164, 95);  // '_'
  __mem_store8(literals_base() + 165, 109);  // 'm'
  __mem_store8(literals_base() + 166, 101);  // 'e'
  __mem_store8(literals_base() + 167, 109);  // 'm'
  __mem_store8(literals_base() + 168, 95);  // '_'
  __mem_store8(literals_base() + 169, 108);  // 'l'
  __mem_store8(literals_base() + 170, 111);  // 'o'
  __mem_store8(literals_base() + 171, 97);  // 'a'
  __mem_store8(literals_base() + 172, 100);  // 'd'
  __mem_store8(literals_base() + 173, 95);  // '_'
  __mem_store8(literals_base() + 174, 95);  // '_'
  __mem_store8(literals_base() + 175, 109);  // 'm'
  __mem_store8(literals_base() + 176, 101);  // 'e'
  __mem_store8(literals_base() + 177, 109);  // 'm'
  __mem_store8(literals_base() + 178, 95);  // '_'
  __mem_store8(literals_base() + 179, 108);  // 'l'
  __mem_store8(literals_base() + 180, 111);  // 'o'
  __mem_store8(literals_base() + 181, 97);  // 'a'
  __mem_store8(literals_base() + 182, 100);  // 'd'
  __mem_store8(literals_base() + 183, 56);  // '8'
  __mem_store8(literals_base() + 184, 95);  // '_'
  __mem_store8(literals_base() + 185, 95);  // '_'
  __mem_store8(literals_base() + 186, 102);  // 'f'
  __mem_store8(literals_base() + 187, 100);  // 'd'
  __mem_store8(literals_base() + 188, 95);  // '_'
  __mem_store8(literals_base() + 189, 119);  // 'w'
  __mem_store8(literals_base() + 190, 114);  // 'r'
  __mem_store8(literals_base() + 191, 105);  // 'i'
  __mem_store8(literals_base() + 192, 116);  // 't'
  __mem_store8(literals_base() + 193, 101);  // 'e'
  __mem_store8(literals_base() + 194, 95);  // '_'
  __mem_store8(literals_base() + 195, 95);  // '_'
  __mem_store8(literals_base() + 196, 102);  // 'f'
  __mem_store8(literals_base() + 197, 100);  // 'd'
  __mem_store8(literals_base() + 198, 95);  // '_'
  __mem_store8(literals_base() + 199, 114);  // 'r'
  __mem_store8(literals_base() + 200, 101);  // 'e'
  __mem_store8(literals_base() + 201, 97);  // 'a'
  __mem_store8(literals_base() + 202, 100);  // 'd'
  __mem_store8(literals_base() + 203, 95);  // '_'
  __mem_store8(literals_base() + 204, 95);  // '_'
  __mem_store8(literals_base() + 205, 102);  // 'f'
  __mem_store8(literals_base() + 206, 100);  // 'd'
  __mem_store8(literals_base() + 207, 95);  // '_'
  __mem_store8(literals_base() + 208, 99);  // 'c'
  __mem_store8(literals_base() + 209, 108);  // 'l'
  __mem_store8(literals_base() + 210, 111);  // 'o'
  __mem_store8(literals_base() + 211, 115);  // 's'
  __mem_store8(literals_base() + 212, 101);  // 'e'
  __mem_store8(literals_base() + 213, 95);  // '_'
  __mem_store8(literals_base() + 214, 95);  // '_'
  __mem_store8(literals_base() + 215, 112);  // 'p'
  __mem_store8(literals_base() + 216, 97);  // 'a'
  __mem_store8(literals_base() + 217, 116);  // 't'
  __mem_store8(literals_base() + 218, 104);  // 'h'
  __mem_store8(literals_base() + 219, 95);  // '_'
  __mem_store8(literals_base() + 220, 111);  // 'o'
  __mem_store8(literals_base() + 221, 112);  // 'p'
  __mem_store8(literals_base() + 222, 101);  // 'e'
  __mem_store8(literals_base() + 223, 110);  // 'n'
  __mem_store8(literals_base() + 224, 95);  // '_'
  __mem_store8(literals_base() + 225, 95);  // '_'
  __mem_store8(literals_base() + 226, 116);  // 't'
  __mem_store8(literals_base() + 227, 116);  // 't'
  __mem_store8(literals_base() + 228, 121);  // 'y'
  __mem_store8(literals_base() + 229, 95);  // '_'
  __mem_store8(literals_base() + 230, 103);  // 'g'
  __mem_store8(literals_base() + 231, 101);  // 'e'
  __mem_store8(literals_base() + 232, 116);  // 't'
  __mem_store8(literals_base() + 233, 95);  // '_'
  __mem_store8(literals_base() + 234, 109);  // 'm'
  __mem_store8(literals_base() + 235, 111);  // 'o'
  __mem_store8(literals_base() + 236, 100);  // 'd'
  __mem_store8(literals_base() + 237, 101);  // 'e'
  __mem_store8(literals_base() + 238, 95);  // '_'
  __mem_store8(literals_base() + 239, 95);  // '_'
  __mem_store8(literals_base() + 240, 116);  // 't'
  __mem_store8(literals_base() + 241, 116);  // 't'
  __mem_store8(literals_base() + 242, 121);  // 'y'
  __mem_store8(literals_base() + 243, 95);  // '_'
  __mem_store8(literals_base() + 244, 115);  // 's'
  __mem_store8(literals_base() + 245, 101);  // 'e'
  __mem_store8(literals_base() + 246, 116);  // 't'
  __mem_store8(literals_base() + 247, 95);  // '_'
  __mem_store8(literals_base() + 248, 114);  // 'r'
  __mem_store8(literals_base() + 249, 97);  // 'a'
  __mem_store8(literals_base() + 250, 119);  // 'w'
  __mem_store8(literals_base() + 251, 95);  // '_'
  __mem_store8(literals_base() + 252, 95);  // '_'
  __mem_store8(literals_base() + 253, 116);  // 't'
  __mem_store8(literals_base() + 254, 116);  // 't'
  __mem_store8(literals_base() + 255, 121);  // 'y'
  __mem_store8(literals_base() + 256, 95);  // '_'
  __mem_store8(literals_base() + 257, 114);  // 'r'
  __mem_store8(literals_base() + 258, 101);  // 'e'
  __mem_store8(literals_base() + 259, 115);  // 's'
  __mem_store8(literals_base() + 260, 116);  // 't'
  __mem_store8(literals_base() + 261, 111);  // 'o'
  __mem_store8(literals_base() + 262, 114);  // 'r'
  __mem_store8(literals_base() + 263, 101);  // 'e'
  __mem_store8(literals_base() + 264, 109);  // 'm'
  __mem_store8(literals_base() + 265, 97);  // 'a'
  __mem_store8(literals_base() + 266, 105);  // 'i'
  __mem_store8(literals_base() + 267, 110);  // 'n'
  // "v1" at offset 268
  __mem_store8(literals_base() + 268, 118);  // 'v'
  __mem_store8(literals_base() + 269, 49);  // '1'
  // "i64" at offset 270
  __mem_store8(literals_base() + 270, 105);  // 'i'
  __mem_store8(literals_base() + 271, 54);  // '6'
  __mem_store8(literals_base() + 272, 52);  // '4'
  // "f32" at offset 273
  __mem_store8(literals_base() + 273, 102);  // 'f'
  __mem_store8(literals_base() + 274, 51);  // '3'
  __mem_store8(literals_base() + 275, 50);  // '2'
  // "f64" at offset 276
  __mem_store8(literals_base() + 276, 102);  // 'f'
  __mem_store8(literals_base() + 277, 54);  // '6'
  __mem_store8(literals_base() + 278, 52);  // '4'
  // "str" at offset 279
  __mem_store8(literals_base() + 279, 115);  // 's'
  __mem_store8(literals_base() + 280, 116);  // 't'
  __mem_store8(literals_base() + 281, 114);  // 'r'
  // "int_i64" at offset 282
  __mem_store8(literals_base() + 282, 105);  // 'i'
  __mem_store8(literals_base() + 283, 110);  // 'n'
  __mem_store8(literals_base() + 284, 116);  // 't'
  __mem_store8(literals_base() + 285, 95);  // '_'
  __mem_store8(literals_base() + 286, 105);  // 'i'
  __mem_store8(literals_base() + 287, 54);  // '6'
  __mem_store8(literals_base() + 288, 52);  // '4'
  // "float_f32" at offset 289
  __mem_store8(literals_base() + 289, 102);  // 'f'
  __mem_store8(literals_base() + 290, 108);  // 'l'
  __mem_store8(literals_base() + 291, 111);  // 'o'
  __mem_store8(literals_base() + 292, 97);  // 'a'
  __mem_store8(literals_base() + 293, 116);  // 't'
  __mem_store8(literals_base() + 294, 95);  // '_'
  __mem_store8(literals_base() + 295, 102);  // 'f'
  __mem_store8(literals_base() + 296, 51);  // '3'
  __mem_store8(literals_base() + 297, 50);  // '2'
  // "float_f64" at offset 298
  __mem_store8(literals_base() + 298, 102);  // 'f'
  __mem_store8(literals_base() + 299, 108);  // 'l'
  __mem_store8(literals_base() + 300, 111);  // 'o'
  __mem_store8(literals_base() + 301, 97);  // 'a'
  __mem_store8(literals_base() + 302, 116);  // 't'
  __mem_store8(literals_base() + 303, 95);  // '_'
  __mem_store8(literals_base() + 304, 102);  // 'f'
  __mem_store8(literals_base() + 305, 54);  // '6'
  __mem_store8(literals_base() + 306, 52);  // '4'
  // "array_alloc" at offset 307
  __mem_store8(literals_base() + 307, 97);  // 'a'
  __mem_store8(literals_base() + 308, 114);  // 'r'
  __mem_store8(literals_base() + 309, 114);  // 'r'
  __mem_store8(literals_base() + 310, 97);  // 'a'
  __mem_store8(literals_base() + 311, 121);  // 'y'
  __mem_store8(literals_base() + 312, 95);  // '_'
  __mem_store8(literals_base() + 313, 97);  // 'a'
  __mem_store8(literals_base() + 314, 108);  // 'l'
  __mem_store8(literals_base() + 315, 108);  // 'l'
  __mem_store8(literals_base() + 316, 111);  // 'o'
  __mem_store8(literals_base() + 317, 99);  // 'c'
  // "array_get" at offset 318
  __mem_store8(literals_base() + 318, 97);  // 'a'
  __mem_store8(literals_base() + 319, 114);  // 'r'
  __mem_store8(literals_base() + 320, 114);  // 'r'
  __mem_store8(literals_base() + 321, 97);  // 'a'
  __mem_store8(literals_base() + 322, 121);  // 'y'
  __mem_store8(literals_base() + 323, 95);  // '_'
  __mem_store8(literals_base() + 324, 103);  // 'g'
  __mem_store8(literals_base() + 325, 101);  // 'e'
  __mem_store8(literals_base() + 326, 116);  // 't'
  // "array_set" at offset 327
  __mem_store8(literals_base() + 327, 97);  // 'a'
  __mem_store8(literals_base() + 328, 114);  // 'r'
  __mem_store8(literals_base() + 329, 114);  // 'r'
  __mem_store8(literals_base() + 330, 97);  // 'a'
  __mem_store8(literals_base() + 331, 121);  // 'y'
  __mem_store8(literals_base() + 332, 95);  // '_'
  __mem_store8(literals_base() + 333, 115);  // 's'
  __mem_store8(literals_base() + 334, 101);  // 'e'
  __mem_store8(literals_base() + 335, 116);  // 't'
  // "string_typed" at offset 336
  __mem_store8(literals_base() + 336, 115);  // 's'
  __mem_store8(literals_base() + 337, 116);  // 't'
  __mem_store8(literals_base() + 338, 114);  // 'r'
  __mem_store8(literals_base() + 339, 105);  // 'i'
  __mem_store8(literals_base() + 340, 110);  // 'n'
  __mem_store8(literals_base() + 341, 103);  // 'g'
  __mem_store8(literals_base() + 342, 95);  // '_'
  __mem_store8(literals_base() + 343, 116);  // 't'
  __mem_store8(literals_base() + 344, 121);  // 'y'
  __mem_store8(literals_base() + 345, 112);  // 'p'
  __mem_store8(literals_base() + 346, 101);  // 'e'
  __mem_store8(literals_base() + 347, 100);  // 'd'
  // "str_len" at offset 348
  __mem_store8(literals_base() + 348, 115);  // 's'
  __mem_store8(literals_base() + 349, 116);  // 't'
  __mem_store8(literals_base() + 350, 114);  // 'r'
  __mem_store8(literals_base() + 351, 95);  // '_'
  __mem_store8(literals_base() + 352, 108);  // 'l'
  __mem_store8(literals_base() + 353, 101);  // 'e'
  __mem_store8(literals_base() + 354, 110);  // 'n'
  // "str_ptr" at offset 355
  __mem_store8(literals_base() + 355, 115);  // 's'
  __mem_store8(literals_base() + 356, 116);  // 't'
  __mem_store8(literals_base() + 357, 114);  // 'r'
  __mem_store8(literals_base() + 358, 95);  // '_'
  __mem_store8(literals_base() + 359, 112);  // 'p'
  __mem_store8(literals_base() + 360, 116);  // 't'
  __mem_store8(literals_base() + 361, 114);  // 'r'
  // "struct_lit" at offset 362
  __mem_store8(literals_base() + 362, 115);  // 's'
  __mem_store8(literals_base() + 363, 116);  // 't'
  __mem_store8(literals_base() + 364, 114);  // 'r'
  __mem_store8(literals_base() + 365, 117);  // 'u'
  __mem_store8(literals_base() + 366, 99);   // 'c'
  __mem_store8(literals_base() + 367, 116);  // 't'
  __mem_store8(literals_base() + 368, 95);   // '_'
  __mem_store8(literals_base() + 369, 108);  // 'l'
  __mem_store8(literals_base() + 370, 105);  // 'i'
  __mem_store8(literals_base() + 371, 116);  // 't'
  // "field" at offset 372
  __mem_store8(literals_base() + 372, 102);  // 'f'
  __mem_store8(literals_base() + 373, 105);  // 'i'
  __mem_store8(literals_base() + 374, 101);  // 'e'
  __mem_store8(literals_base() + 375, 108);  // 'l'
  __mem_store8(literals_base() + 376, 100);  // 'd'
  // "field_assign" at offset 377
  __mem_store8(literals_base() + 377, 102);  // 'f'
  __mem_store8(literals_base() + 378, 105);  // 'i'
  __mem_store8(literals_base() + 379, 101);  // 'e'
  __mem_store8(literals_base() + 380, 108);  // 'l'
  __mem_store8(literals_base() + 381, 100);  // 'd'
  __mem_store8(literals_base() + 382, 95);   // '_'
  __mem_store8(literals_base() + 383, 97);   // 'a'
  __mem_store8(literals_base() + 384, 115);  // 's'
  __mem_store8(literals_base() + 385, 115);  // 's'
  __mem_store8(literals_base() + 386, 105);  // 'i'
  __mem_store8(literals_base() + 387, 103);  // 'g'
  __mem_store8(literals_base() + 388, 110);  // 'n'
  __mem_store(literals_inited_addr(), 1);
  return 0;
}
